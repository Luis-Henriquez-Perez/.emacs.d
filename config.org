* Core
:PROPERTIES:
:ID:       d68434bf-be6a-471f-ab65-e151f4f1c111
:END:

** Initialize
:PROPERTIES:
:ID:       71dbf82e-cf4f-4e8a-b14d-df78bea5b20f
:END:

*** don't garbage collect during initialization
:PROPERTIES:
:ID:       4913461b-8421-4a64-b09a-18c54673d7d7
:END:

[[id:86653a5a-f273-4ce4-b89b-f288d5d46d44][gcmh]] will take care of setting the gc-cons-threshold back to normal.

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

*** config files and directores
:PROPERTIES:
:ID:       be8993d3-c8f7-451b-8cb4-04a9138e5c4e
:END:

**** important directories
:PROPERTIES:
:ID:       17fd696e-6140-4d9b-9d17-053c2dced786
:END:

#+begin_src emacs-lisp
(defconst VOID-EMACS-DIR (file-truename user-emacs-directory)
  "Path to `user-emacs-directory'.")

(defconst VOID-LOCAL-DIR (concat VOID-EMACS-DIR ".local/")
  "Path to the directory for local Emacs files.
Files that need to exist, but I don't typically want to see go here.")

(defconst VOID-DATA-DIR (concat VOID-LOCAL-DIR "data/")
  "Path to the directory where Void data files are stored.")

(defconst VOID-PACKAGES-DIR (concat VOID-LOCAL-DIR "packages/")
  "Path to the directory where packages are stored.")

(defconst VOID-ORG-DIR (concat VOID-EMACS-DIR "org/")
  "Directory where org files should go.")
#+end_src

**** important files
:PROPERTIES:
:ID:       d01a33a8-c6e8-433c-9850-6bd7ea0488f9
:END:

#+begin_src emacs-lisp
(defconst VOID-INIT-FILE (concat VOID-EMACS-DIR "init.el")
  "Path to the elisp file that bootstraps Void startup.")

(defconst VOID-MAIN-ORG-FILE (concat VOID-EMACS-DIR "config.org")
  "Path to config file used for tangling.")

(defconst VOID-MAIN-ELISP-FILE (concat VOID-EMACS-DIR "main.el")
  "Path to elisp file.")
#+end_src

**** recipe file
:PROPERTIES:
:ID:       96efba8a-9935-4684-8063-b7e043ced4bd
:END:

I want my configuration to be fully reproducible. Therefore, I have a file that
contains the recipes for the packages I install.

#+begin_src emacs-lisp
(defconst VOID-RECIPE-FILE (concat VOID-ORG-DIR "recipes.org")
  "File that contains recipes for my installed packages.")
#+end_src

**** ensure directories exist
:PROPERTIES:
:ID: 56e80dda-5d0e-4c7c-a225-00d0028d4995
:END:

#+begin_src emacs-lisp
(dolist (dir (list VOID-LOCAL-DIR VOID-DATA-DIR VOID-PACKAGES-DIR))
  (make-directory dir t))
#+end_src

*** debug-p
:PROPERTIES:
:ID:       39197346-c420-4518-b8f8-8ea247d6decb
:END:

[[helpvar:void-debug-p][void-debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable
is to serve as an indicator of whether the current Void instance is run for
debugging. When Void is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][void-log]].

#+begin_src emacs-lisp
(defvar void-debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

** Package Management
:PROPERTIES:
:ID:       00eaa1a5-b5fe-437d-9888-1846ea9a232b
:END:

The purpose of this headline is to set up the package manager and install all of
my packages so the rest of the file can assume the packages are already
installed. The idea is to separate package installation and package configuration.

*** package recipes
:PROPERTIES:
:ID:       e8860d22-6070-4bc7-a5fc-0f155f566624
:END:

#+begin_src emacs-lisp
(defun void-package-recipes ()
  "Return a list of all package recipes in `VOID-RECIPE-FILE'."
  (with-temp-buffer
    (let (forms)
      (insert-file-contents VOID-RECIPE-FILE)
      (goto-char (point-min))
      (while (re-search-forward (rx bol "(") nil t nil)
        (goto-char (match-beginning 0))
        (push (read (current-buffer)) forms))
      forms)))
#+end_src

*** recipe list
:PROPERTIES:
:ID:       05b4ade0-2e46-4976-b43d-da09b134d602
:END:

#+begin_src emacs-lisp
(defvar void-recipe-list (void-package-recipes)
  "List of package recipes.")
#+end_src

*** straight.el
:PROPERTIES:
:ID:       86037015-ca61-48f9-96bf-df8fc625a35d
:RECIPE:   [[id:8de43077-14dc-492a-9ac2-55521683def2][straight.el]]
:END:

[[straight][straight.el]] is a package manager that installs packages by cloning their git
repositories from online and building them from source. A consequence of this is
that you have the history of every installed emacs package locally. Another
consequence is that you can completely reproduce the state of your emacs on
another machine by installing the same packages with the same versions.

**** variables
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

#+begin_src emacs-lisp
(setq straight-vc-git-default-clone-depth 1)
(setq straight-base-dir VOID-PACKAGES-DIR)
(setq straight-use-package-version 'straight)
(setq straight-use-package-by-default t)
(setq straight-enable-package-integration t)
(setq straight-disable-autoloads nil)
(setq straight-cache-autoloads t)
(setq straight-check-for-modifications nil)
(setq straight-enable-package-integration nil)
(setq straight-recipes-emacsmirror-use-mirror t)
#+end_src

**** straight initialization code
:PROPERTIES:
:ID:       ab38beca-2f26-4718-ab73-e4e4409f1563
:END:

#+begin_src emacs-lisp
(defun void-init-straight ()
  (defvar bootstrap-version)
  (let* ((straight-base-dir straight-base-dir)
	 (straight-repo-dir (concat straight-base-dir "straight/repos/"))
	 (bootstrap-file (concat straight-repo-dir "straight.el/bootstrap.el"))
	 (bootstrap-version 5)
	 (straight-commit (plist-get (alist-get 'straight void-recipe-list) :commit))
	 (straight-el-link "https://github.com/raxod502/straight.el.git"))
    (unless (file-exists-p bootstrap-file)
      (make-directory straight-repo-dir t)
      (shell-command
       (format "git -C %s clone %s" straight-repo-dir straight-el-link))
      (shell-command
       (format "git -C %s checkout %s" straight-repo-dir straight-commit)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

*** install packages
:PROPERTIES:
:ID:       a694267f-b37d-487b-ac68-c1da9e1fe776
:END:

#+begin_src emacs-lisp
(void-init-straight)
(mapc #'straight-use-package
      (progn (require 'map)
	     (map-delete (void-package-recipes) 'straight)))
#+end_src

** Library
:PROPERTIES:
:ID:       70af1291-6b16-4261-ba83-19bb16d0023e
:END:

This headline contains all the the helper functions and macros I defined for
customizing emacs.

*** essential libraries
:PROPERTIES:
:ID:       18602d49-dcc3-47c3-8579-62f7a7b7a83a
:END:

These are packages that I use to make writing lisp code more convenient. Emacs
Lisp is a full-featured, turing-complete language. However, for some data
structures like hash-tables and alists it is missing consistently named
functions for performing operations on these data structures. This is improving
slowly with the introduction of libraries like =seq.el= and =map.el= but still
leaves much to be desired.

**** shut-up
:PROPERTIES:
:ID:       71681f9f-2760-4cee-95a0-4aeb71191a42
:RECIPE:   [[id:2ac6175d-d2a8-4da5-9000-c55615167bc7][shut-up]]
:END:

This package provides a macro named =shut-up= that as its name suggests, silences
output of any forms within it. Emacs itself and many emacs packages spew
messages. While these messages can be nice to know, more often than not I get it
now and I don't want to see them again.

#+begin_src emacs-lisp
(require 'shut-up)
#+end_src

**** dash
:PROPERTIES:
:ID:       7885c48d-0ead-4d77-8de1-e9faec58b583
:RECIPE:   [[id:cbb8f3bc-571b-4d96-8a2a-ca249ec2ba77][dash]]
:END:

Dash is rich list manipulation library. Many of the functions it has are already
found in some form or another in emacs in features such as =cl-lib= and =seq= and
=subr=, but dash has some very convenient functions and macros over emacs (such as
=-let)=. Moreover, a lot of work has been put into making it's functions efficient;
some are even more efficient than built-in cl functions. Additionally, it's
already used as a dependency of very many packages so I'll likely end up loading
it anyway.

#+begin_src emacs-lisp
(require 'dash)
#+end_src

**** dash-functional
:PROPERTIES:
:ID:       704fc35f-0ad0-4eb3-9eb5-d8335465dbd8
:RECIPE:   [[id:9137dafe-016c-4a59-8a98-b76d7190c6b6][dash-functional]]
:END:

=dash-functional= provides "function combinators". These are functions that take
one or more functions as arguments and return a function. One example of this is
emacs's [[helpfn:apply-partially][apply-partially]]. These functions can help.

#+begin_src emacs-lisp
(require 'dash-functional)
#+end_src

**** s
:PROPERTIES:
:ID: 4b82deb0-bbe1-452c-8b60-ef734efb86d8
:RECIPE:   [[id:23693687-0bbb-4751-94a8-0fceae62c887][s]]
:END:

=s= is an api for strings inspired by [[id:704fc35f-0ad0-4eb3-9eb5-d8335465dbd8][dash]].

#+begin_src emacs-lisp
(require 's)
#+end_src

**** anaphora
:PROPERTIES:
:ID:       1c47bd8a-15f1-4b1c-9574-23547d27d968
:RECIPE:   [[id:742af191-a59d-453b-b334-5eb0da1e7929][anaphora]]
:END:

It's common to want to refer to the thing you're operating on in lisp and in
many other languages. In lisp this often requires assigning the variable a name.
But if you're only.

#+begin_src emacs-lisp
(require 'anaphora)
#+end_src

*** generic advices
:PROPERTIES:
:ID:       8fb485ec-5387-46da-820e-629dcf004962
:END:

There are some advices that are so generic and used so often that they do not
lend themselves to =defadvice!=. This headline demonstrates how I deal with
them.

**** silence
:PROPERTIES:
:ID:       7eddba70-8597-4af7-bc93-6ebdcc06ee6c
:END:

Often I want to silence the output of certain functions.

#+begin_src emacs-lisp
(defun void--silence-output-advice (orig-fn &rest args)
  "Silence output for the duration of ORIGN-FN."
  (shut-up (apply orig-fn args)))

(defun void-silence-output (fn)
  "Silence output for the duration of ORIGN-FN."
  (void-add-advice fn :around #'void--silence-output-advice))
#+end_src

**** reduce gc-cons-threshold
:PROPERTIES:
:ID:       41e763bd-215f-4176-95c1-f41261864671
:END:

Some functions are very expensive and deserve.

#+begin_src emacs-lisp
(defun void--pause-garbage-collection-advice (orign-fn &rest args)
  "Pause garbage collection for the duration of ORIGN-FN."
  (let ((gc-cons-threshold VOID-GC-CONS-THRESHOLD-MAX))
    (apply orign-fn args)))

(defun void-pause-garbage-collection (fn)
  "Pause garbage collection for the duration of FN."
  (void-add-advice fn :around #'void--pause-garbage-collection-advice))
#+end_src

**** log
:PROPERTIES:
:ID:       843d4ca9-ea52-46ea-9d77-bfd9e7222669
:END:

#+begin_src emacs-lisp
(defun void--message-with-void-log-advice (orign-fn &rest args)
  "Use `void-log' instead of `message'."
  (cl-letf (((symbol-function 'message) #'void-log))
    (apply orig-fn args)))

(defun void-message-with-void-log (fn)
  "Use `void-log' instead of `message'."
  (void-add-advice fn :around #'void--message-with-void-log-advice))
#+end_src

*** macro writing tools
:PROPERTIES:
:ID:       ea5d3295-d8f9-4f3a-a1f6-25811696aa29
:END:

These are tools that are specifically designed to help me write macros.

**** macro keyword arguments
:PROPERTIES:
:ID:       dc7a63e6-041b-4855-b206-6d72ef732de1
:END:

Following past examples (such as), I initially opted for allowing keyword
arguments in the "function args" part of defun-like macros. This is fine when
there's only one keyword argument, but any more and it starts to get crowded. It
doesn't help that emacs functions tend towards longer names due to a lack of
namespaces. Therefore, I support keyword args in the function body.

#+begin_src emacs-lisp
(defun void--keyword-macro-args (body)
  "Return list of (docstring KEYWORD-ARGS BODY)."
  (list (when (stringp (car body)) (pop body))
        (--unfold (when (keywordp (car it))
                    (cons (cons (pop body) (pop body))
                          body))
                  body)
        body))
#+end_src

**** symbols
:PROPERTIES:
:ID: 2cdf8ab1-4e59-4128-a8a4-e5519ca0f4bf
:END:

Conversion between symbols, keywords, and strings are prevalent in
macro-writing.

***** symbol intern
:PROPERTIES:
:ID: 659e8389-84c5-4ac4-a9ba-7dd40599191d
:END:

#+begin_src emacs-lisp
(defun void-symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'void-to-string args)))
#+end_src

***** keyword intern
:PROPERTIES:
:ID: f2668044-13b2-46e7-bf84-fcf998591e37
:END:

Sometimes I want to create a keyword by interning a string or a symbol. This
commands saves me having to add the colon at the beginning before interning.

#+begin_src emacs-lisp
(defun void-keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'void-symbol-intern ":" args))
#+end_src

***** keyword name
:PROPERTIES:
:ID: fb867938-d62b-42fc-bf07-092f10b64f22
:END:

Calling [[helpfn:symbol-name][symbol-name]] on a keyword returns the keyword as a string. However often we
don't want the prepended colon on they keyword. This function is for that
occasion.

#+begin_src emacs-lisp
(defun void-keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (void-to-string keyword) 1))
#+end_src

***** convert to string
:PROPERTIES:
:ID: 4ef52875-4ce6-4940-8b7e-13c96bedcb3d
:END:

This function is for converting something to a string, no questions asked. I use
it when I don't want to be bothered with details and just want a string.

#+begin_src emacs-lisp
(defun void-to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (dolist (a args) (princ a))))
#+end_src

***** hook symbol
:PROPERTIES:
:ID:       7ae3dac1-058b-4b1b-a010-aeb5b121d3f6
:END:

#+begin_src emacs-lisp
(defun void-hook-symbol-p (symbol)
  "Return true if symbol is a hook symbol."
  (s-matches-p ".+-hook\\'" (symbol-name symbol)))
#+end_src

***** mode symbol
:PROPERTIES:
:ID:       ec25e275-c36f-4cee-be04-1fdf8c974857
:END:

#+begin_src emacs-lisp
(defun void-mode-symbol-p (symbol)
  "Return non-nil if symbol is a mode symbol."
  (s-matches-p ".+-mode\\'" (symbol-name symbol)))
#+end_src

**** wrap-form
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

#+begin_src emacs-lisp
(defun void-wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (void-wrap-form (cdr wrappers)
                      (append (car wrappers)
                              (list form)))
    form))
#+end_src

**** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:RECIPE:   [[id:e965dece-b144-4535-b623-5f648796f373][anaphora]]
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

***** anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst VOID-ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (1+ (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

***** anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p VOID-ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

***** true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match VOID-ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

***** body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
       (-filter #'void-anaphoric-symbol-p)
       (-uniq)))
#+end_src

***** all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun void-anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all VOID-ANAPHORIC-SYMBOL-REGEXP (void-to-string obj)))
#+end_src

*** eval-after-load!
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

=eval-after-load= is a macro that evaluates a lisp form after a file or feature
has been loaded. It's syntax is a bit terse because you need to quote the
feature as well as the form to be evaluated.

Also, if an =eval-after-load= block contains an error and it is triggered by a
feature, the error will happening. I think it might be that because the form was
not successfully evaluated =eval-after-load= does not realize it should stop
loading it. To remedy this I wrap the block with [[][condition-case]].

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  "A wrapper around `eval-after-load!' with error catching."
  (declare (indent defun))
  `(eval-after-load ',feature
     '(condition-case error
          (progn ,@body)
        (error
         (message "Error in `eval-after-load': %S" error)))))
#+end_src

*** dbc
:PROPERTIES:
:ID:       b3351a74-b2d0-42b8-9895-b6baad0adb0b
:RECIPE:   [[id:dc4a89b0-70b7-4594-b0ac-e5edcd155bed][dbc]]
:END:

=dbc= stands for "display-buffer-control". This package provides an interface for
working with [[helpfn:display-buffer-alist][display-buffer-alist]].

**** define rulesets
:PROPERTIES:
:ID:       577ff03c-40e0-4ac4-a3ab-47cd9d24992e
:END:

For now, I haven't found a buffer I'd like to display in any place other than
the bottom. I don't like it when buffer text is cutt off or truncated on the
side windows.

#+begin_src emacs-lisp
(require 'dbc)

(thread-last '(display-buffer-in-side-window . ((side . bottom) (window-height . 0.5)))
  (dbc-add-ruleset "bottom"))

(thread-last '(display-buffer-in-side-window . ((side . top) (window-height . 0.4)))
  (dbc-add-ruleset "top"))
#+end_src

*** after!
:PROPERTIES:
:ID:       e209d256-86e0-4e30-a7d5-78a583729b42
:END:

=after!= is yet another wrapper around == that can accept multiple features or
even a specification of features using =and= or =or=.

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from polluting the
[[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to =after-load-list= whether or not it has
been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Wrapper around `with-eval-after-load'."
  (declare (indent defun) (debug t))
  (cond ((eq 'or (car-safe features))
         (macroexp-progn
          (--map `(after! ,it ,@body) (cdr features))))
        ((eq 'and (car-safe features))
         (void-wrap-form (--map `(after! ,it) (cdr features))
                         (macroexp-progn body)))
        ((listp features)
         `(after! ,(cons 'and features) ,@body))
        ((symbolp features)
         `(if (featurep ',features)
              ,(macroexp-progn body)
            (eval-after-load! ,features ,@body)))
        (t (error "Invalid argument."))))
#+end_src

*** with-os!
:PROPERTIES:
:ID:       a3ea434a-3f70-4137-a525-5be4bc63c3a2
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows'(unquoted)."
  (declare (indent defun))
  (when (funcall (cond ((eq :not (car-safe os)) (-not #'member))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 (-list os))
    `(progn ,@body)))
#+end_src

*** ignore!
:PROPERTIES:
:ID:       e0173863-5b27-4afc-879a-17a6dce7ecd0
:END:

#+begin_src emacs-lisp
(defmacro ignore! (&rest _)
  "Do nothing and return nil."
  nil)
#+end_src

*** hooks
:PROPERTIES:
:ID:       a9fb6a01-ded5-405c-83ba-c401dbc06400
:END:

One of the most common ways to customize Emacs is via [[info:elisp#Hooks][hooks]]. Hooks are variables
containing functions (which are sometimes also referred to as hooks). The
functions in hooks are run after certain events, such as starting and quitting
emacs. Their purpose is to fascillitate customization of what happens before or
after particular events.

In this headline, I strive to establish a common naming convention for
"void-defined" hooks, so I can clearly distinguish them from pre-defined hooks.

**** void specific hook regexp
:PROPERTIES:
:ID:       91c9237a-9c47-48c0-abfc-c873155d5921
:END:

#+begin_src emacs-lisp
#+end_src

**** hook-p
:PROPERTIES:
:ID:       1995a309-e1d3-40e5-b6b1-fbcd81dda0bb
:END:

#+begin_src emacs-lisp
(defun void-defined-hook-symbol-p (symbol)
  "Return non-nil if SYMBOL is a void-specific hook."
  (alet "\\`[^[:space:]]+&[^[:space:]]+\\'"
    (s-matches-p it (symbol-name symbol))))
#+end_src

**** hook naming
:PROPERTIES:
:ID:       82e6a9e7-208a-48b0-b779-c14a0a7eca00
:END:

This section pertains to functions that help with the naming convention.

***** hook info
:PROPERTIES:
:ID:       4c093dca-87fc-4c61-ba45-a43b326d1ae0
:END:

#+begin_src emacs-lisp
(defsubst void--hook-info (hook-fn i)
  (intern (nth i (split-string (symbol-name hook-fn) "&" t))))
#+end_src

***** hook variable
:PROPERTIES:
:ID:       77f45347-3688-438d-8674-39e6d476a2d1
:END:

A useful consequence of the hook naming convention is I can determine precisely
which hook variable a function resides in based on looking at the name
(=emacs-startup-hook&do-something= would be a hook in =emacs-starup-hook= for
example). This proves to be useful for [[id:8506fa78-c781-4ca8-bd58-169cce23a504][expire advice]].

#+begin_src emacs-lisp
(defsubst void-hook-variable (hook-fn)
  "Return the hook variable HOOK-FN is in.
HOOK-FN is a function named with Void naming conventions."
  (void--hook-info hook-fn 0))
#+end_src

***** hook function
:PROPERTIES:
:ID:       fa705f26-31f0-43c3-80a6-6741e74ab0ea
:END:

#+begin_src emacs-lisp
(defun void-hook-function (hook-fn)
  "Return the function HOOK-FN."
  (void--hook-info hook-fn 1))
#+end_src

***** hook name
:PROPERTIES:
:ID:       6b14ea72-b8ef-493d-82e2-962f889736a2
:END:

This function determines how void-defined hooks are named. When possible they
should be in the form of some action so that the hook name will be of the form
=hook-variable&do-something=. Having the names like this makes it so you can
actually read through hook functions like reading a todo-list. It will be
apparent what's being done.

#+begin_src emacs-lisp
(defun void-hook-function-name (hook function)
  "Return name to give to void-defined hook function."
  (alet (acond ((void-mode-symbol-p function)
		(void-symbol-intern 'enable- function))
	       ((nth 1 (s-match "void--\\(.+\\)-hook" (symbol-name function)))
		it)
	       (t function))
    (void-symbol-intern hook '& it)))
#+end_src

**** generate a hook
:PROPERTIES:
:ID:       01cdecef-a345-45f0-b38e-5fe0b4939b08
:END:

When there's a bug with a function (also called a hook) added to a hook
variable, it interferes with the running of the hook variable. Evaluation
stops at the error; as a result hooks following the bugged function aren't
evaluated. All in all, you get an unpleasant experience with partially
evaluated code. I've faced this problem numerous times, mostly when I failed
to autoload the hook for a mode and as a result get a =void-function= error
in the middle of the mode's hook.

I would prefer an elegant failure. By this, I mean I'd like the "problem"
function to report the problem to me without short-circuiting. This is why I
wrap hook functions in a [[helpfn:condition-case][condition-case]] block.

#+begin_src emacs-lisp
(defun void-generate-hook-function (hook function)
  "Return a Void hook function.
The function does the same thing as FUNCTION, but errors are caught."
  (alet (void-hook-function-name hook function)
    (fset it
	  `(lambda (&rest args)
	     (condition-case err
		 (apply #',function args)
	       (error
		(void-log "%s failed." ',function)))))
    it))
#+end_src

**** adding hooks
:PROPERTIES:
:ID:       882bc5d2-a0e2-4ea7-b9d2-ab64b3407f82
:END:

***** internal helper
:PROPERTIES:
:ID:       aaf7ab9a-0648-4f1b-b30e-85ce0acac602
:END:

Add a hook that follow naming conventions. When adding a hook, if it is a void
function, change it to a hook.

#+begin_src emacs-lisp
(defun void--add-hook (hook function &optional depth local expire-fn)
  "Generate a Void hook function and add it to HOOK."
  (let ((hook-fn (void-generate-hook-function hook function)))
    (add-hook hook hook-fn depth local)
    (void-log-function hook-fn)
    (when expire-fn
      (alet (void-expire-advice hook-fn expire-fn t)
	(advice-add new-hook :around it)))))
#+end_src

***** adding hooks
:PROPERTIES:
:ID:       10dcca8f-7dd0-45da-a413-43608c098b10
:END:

This is a simple wrapper around [[id:][void--add-hook]] that handles multiple hook
variables and hook functions.

#+begin_src emacs-lisp
(defun void-add-hook (hooks functions &optional depth local expire-fn)
  "Generate Void hook functions and add them to HOOKS."
  (dolist (hook (-list hooks))
    (dolist (fn (-list functions))
      (void--add-hook hook fn depth local expire-fn))))
#+end_src

**** removing hooks
:PROPERTIES:
:ID:       99708d72-a8d4-42ba-b6ae-ba692fbafec8
:END:

#+begin_src emacs-lisp
(defun void-remove-hook (fn)
  "Remove a void hook."
  (remove-hook (void-hook-var fn) fn))
#+end_src

**** defhook!
:PROPERTIES:
:ID:       4daf2baf-ea7f-41f5-9f86-63168089149a
:END:

=defhook= provides a declarative way declare hook functions. It uses a familiar
defun-like syntax.

#+begin_src emacs-lisp
(defmacro defhook! (name args &rest body)
  "Define a hook function and attatch it to HOOK and HOOKS.
DEPTH and LOCAL are the same as in `add-hook'. BODY is the body of the hook
function.

\(NAME (HOOK &REST HOOKS &OPTIONAL DEPTH LOCAL) &rest BODY)"
  (declare (doc-string 3))
  (-let* ((hooks (-take-while (-not #'keywordp) args))
          (local (plist-get hooks :local))
          (depth (or (plist-get hooks :append) (plist-get hooks :depth)))
          ((docstring _ body) (void--keyword-macro-args body))
          (hook-name (void-symbol-intern 'void-- name '-hook)))
    `(progn
       ,@(mapcar (lambda (hook)
                   `(aprog1 (defun ,hook-name (&rest _) ,docstring ,@body)
                      (void-add-hook ',hook it ,depth ,local)))
                 hooks))))
#+end_src

*** advice
:PROPERTIES:
:ID:       19b9021d-f310-485b-9258-4df19423c082
:END:

[[info:elisp#Advising Functions][Advising]] is one of the most powerful ways to customize emacs's behavior.

I want to name advices so that they can be distinguished from other functions. I
also want to be able to deduce the function being advised from the name.

In this headline I provide a macro to concisely define functions that
are specifically intended to advise other functions and to ensure that
these functions are named properly. All user-defined advising
functions should have the format =TARGET@ACTION=, where =TARGET= is the
function being advised and =ACTION= is the action the advise is
performing. This naming scheme is inspired and taken from the one
introduced by [[helpfn:define-advice][define-advice]].

**** advice-p
:PROPERTIES:
:ID:       0a84d983-39ad-48d1-af9d-b43589d63bcf
:END:

This function should be used to distinguish advices I add to functions over
advices that have been added by Emacs or other packages.

#+begin_src emacs-lisp
(defun void-defined-advice-symbol-p (fn)
  "Return non-nil if FN is a void advice."
  (s-matches-p (rx (1+ (not white)) "@" (1+ (not white)))
               (symbol-name fn)))
#+end_src

**** logging certain functions
:PROPERTIES:
:ID:       1ccfaa39-924f-4b1d-82b2-e458511cbb1b
:END:

I make distinctions between different kinds of functions such as advices, hook
functions and interactive functions. Depending on which type of function it is I
want to log it differently.

***** log message
:PROPERTIES:
:ID:       f0f4d5fd-2ce2-408c-8a4d-f55e39744132
:END:

#+begin_src emacs-lisp
(defun void--log-message (fn)
  "Return the message logged."
  (pcase fn
    ((pred void-defined-hook-symbol-p)
     (format "& %s -> %s"
	     (void-hook-variable fn)
	     (void-hook-function fn)))
    ((pred void-defined-advice-symbol-p)
     (format "@ %s -> %s"
	     (void-advice-symbol fn)
	     (void-advice-function fn)))
    (_
     (format "%s called" fn))))
#+end_src

***** log advice
:PROPERTIES:
:ID:       25ea174f-af84-49e3-ad13-c797ef4ee6b2
:END:

Maybe it's overkill having an advice just to log a function. But it helps
maintain maximum purity and extensibility.

#+begin_src emacs-lisp
(defun void-log-function (fn &optional after)
  "Log calls to FN.
Add a log to *void-log* after function is called.
This function should be primarly used for side-effect but does incidentally return the
log function that is added to FN."
  (aprog1 (void-symbol-intern fn '@ 'log)
    (fset it `(lambda (&rest _) (void-log ,(void--log-message fn))))
    (advice-add fn (if after :after :before) it)))
#+end_src

**** naming advice
:PROPERTIES:
:ID:       d8773074-d384-48b8-aa89-f99c8098753a
:END:

***** advice symbol
:PROPERTIES:
:ID:       74aee21a-3549-488b-b6f1-de9549e7e358
:END:

#+begin_src emacs-lisp
(defun void-advice-symbol-p (symbol)
  (s-match "\\(.+\\)@.+" (symbol-name symbol)))
#+end_src

***** advised symbol
:PROPERTIES:
:ID:       f893fbe8-592b-409e-8de7-6060e936456f
:END:

It's easy to find which functions are advising a given function using
[[helpfn:advice-mapc][advice-mapc]]. However, it's not as easy to go the other way around--to determine
what which function a given advice is advising. Another complicaiton is that
it's possible for a given advice to advise multiple functions. With the naming
system I provide, doing this is trivial.

#+begin_src emacs-lisp
(defun void-advice-symbol (fn)
  "Return the symbol."
  (->> (symbol-name fn)
       (s-match "\\([^[:space:]]+\\)@[^[:space:]]+")
       (nth 1)
       (intern)))
#+end_src

***** advice name
:PROPERTIES:
:ID:       03416f82-ced7-42a0-843b-6975903f0b38
:END:

This is where I try to convert a symbol and an advice into a symbol@action.

#+begin_src emacs-lisp
(defun void-advice-name (symbol advice)
  "Return advice name that meets Void naming conventions."
  (alet (nth 1 (s-match "void--\\(.+\\)-advice" (symbol-name advice)))
    (void-symbol-intern symbol '@ (or it advice))))
#+end_src

**** adding advice
:PROPERTIES:
:ID:       3ab8947c-15f0-4fb7-bd75-f0baabc20ec1
:END:

Since adding an advice to multiple functions is done frequently.

***** helper
:PROPERTIES:
:ID:       4750f4dc-053b-4062-bd6c-aeeed6cdbcd9
:END:

Often, I advise functions with other existing functions (such as =#'ignore=)
instead of defining my own advices. To maintain consistency with the naming
convention I created [[helpfn:void-add-advice][void-add-advice]]. It will create an advice with an
appropriate name to target.

#+begin_src emacs-lisp
(defun void--add-advice (symbol where fn &optional props expire-fn)
  "Advise SYMBOLS with Void ADVICES."
  (let ((advice (void-advice-name symbol fn)))
    (defalias advice fn)
    (advice-add symbol where advice props)
    (void-log-function advice)
    (when expire-fn
      (alet (void-expire-advice advice expire-fn t)
	(advice-add advice :around it)))))
#+end_src

***** adding advice
:PROPERTIES:
:ID:       1298ea9d-870c-45da-9424-9cf8c66f7403
:END:

#+begin_src emacs-lisp
(defun void-add-advice (symbols where advices &optional props expire-fn)
  "Advise TARGETS with Void ADVICES."
  (dolist (symbol (-list symbols))
    (dolist (advice (-list advices))
      (void--add-advice symbol where advice props expire-fn))))
#+end_src

**** remove advice
:PROPERTIES:
:ID:       3d13ea95-44aa-4261-8480-5ae9701d533d
:END:

Since we can get the advisee from the advise name, or remove advice only needs
one argument--the advice to remove.

#+begin_src emacs-lisp
(defun void-remove-advice (advice)
  "Remove advice."
  (advice-remove (void-advice-symbol advice) advice))
#+end_src

**** advice action
:PROPERTIES:
:ID:       f15279e9-cd0c-4a74-bc74-389d14a4b82a
:END:

#+begin_src emacs-lisp
(defun void-advice-function (advice)
  "Return the action for advice."
  (->> (symbol-name advice)
       (s-match (rx "@" (group (1+ (not (any "@" white)))) eos))
       (nth 1)))
#+end_src

**** expire advice
:PROPERTIES:
:ID:       8506fa78-c781-4ca8-bd58-169cce23a504
:END:

Often there are functions you want to advise just once. For example, loading a
feature just before a function that needs it is called. Although it's harmless,
you don't want to keep reloading the feature everytime the function is called.
The way I handle this situation is by creating a function that generates an
=expire-advice=. When an =expire-advice= it will.

Note that this function returns must be evaluated with lexical binding to work.

#+begin_src emacs-lisp
(defun void-expire-advice (fn &optional expire-fn unbind)
  "Return an advice that causes FN to expire when EXPIRE-FN returns true.
FN is a function. EXPIRE-FN is a function that returns true when FN
should expire."
  (let ((expire-advice (void-advice-name fn 'expire))
        (expire-fn (or expire-fn t)))
    (fset expire-advice
          `(lambda (orig-fn &rest args)
             (aprog1 (apply orig-fn args)
               (when (or (eq t #',expire-fn) (funcall #',expire-fn))
                 (when (void-defined-advice-symbol-p #',fn)
                   (void-remove-advice #',fn))
                 (when (void-defined-hook-symbol-p #',fn)
                   (void-remove-hook #',fn))
                 (advice-remove #',fn #',expire-advice)
                 (when ,unbind (fmakunbound #',expire-advice))
                 (void-log "%s has expired." #',fn)
                 (when ,unbind (fmakunbound #',fn))))))))
#+end_src

**** defadvice!
:PROPERTIES:
:ID:       1e0f3a27-a7d8-4e28-a359-f42ed7a16033
:END:

This section pertains to [[helpfn:defadvice!][defadvice!]], a replacement for [[helpfn:define-advice][define-advice]] that
provides a declarative way to define advices. This should be used for one-time
advices that.

***** define-advice!
:PROPERTIES:
:ID:       cc161eaf-a8fb-4e24-853f-a76a49c28dcf
:END:

The only difference between this and [[helpfn:define-advice][define-advice]] is that =NAME= and =SYMBOL= are
switched. In my opinion, the unique part of the function name being first is
more consistent with =defun=.

#+begin_src emacs-lisp
(defmacro define-advice! (name args &rest body)
  "A wrapper around `define-advice'.
The only difference is that this switches the order the arguments have to be
passed in.

\(fn ACTION (WHERE &optional ADVICE-ARGS TARGET &rest TARGETS) &rest BODY)"
  (declare (indent 2) (doc-string 3) (debug (sexp sexp body)))
  (unless (listp args)
    (signal 'wrong-type-argument (list #'listp args)))
  (-let (((where lambda-args fn props) args)
         (advice-name (intern (format "void--%s-advice" name))))
    `(aprog1 (defun ,name ,lambda-args ,@body)
       (void-add-advice #',fn ,where it ,props))))
#+end_src

***** anaphoric defadvice!
:PROPERTIES:
:ID:       98b2ce63-da31-4f7a-b776-1ee1747b5d57
:END:

=anaphoric-define-advice!= lets you omit the =lambda-args=. If you do omit the
arguments and you want to use them, you can do so via [[id:9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df][anaphoric variables]].

Note that [[helpfn:help-function-arglist][help-function-arglist]] returns =t= when it fails to get the function
arguments.

#+begin_src emacs-lisp
(defmacro anaphoric-define-advice! (name args &rest body)
  "A variant of `define-advice!'.
Unlike `define-advice!', this macro does not take an arglist as an argument.
Instead, arguments are accessed via anaphoric variables.

\(fn ACTION (WHERE TARGET &rest TARGETS) &rest BODY)"
  (-let* (((where target . other-args) args)
          (advice-args (if (eq where :around)
                           '(<orig-fn> &rest <args>)
                         '(&rest <args>))))
    `(define-advice! ,name (,where ,advice-args ,target ,@other-args)
       (ignore <args>)
       (cl-progv
           (->> (alet (help-function-arglist #',target t)
		  ;; kind of a hack...
		  (if (eq t it) nil it))
		(--remove (s-starts-with-p "@" (symbol-name it)))
		(--map (intern (format "<%s>" (symbol-name it)))))
	   <args>
	 ,@body))))
#+end_src

***** defadvice!
:PROPERTIES:
:ID:       d8773e00-1abe-4b03-82f0-07b47e93ccb4
:END:

This macro takes care of allowing multiple advices and deciding between whether
to use =defadvice!= or =anaphoric-defadvice!=.

#+begin_src emacs-lisp
(defmacro defadvice! (name args &rest body)
  "Define and advice.

\(fn ACTION (WHERE &optional ARGS-LIST TARGET &rest TARGETS) &rest BODY)"
  (-let* ((symbols-only (lambda (it) (and (symbolp it) (not (keywordp it)))))
          ((before fns after) (-partition-by symbols-only args))
          (advice-macro (if (listp (nth 1 args))
                            'define-advice!
                          'anaphoric-define-advice!)))
    `(progn
       ,@(--map `(,advice-macro ,name (,@before ,it ,@after) ,@body)
                fns))))
#+end_src

*** list mutation
:PROPERTIES:
:ID:       d9f77404-5c29-4305-ae53-e409e1b06b99
:END:

***** append!
:PROPERTIES:
:ID: f314672c-f9f3-4630-9402-a9a65215c153
:END:

#+begin_src emacs-lisp
(defmacro append! (sym &rest lists)
  "Append LISTS to SYM.
SYM is a symbol that stores a list."
  (declare (indent 1))
  `(setq ,sym (append ,sym ,@lists)))
#+end_src

***** prepend!
:PROPERTIES:
:ID: 3395dec3-0915-49cd-9445-d3db2b1ffe7f
:END:

#+begin_src emacs-lisp
(defmacro prepend! (sym &rest lists)
  (declare (indent defun))
  `(setq ,sym (append ,@lists ,sym)))
#+end_src

***** nconc!
:PROPERTIES:
:ID: b24d1d8f-f3e1-4dca-afdb-8fb73d5299c3
:END:

#+begin_src emacs-lisp
(defmacro nconc! (sym &rest lists)
  "Append LISTS to SYM by altering them in place."
  (declare (indent 1))
  `(setq ,sym (nconc ,sym ,@lists)))
#+end_src

*** loading on call
:PROPERTIES:
:ID:       fa6583aa-5e7c-4212-be8a-b90b4c08aa31
:END:

Instead of loading all features on startup, we want to load features only when
we need them--just in time. And by "just in time" I mean at the last possible
moment or in practice just before a function that uses this feature is called.
While I could use =defadvice!= for defining these advices, doing this would
quickly become repetative because it's something that is done so often in
package configuration. The function =before-call= and =after-call= provide a fast
and convenient way to do this.

**** load-on-call
:PROPERTIES:
:ID:       324e707b-2f44-4168-a846-037f5401dedb
:END:

#+begin_src emacs-lisp
(defun void--load-on-call (package where functions &optional enable)
  "Load packages FUNCTIONS are called."
  (alet (void-symbol-intern 'void--load- package '-advice)
    (fset it `(lambda (&rest _)
                (void-log "Loading %s" ',package)
                (require ',package)
                (when ,enable
                  (funcall-interactively #',(void-symbol-intern package '-mode) 1))))
    (void-add-advice functions where it nil t)))
#+end_src

**** load before call
:PROPERTIES:
:ID:       cc0e92bc-cd6d-4994-82ea-eb065fc3ad89
:END:

#+begin_src emacs-lisp
(defun void-load-before-call (package functions &optional enable)
  (void--load-on-call package :before functions enable))
#+end_src

**** load after call
:PROPERTIES:
:ID:       b0b294d0-15ac-42d9-9e4c-fd9da8a95206
:END:

#+begin_src emacs-lisp
(defun void-load-after-call (package functions &optional enable)
  (void--load-on-call package :after functions enable))
#+end_src


** Keybindings
:PROPERTIES:
:ID:       b0680fe6-23eb-412f-a357-bfa5e5bb7af7
:END:

*** prefix bindings
:PROPERTIES:
:ID: b0b5b51c-155e-46fc-a80a-0d45a32440ba
:END:

A popular strategy to mitigate the mental load of remembering many keybindings
is to bind them in a tree-like fashion (see [[https://github.com/syl20bnr/spacemacs][spacemacs]]).

**** leader Keys
:PROPERTIES:
:ID: 143211d6-b868-4ffb-a5d0-25a77dee401f
:END:

#+begin_src emacs-lisp
(defconst VOID-LEADER-KEY "SPC"
  "The evil leader prefix key.")

(defconst VOID-LEADER-ALT-KEY "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")
#+end_src

**** localleader keys
:PROPERTIES:
:ID: 45941bcb-209f-4aa3-829a-dee4e3ef2464
:END:

#+begin_src emacs-lisp
(defconst VOID-LOCALLEADER-KEY "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst VOID-LOCALLEADER-ALT-KEY "C-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defconst VOID-LOCALLEADER-SHORT-KEY ","
  "A shorter alternative `void-localleader-key'.")

(defconst VOID-LOCALLEADER-SHORT-ALT-KEY "M-,"
  "A short non-normal  `void-localleader-key'.")
#+end_src

*** general
:PROPERTIES:
:ID: 706f35fc-f840-4a51-998f-abcd54c5d314
:RECIPE:   [[id:07ef3d86-164b-4810-b82a-2930aea3de4f][general]]
:END:

There are numerous keybinding functions in Emacs; and they all look a little
different: there's [[helpfn:global-set-key][global-set-key]], [[helpfn:local-set-key][local-set-key]], [[helpfn:define-key][define-key]] and the list goes
on. And with [[https://github.com/emacs-evil/evil.git][evil]] which [[id:73366b3e-7438-4abf-a661-ed1553b1b8df][I use]] , there's also [[helpfn:evil-global-set-key][evil-global-set-key]] and
[[helpfn:evil-define-key][evil-define-key]]. [[https://github.com/noctuid/general.el.git][general]] provides a function that you can use for all bindings
([[helpfn:general-define-key][general-define-key]]).

**** init
:PROPERTIES:
:ID:       2d0487ba-0150-47f2-a3d5-9d3c26e64c31
:END:

#+begin_src emacs-lisp
(require 'general)
#+end_src

**** unbind keys
:PROPERTIES:
:ID:       ffff6e7c-35c7-45e2-b2ad-6bca21bf8c1d
:END:

One error you'll often get when defining keys is.

#+begin_src emacs-lisp
(general-auto-unbind-keys)
#+end_src

**** definers
:PROPERTIES:
:ID: 6444d218-1627-48bd-9b5c-7bfffb17d912
:END:

As I've mentioned =general= uses the function =general-define-key= as a generic
do-all key binder. Sometimes though we have keys that we want to bind with
specific arguments to =general-define-key= pretty often. A typical example of
this is binding =leader= or =localleader= keys like [[https://github.com/syl20bnr/spacemacs][spacemacs]].

This form creates a macro =define-leader-key!= that.

#+begin_src emacs-lisp
(general-create-definer define-leader-key!
  :prefix VOID-LEADER-KEY
  :non-normal-prefix VOID-LEADER-ALT-KEY
  :keymaps 'override
  :states '(normal motion insert emacs))
#+end_src

**** localleader
:PROPERTIES:
:ID:       e4770eae-adf5-4216-9016-5ec4bc465e03
:END:

There's pros and cons to the =SPC m= binding. The main pro is that it's
consistent with =SPC=. With the leader and the localleader, this means that you
can reach any binding from just =SPC=. This means that you can discover all
bindings from just one root binding. This is a nice property to have. On the
other hand, bindings can get a bit long. That one extra character can really
make a difference. That's why.

#+begin_src emacs-lisp
(defmacro define-localleader-key! (&rest args)
  (declare (indent defun))
  (alet `(:keymaps 'override
	  :states '(normal motion insert emacs)
	  ,@args)
    `(progn (general-def
              :prefix VOID-LOCALLEADER-KEY
              :non-normal-prefix VOID-LOCALLEADER-ALT-KEY
              ,@it)
            (general-def
              :prefix VOID-LOCALLEADER-SHORT-KEY
              :non-normal-prefix VOID-LOCALLEADER-SHORT-ALT-KEY
              ,@it))))
#+end_src

**** aliases
:PROPERTIES:
:ID:       81031f16-179e-4da7-9d83-7da5459fbdbd
:END:

In addition to providing keybinding stuff, =general= also provides.

#+begin_src emacs-lisp
(defalias 'define-key! 'general-def)

(defalias 'set! 'general-setq)
(defalias 'set-default! 'gsetq-default)

(defalias 'gsetq 'general-setq)
(defalias 'gsetq-default 'general-setq-default)
#+end_src

** Packages
:PROPERTIES:
:ID:       d5c0d112-319d-4271-a819-eb786a64bfc6
:END:

*** calc
:PROPERTIES:
:ID:       98c0a8c7-2dc1-4285-9b7b-146bbc2867ae
:END:

*** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(setq vc-follow-link t)
(setq vc-follow-symlinks t)
#+end_src

*** subr-x
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(require 'subr-x)
#+end_src

*** startup
:PROPERTIES:
:ID: 9725b7e0-54b8-4ab4-aa00-d950345d0aea
:TYPE:     built-in
:END:

#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
(setq inhibit-default-init t)
(setq inhibit-startup-buffer-menu t)
(setq initial-major-mode 'fundamental-mode)
(setq initial-scratch-message nil)
(setq initial-buffer-choice #'void-initial-buffer)
#+end_src

*** paren
:PROPERTIES:
:ID: 8ba80d6f-292e-4d44-acfe-d7b7ba939fa4
:TYPE:     built-in
:END:

#+begin_src emacs-lisp
(setq show-paren-delay 0)
(void-add-hook 'prog-mode-hook #'show-paren-mode)
#+end_src

*** clipboard
:PROPERTIES:
:ID: 60abb076-89b1-439b-8198-831b2df47782
:TYPE:     built-in
:END:

#+begin_src emacs-lisp
(setq selection-coding-system 'utf-8)
(setq select-enable-clipboard t)
(setq select-enable-primary t)
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

*** simple
:PROPERTIES:
:ID: 89df102a-a2c9-4ece-9acc-ed90e8064ed8
:TYPE:     built-in
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "messages" :newname "\\*Messages\\*")

(setq idle-update-delay 1)
(setq blink-matching-paren t)
(setq delete-trailing-lines nil)

(setq mail-user-agent 'mu4e-user-agent)
#+end_src

*** loaddefs
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:TYPE:     built-in
:END:

These are *extremely* important lines if you use an external program as I do
([[https://wiki.archlinux.org/index.php/Msmtp][msmtp]]) to send your email. If you don't set these variables, emacs will
think you want to use =smtp=.

#+begin_src emacs-lisp
(setq disabled-command-function nil)
#+end_src

*** files
:PROPERTIES:
:ID: 2a7862da-c863-416b-a976-4cf7840a8712
:TYPE:     built-in
:END:

Disable second, case-insensitive pass over `auto-mode-alist'.
#+begin_src emacs-lisp
(setq auto-mode-case-fold nil)
#+end_src
Whether to add a newline automatically at the end of the file.
Whether confirmation is requested before visiting a new file or buffer.
#+begin_src emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)
#+end_src
How to ask for confirmation when leaving Emacs.
#+begin_src emacs-lisp
(setq confirm-kill-emacs #'y-or-n-p)
(setq require-final-newline nil)
(setq trash-directory (expand-file-name "Trash" "~"))
(setq auto-save-default nil)
(setq auto-save-interval 300)
(setq auto-save-timeout 30)
(setq backup-directory-alist (list (cons ".*" (concat VOID-DATA-DIR "backup/"))))
(setq make-backup-files nil)
(setq version-control nil)
(setq kept-old-versions 2)
(setq kept-new-versions 2)
(setq delete-old-versions t)
(setq backup-by-copying t)
(setq backup-by-copying-when-linked t)
#+end_src

*** subr-x
:PROPERTIES:
:ID:       1ed0ba00-e5a1-4642-9ed5-a52f4b917a4d
:END:

#+begin_src emacs-lisp
(require 'subr-x)
#+end_src

*** ffap
:PROPERTIES:
:ID: b1229201-a5ac-45c7-91fa-7a6b39bbb879
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(after! ffap
  (setq ffap-machine-p-known 'reject))
#+end_src

*** server
:PROPERTIES:
:ID: 3ddeb65c-9df6-4ede-9644-eb106b3ba1dd
:END:

#+begin_src emacs-lisp
(after! server
  (setq server-auth-dir (concat VOID-DATA-DIR "server/")))
#+end_src

*** tramp
:PROPERTIES:
:ID: 3af0a4d6-bd08-4fe2-bc5c-79b1b811fc6b
:RECIPE:   [[id:0ee52136-7a9a-42a5-9afe-c4374dd98ebb][tramp]]
:END:

#+begin_src emacs-lisp
(after! tramp
  (setq tramp-backup-directory-alist backup-directory-alist)
  (setq tramp-auto-save-directory (concat VOID-DATA-DIR "tramp-auto-save/"))
  (setq tramp-persistency-file-name (concat VOID-DATA-DIR "tramp-persistency.el")))
#+end_src

*** cus-edit
:PROPERTIES:
:ID: 8bd5683d-91e1-4c1b-a8a5-3b39921e995d
:END:

#+begin_src emacs-lisp
(setq custom-file null-device)
(setq custom-theme-directory (concat VOID-LOCAL-DIR "themes/"))
#+end_src

*** url
:PROPERTIES:
:ID: e4b5bfce-1111-48b2-bfee-da754974aa46
:END:

#+begin_src emacs-lisp
(setq url-cache-directory (concat VOID-DATA-DIR "url/cache/"))
(setq url-configuration-directory (concat VOID-DATA-DIR "url/configuration/"))
#+end_src

*** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(setq byte-compile-verbose void-debug-p)
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
#+end_src

*** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(setq compilation-always-kill t)
(setq compilation-ask-about-save nil)
(setq compilation-scroll-output 'first-error)
#+end_src

*** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(after! uniquify
  (setq uniquify-buffer-name-style 'forward))
#+end_src

*** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(after! ansi-color
  (setq ansi-color-for-comint-mode t))
#+end_src

*** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

Non-nil means animated images loop forever, rather than playing once.

#+begin_src emacs-lisp
(setq image-animate-loop t)
#+end_src

*** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(after! window
  (setq split-width-threshold 160))
#+end_src

*** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(after! indent
  (setq tab-always-indent t))
#+end_src

*** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:


#+begin_src emacs-lisp
(setq mouse-yank-at-point t)
#+end_src

*** calendar
;; :PROPERTIES:
;; :ID:       4ad7e704-f490-40e4-b2bc-8a30a10a7bb7
;; :END:

(setq diary-file (concat VOID-DATA-DIR "diary"))

(after! calendar
  (require 'f)
  (unless (f-exists-p diary-file)
    (f-touch diary-file)))

*** mule-cmds
:PROPERTIES:
:ID:       e48e925e-1f1e-4c79-8652-c92aafe06290
:END:

(setq prefer-coding-system VOID-DEFAULT-CODING-SYSTEM)

*** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(after! gv
  (gv-define-simple-setter plist-get plist-put))
#+end_src

*** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(setq nsm-settings-file (concat VOID-DATA-DIR "network-settings.data"))
#+end_src

*** browse-url
:PROPERTIES:
:ID:       e59dc362-5615-45a8-8010-a111ddc5e835
:END:

=browse-url= is a built-in package that provides a useful abstraction for browsing
the web.

**** always open url in new windows
:PROPERTIES:
:ID:       6ae5e9b6-4be3-4689-b539-3959e9d20f23
:END:

Strive to always open url in new windows. While using exwm, having each
window be in it's own buffer lends itself better to searching them via
[[helpfn:switch-to-buffer][switch-to-buffer]] and the like.

#+begin_src emacs-lisp
(setq browse-url-firefox-new-window-is-tab nil)
(setq browse-url-new-window-flag t)
(setq browse-url-firefox-arguments nil)

(alet (list (cons (rx "http://www.wikipedia.org/search") #'w3m)
	    (cons "." #'browse-url-firefox))
  (setq browse-url-browser-function it))
#+end_src

** Miscellaneous
:PROPERTIES:
:ID:       65edb4e7-0fe1-4e37-ae9b-027c9f15162a
:END:

This headline contains headings for which I have not yet determined a good
hierarchy.

*** tangling
:PROPERTIES:
:ID:       adf94410-e747-4d5a-b9dc-7b7b249b8c76
:END:

The most inconvenient time to tangle an org file is during emacs startup because
it can significantly increase startup time. Tangling at this time should be done
only as a last resort. This heading provides hooks that try to sneak in a tangle
during the current emacs session to minimize this "worst-case" scenario and
thereby minimize startup time.

**** determine whether to tangle
:PROPERTIES:
:ID:       9408329a-ab73-4bcc-9416-d2cea8fa37bb
:END:

If you looked at my init file you'll see that I already defined a variant of
this function. I define it here from scratch so this file will be independent of
my =init.el=.

#+begin_src emacs-lisp
(defun void-needs-tangling-p ()
  "Return t if void needs taggling."
  (or (not (file-exists-p VOID-MAIN-ELISP-FILE))
      (file-newer-than-file-p VOID-MAIN-ORG-FILE VOID-MAIN-ORG-FILE)))
#+end_src

**** load tangling functions
:PROPERTIES:
:ID:       27c742d6-1145-4be1-9c24-46e1613df247
:END:

This function is meant to be used as the first argument for =async-start=. This
function and [[][[] end up doing the same thing but this one is more indirect
about it. It achieves tangling by evaluating the init file but without loading
the main elisp file. I do it this way because my tangling function is not
defined in a new emacs process. I considered injecting the raw function object
into a lambda so I could essentially redefine the function in the new emacs
process but that would only work if the function's definiton only depends on
built-in emacs variables and functions.

#+begin_src emacs-lisp
(defun void-load-init-file-only ()
  "Load init file."
  (let ((old-fn (symbol-function 'load))
	(user-init-file (concat user-emacs-directory "init.el")))
    (require 'cl)
    (cl-letf (((symbol-function 'load)
	       (lambda (file &rest args)
		 (when (string= user-init-file file)
                   (apply old-fn file args)))))
      (load user-init-file))))
#+end_src

**** indicate if tangling successful
:PROPERTIES:
:ID:       066857c8-b9bb-4660-899d-0bea725d2b15
:END:

The purpose of this function is simply to log the outcome of whether tangling
has been successful or not. It's used as the second argument of =async-start=.

#+begin_src emacs-lisp
(defun void-log-tangling-outcome ()
  "Log whether tangling successful."
  (alet (if (void-needs-tangling-p) " failed" " succeeded")
    (void-log "%s tangling `VOID-MAIN-ORG-FILE'." it)))
#+end_src

**** tangle asyncronously
:PROPERTIES:
:ID:       9f3cfe06-dae6-48e1-864d-914a176a177b
:END:

This hook tangles my org file during saves and, crucially, it does so
asynchronously--meaning that a separate emacs process does this tangling. Emacs
is single-threaded, so doing it synchronously will likely cause a significant
"hangs" or pauses after each save.

#+begin_src emacs-lisp
(defun void-tangle-async-maybe (&optional log-output-p)
  "Tangle `VOID-MAIN-ORG-FILE' asynchronously."
  (when (void-needs-tangling-p)
    (async-start #'void-load-init-file-only
		 (when log-output-p #'void-log-tangling-outcome))))
#+end_src

**** tangle on quit
:PROPERTIES:
:ID:       d7ee4164-61a3-4b82-bc68-4673446707b9
:END:

#+begin_src emacs-lisp
(void-add-hook 'kill-emacs-hook #'void-tangle-async-maybe)
#+end_src

**** tangle on save
:PROPERTIES:
:ID:       585b1e28-950b-4901-ac90-487facdf0b70
:END:

When saving from a file I also make sure that I'm saving the main org file so I
don't tangle needlessly.

#+begin_src emacs-lisp
(defhook! tangle-async-maybe (after-save-hook)
  "When I'm saving from `VOID-MAIN-ORG-FILE', tangle it."
  (when (aand (buffer-file-name)
	      (string= VOID-MAIN-ELISP-FILE it))
    (void-tangle-async-maybe)))
#+end_src

*** disable =auto-save-directory= from being created
:PROPERTIES:
:ID:       eca1df47-5c58-4606-8036-a9b8de3ec962
:END:

As per [[https://emacs.stackexchange.com/questions/18677/prevent-auto-save-list-directory-to-be-created][this stackoverflow question]], this prevents the =auto-save-directory= from
being created.

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix nil)
#+end_src

*** log the init time
:PROPERTIES:
:ID:       36e2113f-a28f-4ef2-bb90-141f82291c91
:END:

I find it convenient to be able to view the init time in the =*void-log*= buffer.

#+begin_src emacs-lisp
(defhook! log-init-time (emacs-startup-hook :append t)
  "Log the init time."
  (void-log "emacs-init-time -> %s" (emacs-init-time)))
#+end_src

*** set the fill-column
:PROPERTIES:
:ID:       84d8e85a-a6a1-49cd-b46e-e5cd3f825438
:END:

Fill column refers to the column where line-wrapping will occur.

#+begin_src emacs-lisp
(setq-default fill-column 80)
#+end_src

*** recursive minibuffers
:PROPERTIES:
:ID:       7eb20f6d-75b4-4eec-8878-e7232c1a153d
:END:

This means that you can use the minibuffer while in the minibuffer. One
situation where I use this feature is in the command [[helpfn:eval-expression][eval-expression]]. As I'm
typing an expression, I get completion from the minibuffer.

#+begin_src emacs-lisp
(setq-default enable-recursive-minibuffers t)
#+end_src

*** stop initial echo message
:PROPERTIES:
:ID:       c619e1ee-1109-4f1b-b1ba-53fcb8ceae4e
:END:

If you just set [[helpvar:inhibit-startup-echo-area-message][inhibit-startup-echo-area-message]] to =t= the word =nil= is messaged.
So it's best just to override the function entirely.

#+begin_src emacs-lisp
(void-add-advice #'display-startup-echo-area-message :override #'ignore)
#+end_src

*** use yes or no
:PROPERTIES:
:ID:       82a84315-2018-42e0-bd1a-74af7b722593
:END:

It suffices typing =y= or =n= as opposed to =yes= or =no=.

#+begin_src emacs-lisp
(void-add-advice #'yes-or-no-p :override #'y-or-n-p)
#+end_src

*** utf-8 text encoding
:PROPERTIES:
:ID:       26344072-c145-40bd-9ade-8c7f2eef54c8
:END:

#+begin_src emacs-lisp
(setq-default locale-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)

(set-language-environment 'utf-8)
(setq-default locale-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default default-file-name-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; (unless IS-WINDOWS
;;   (setq selection-coding-system 'utf-8))

(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

*** linux
:PROPERTIES:
:ID:       6572e618-e5ef-445b-90d6-14dc2c24f1a4
:END:

#+begin_src emacs-lisp
(with-os! linux
  (setq x-underline-at-descent-line t)
  (setq x-gtk-use-system-tooltips nil))
#+end_src

*** disable bi-directional text
:PROPERTIES:
:ID:       6c12f14c-75c7-4b30-9bb4-ca6e8d3cae47
:END:

Disabling bidirectional text provides a small performance boost. Bidirectional
text is useful for languages that read right to left.

#+begin_src emacs-lisp
(setq-default bidi-display-reordering 'left-to-right)
(setq-default bidi-paragraph-direction 'left-to-right)
#+end_src

*** scrolling
:PROPERTIES:
:ID:       c91bcd0f-da83-44a3-9d9e-e1f55dcdb642
:END:

#+begin_src emacs-lisp
(gsetq-default hscroll-margin 2)
(gsetq-default hscroll-step 1)
(gsetq-default scroll-conservatively 1001)
(gsetq-default scroll-margin 0)
(gsetq-default scroll-preserve-screen-position t)
#+end_src

*** fast scrolling
:PROPERTIES:
:ID:       964a8b3e-37b4-4d6b-9298-3a1be3cfe6aa
:END:

"More performant rapid scrolling over unfontified regions. May cause brief
spells of inaccurate fontification immediately after scrolling."

#+begin_src emacs-lisp
(gsetq fast-but-imprecise-scrolling t)
#+end_src

*** resize pixelwise
:PROPERTIES:
:ID:       02daff3d-e532-4cfa-a217-81e27627e7a7
:END:

;; https://github.com/baskerville/bspwm/issues/551#issuecomment-574975395

#+begin_src emacs-lisp
(gsetq window-resize-pixelwise t)
(gsetq frame-resize-pixelwise t)
#+end_src

*** inhibit startup messages
:PROPERTIES:
:ID:       e1ae4527-547e-46b8-b040-d9779bfe53ad
:END:

When emacs starts up it displays a message and it's own introduction screen. I
prefer not seeing that. I have my own [[][dashboard]] anyway.

#+begin_src emacs-lisp
(gsetq inhibit-startup-message t)
(gsetq inhibit-splash-screen t)
(void-add-advice 'startup-echo-area-message :override #'ignore)
#+end_src

*** disable cursor blinking
:PROPERTIES:
:ID:       fe8a259b-12e6-4e58-a324-eab831283a86
:END:

By default the cursor blinks. The point is so that it is easier to find on the
screen. Usually, however, I have no trouble finding it so I disable it.

#+begin_src emacs-lisp
(blink-cursor-mode -1)
#+end_src

*** stop beeping
:PROPERTIES:
:ID:       2a83cb3a-ca2e-4d9c-a296-340d33855614
:END:

#+begin_src emacs-lisp
(setq-default ring-bell-function #'ignore)
#+end_src

*** garbage collection
:PROPERTIES:
:ID: 27ad0de3-620d-48f3-aa32-dfdd0324a979
:END:

Emacs garbage collects too frequently for most modern machines. This makes emacs
less performant especially when performing a large number of calculations,
because it spends resources garbage collecting when it doesn't have to. Indeed,
increasing the value of [[helpvar:gc-cons-threshold][gc-cons-threshold]], the number of bytes of consing
between garbage collections, is known to make a notable difference in user
startup time. By default it is only 800 KB.

**** gc cons threshold
:PROPERTIES:
:ID: e15d257f-1b0f-421e-8b34-076b1d20e493
:END:

I define three levels on frequency with which emacs should perform garbage
collection.

#+begin_src emacs-lisp
(defconst VOID-GC-CONS-THRESHOLD-MAX most-positive-fixnum
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst VOID-GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
This is the value of `gc-cons-threshold' that should be used in typical usages.")

(defconst VOID-GC-CONS-THRESHOLD-MIN (eval-when-compile (* 4 1024 1024))
  "The value for `gc-cons-threshold'.")
#+end_src

**** gcmh
:PROPERTIES:
:ID:       86653a5a-f273-4ce4-b89b-f288d5d46d44
:RECIPE:   [[id:64d2f517-734e-4394-b8ff-0cb498a59162][gcmh]]
:END:

=gcmh= does three things. It reduces garbage collection by setting, it adds a
hook telling Emacs to gargbage collect during idle time, and it tells Emacs
to garbage collect more frequently when it's idle.

Note that I add gcmh mode hook at the end so that all the other hook commands
are done before setting the =gc-cons-threshold= back to a normal value.

#+begin_src emacs-lisp
(setq gcmh-idle-delay 5)
(setq gcmh-verbose void-debug-p)
(setq gcmh-high-cons-threshold VOID-GC-CONS-THRESHOLD)
(setq gcmh-low-cons-threshold VOID-GC-CONS-THRESHOLD-MIN)

(autoload #'gcmh-mode "gcmh" nil t nil)
(void-add-hook 'emacs-startup-hook #'gcmh-mode t)
#+end_src

**** minibuffer
:PROPERTIES:
:ID: 83f47b4d-a0e2-4275-9c1a-7e317fdc4e41
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! boost-garbage-collection (minibuffer-enter-hook)
  "Boost garbage collection settings to `VOID-GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold VOID-GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `void-gc-cons-threshold' after delay."
  (setq gc-cons-threshold VOID-GC-CONS-THRESHOLD))
#+end_src

*** theme
:PROPERTIES:
:ID: 2ac7c2fe-a2ba-4e55-a467-ff4af8850331
:END:

**** don't prompt me when loading theme
:PROPERTIES:
:ID:       eaa6531c-1188-41c7-a645-a82d9f482449
:END:

If you don't enable =custom-save-themes=, emacs asks you whether you're sure you
want to load a theme for security reasons. I prefer the convenience of not being
prompted.

#+begin_src emacs-lisp
(setq custom-safe-themes t)
#+end_src

**** loading theme
:PROPERTIES:
:ID: 7ae02d32-4652-494c-9e14-05f60ca60395
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar void-after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! run-after-load-theme-hook (:after load-theme)
  "Set up `void-load-theme-hook' to run after `load-theme' is called."
  (setq void-theme <theme>)
  (run-hooks 'void-after-load-theme-hook))
#+end_src

**** disable old themes first
:PROPERTIES:
:ID: 9d2f985b-8b0f-497f-982b-6f69c62179a9
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! disable-old-themes (:around load-theme)
  "Disable old themes before loading new ones."
  (mapc #'disable-theme custom-enabled-themes)
  (apply <orig-fn> <args>))
#+end_src

**** boost gc when loading theme
:PROPERTIES:
:ID:       447c9bc9-5aa8-40f9-8373-e8626183aef7
:END:

Loading a theme qualifies as an intensive operation as all the faces on the
screen need to be redisplayed.

#+begin_src emacs-lisp
(void-pause-garbage-collection #'load-theme)
#+end_src

*** disable terminal initialization
:PROPERTIES:
:ID: 63e351ad-9ef6-4034-9fca-861881c74d6a
:END:

When running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (void-add-advice #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

*** prevent emacs from killing certain buffers
:PROPERTIES:
:ID:       ae935cf5-7322-499c-96d7-20209d9b6641
:END:

I never want the =*scratch*= and =*Messages*= buffer to be killed. I owe this idea
to [[https://github.com/rememberYou/.emacs.d][rememberYou's Emacs]].

#+begin_src emacs-lisp
(defhook! lock-certain-buffers (after-init-hook)
  "Prevent certain buffers from being killed."
  (--each (list "*scratch*" "*Messages*")
    (with-current-buffer it
      (emacs-lock-mode 'kill))))
#+end_src

*** initial buffer choice
:PROPERTIES:
:ID:       8eb302a6-cbc0-40ed-a046-b4c2d3dbc997
:END:

#+begin_src emacs-lisp
(defun void-initial-buffer ()
  "Return the initial buffer to be displayed.
This function is meant to be used as the value of `initial-buffer-choice'."
  (alet (if void-debug-p  "*void-log*" "*scratch")
    (get-buffer-create it)))
#+end_src

*** aliases
:PROPERTIES:
:ID:       da7229b6-27a4-41b6-aa3a-07935b97d181
:END:

**** atom predicate
:PROPERTIES:
:ID:       d6e83bfb-aaac-4dcb-89e9-8f9b4ca92db7
:END:

=atom= is perhaps the only type predicate not to end in =p=.

#+begin_src emacs-lisp
(defalias 'atomp 'atom)
#+end_src

**** prefixed-core
:PROPERTIES:
:ID:       14b63dc9-1d95-4bd7-8b29-8b2b33bd1e69
:RECIPE:   [[id:62123143-83d9-4e0b-b35b-f277807c2084][prefixed-core]]
:END:

This package defines numerous aliases to existing commands in an attempt to make
commands more discoverable and naming schemes more consistent.

#+begin_src emacs-lisp
(require 'prefixed-core)
#+end_src

*** keyfreq
:PROPERTIES:
:ID:       626b35f7-eef1-4a75-b2dc-8600c1ac47b7
:RECIPE:   [[id:c967f1d3-cb23-4cb8-a65e-2d5bac6ff245][keyfreq]]
:END:

=keyfreq= records the frequency of key strokes.

#+begin_src emacs-lisp
(void-add-hook 'emacs-startup-hook #'keyfreq-mode)
(autoload #'keyfreq-mode "keyfreq" nil t nil)
#+end_src

*** idle-require
:PROPERTIES:
:ID:       0d619336-e852-4c6a-89a8-38ccbb71a077
:RECIPE:   [[id:0a71632f-e736-4958-87a3-904f2ab38396][idle-require]]
:END:

Idle require is a tool for loading autoload functions, files or features during
idle time. The way to use this is to idle-require many small packages that
individually don't take too much time. This helps ensure that in emacs loading
of big packages like org-mode is snappy.

**** init
:PROPERTIES:
:ID:       43d2350f-f7c4-43d3-9612-f78ccdf9d649
:END:

#+begin_src emacs-lisp
(require 'idle-require)
#+end_src

**** settings
:PROPERTIES:
:ID:       d16db762-9c50-4b00-9f2d-b4b5d15855cf
:END:

When emacs goes idle for [[helpvar:idle-require-idle-delay][idle-require-idle-delay]] seconds, the features will
start loading. [[helpvar:idle-require-load-break][idle-require-load-break]] is the break between features idle
require loads.

#+begin_src emacs-lisp
(setq idle-require-load-break 2)
(setq idle-require-idle-delay 10)
#+end_src

**** make idle require use void-log
:PROPERTIES:
:ID:       109011ee-ab24-4f3e-867f-21d6f6f534a8
:END:

=idle-require= messages us to tell us when a package is being idle required and
when it has finished idle-requiring packages. I don't want to see the message
unless I'm debugging.

#+begin_src emacs-lisp
(void-message-with-void-log #'idle-require-mode)
(void-message-with-void-log #'idle-require-load-next)
#+end_src

**** increase gc-cons-threshold during idle loading
:PROPERTIES:
:ID:       275c3488-8192-476c-97b8-6c6643f54d2e
:END:

Since we're evaluating a good amount of lisp expressions, we should boost
garbage collection during this time.

#+begin_src emacs-lisp
(void-pause-garbage-collection #'idle-require-load-next)
#+end_src

** Commands
:PROPERTIES:
:ID:       14fd249d-b972-472c-b57e-4e53a80b22dc
:END:

*** consult
:PROPERTIES:
:ID:       44120178-95c3-44f1-a3a2-bd69b0d03e70
:RECIPE:   [[id:e81a0d79-39f0-492c-9636-ddc701cd85be][consult]]
:END:

Consult is a package that provides several generic utility functions.

**** don't preview anything

Many consult consult commands have a preview by default. Typically previews are
expensive. This is especially true for [[helpfn:consult-theme][consult-theme]], which switches the theme
every time you move from one candidate to another. If a preview is helpful and
its benefit is not outweighed by the performance cost of previewing, then I
favor using it.

#+begin_src emacs-lisp
(setq consult-preview-theme nil)
(setq consult-preview-outline t)
(setq consult-preview-buffer nil)
(setq consult-preview-line t)
#+end_src

**** autoload commands
:PROPERTIES:
:ID:       f78a7e71-b70a-4067-b821-f581cf76fb84
:END:

#+begin_src emacs-lisp
(--each (list #'consult-theme #'consult-line #'consult-yank-pop
              #'consult-outline #'consult-apropos #'consult-buffer
	      #'consult-buffer-other-window)
  (autoload it "consult" nil t nil))

(--each (list #'consult-buffer #'consult-buffer-other-window)
  (void-load-before-call 'recentf it t))
#+end_src

**** make sure commands display correctly
:PROPERTIES:
:ID:       a8d49e11-b173-4aea-ba43-08ec7bea4379
:END:

This headline addresses some inconveniences with the way =consult-line= and
=consult-outline=.

***** revealing folds
:PROPERTIES:
:ID:       e7c56a70-0772-41c3-a8a6-261e64ee3f36
:END:

When you have a folded outline structure (which will be true about 99% of the
time) and the point you select for your search is in folded text, consult does
not unfold it for you. This is annoying. The purpose of this headline is to
address this problem.

****** make sure commands work in folds
:PROPERTIES:
:ID:       6e442764-a323-4242-8dfd-818a82ea802b
:END:

This function is designed to reveal the current outline branch hierarchy so that
you can see the point where consult takes you.

#+begin_src emacs-lisp
(defun outline:show-branch-maybe ()
  "Reveal the current outline branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (when (outline-invisible-p (line-end-position))
    (let (points)
      (save-excursion
        (when (ignore-errors (outline-back-to-heading :invisible-ok))
          (push (point) points)
          (while (ignore-errors (outline-up-heading 1 :invisible-ok))
            (push (point) points))
          (dolist (point points)
            (goto-char point)
            (outline-show-children)
            (outline-show-entry)))))))
#+end_src

****** advise =consult-outline= and =consult-line=
:PROPERTIES:
:ID:       1b502b03-3aa8-428e-ae93-ffb6769490ff
:END:

#+begin_src emacs-lisp
(alet (list #'consult-outline #'consult-line)
  (void-add-advice it :after #'outline:show-branch-maybe))
#+end_src

***** window display
:PROPERTIES:
:ID:       b1049ef3-ab14-4b41-b759-eb3699107e71
:END:

Another rough edge with searching via consult is that sometimes the heading
won't be placed perfectly in a window. This headline is for addressing this
problem.

****** display children in window
:PROPERTIES:
:ID: f7a9c5e7-fcf8-434a-a9b3-dbe4eadead78
:END:

By default when you search a subtree with consult, you end up.

#+begin_src emacs-lisp
(defun outline:display-children-in-window ()
  "Scroll up window to maximize view of unfolded subtree.
If the subtree is unfolded and the end of the current subtree is outside of the
visible window, scroll up until the whole subtree is visible. If the whole
subtree can't fit on the visible window, only scroll up until the top of the
subtree is on the first line of the window (in other words, the beginning of
th subtree should always be visible)."
  ;; Don't use `window-beg' and `window-end' because their values are
  ;; unreliable.
  (let ((subtree-beg (save-excursion (outline-back-to-heading)
				     (line-beginning-position)))
        (subtree-end (save-excursion (outline-end-of-subtree)
				     (line-end-position))))
    (while (and (pos-visible-in-window-p subtree-beg)
                (not (pos-visible-in-window-p subtree-end)))
      (scroll-up 1))
    ;; Sometimes the line at the end is not fully visible. So I try to
    ;; scroll down an extra line.
    (unless (pos-visible-in-window-p subtree-beg)
      (scroll-down 1))))
#+end_src

****** advise
:PROPERTIES:
:ID:       9ac87847-c116-4a0b-b2ab-544c1f02cdcf
:END:

#+begin_src emacs-lisp
(alet (list #'consult-outline #'consult-line)
  (void-add-advice it :after #'outline:display-children-in-window))
#+end_src

**** bindings
:PROPERTIES:
:ID:       c08a6f82-0408-4899-8e91-e1c5a062a7b2
:END:

#+begin_src emacs-lisp
(define-key!
  [remap switch-to-buffer]              #'consult-buffer
  [remap switch-to-buffer-other-window] #'consult-buffer-other-window
  [remap apropos]                       #'consult-apropos
  [remap load-theme]                    #'consult-theme)
#+end_src

*** setting font size
:PROPERTIES:
:ID: 4bf24b65-6f23-4e42-930e-4d43f766545c
:END:

Face attribute height is a magnitude of 10 greater than what we typically
use as font sizes (eg. font-size 14 corresponds to a face-height of 140).
I want to make sure I don't input 14 thinking about font size (it's
happened before and it's a huge pain resetting the font-size when the
font is super small). Therefore, I check the code.

#+begin_src emacs-lisp
(defun void/set-font-size ()
  "Set the font size interactively."
  (interactive)
  (let* ((old-font-size (face-attribute 'default :height))
         (prompt "The font size is %d. What do you want to change it to? ")
         (font-size (string-to-number (read-string (format prompt old-font-size))))
         (digits (+ 1 (floor (log font-size 10)))))

    ;; Make the font-size be 3 digits (Do what I mean not what I say).
    (when (< digits 3)
      (setq font-size (* font-size (expt 10 (- 3 digits)))))
    (when (> digits 3)
      (setq font-size (/ font-size (expt 10 (- digits 3)))))

    ;; If font size is still doesn't make sense, ask me to make sure it's what I want.
    (if (or (< font-size 280)
            (y-or-n-p
             (format "You're choosing a pretty large font size: %d. Is this what you intended?)"
                     font-size)))
        (progn
          (set-face-attribute 'default nil :height font-size)
          (message "Your Font Size was %s. Font size is now: %s"
                   old-font-size
                   font-size))
      (message "Font Size has been cancelled."))))
#+end_src

*** set font
:PROPERTIES:
:ID:       f24d97b6-7c74-491a-a77c-ba3ec22a2b68
:END:

#+begin_src emacs-lisp
(defun void/set-font-face ()
  "Apply an existing xfont to all graphical frames."
  (interactive)
  (alet (completing-read "Choose font: " (x-list-fonts "*"))
    (set-frame-font it nil t)))
#+end_src

*** important buffers
:PROPERTIES:
:ID:       8d04e395-5b57-434b-b975-9ae85620631d
:END:

**** init file
:PROPERTIES:
:ID:       08a3004c-6c37-401d-b584-c2c94577102d
:END:

#+begin_src emacs-lisp
(defun void/open-init-file ()
  "Switch to init file."
  (interactive)
  (alet (or (get-file-buffer VOID-INIT-FILE)
	    (create-file-buffer VOID-INIT-FILE))
    (display-buffer it)))
#+end_src

**** messages buffer
:PROPERTIES:
:ID: 7064ea0e-20e0-481c-9d07-18e4506ee3e8
:END:

In Emacs, messages. The messages buffer is where messages displayed at the bottom
of the Emacs frame are recorded after they expire.

#+begin_src emacs-lisp
(defun void/open-messages-buffer ()
  (interactive)
  (alet (get-buffer-create "*Messages*")
    (display-buffer it)))
#+end_src

**** main todo file
:PROPERTIES:
:ID: 2accd21d-7316-4fa5-bd8f-8f40935ed621
:END:

#+begin_src emacs-lisp
(defun void/switch-to-capture-file ()
  (interactive)
  (switch-to-buffer (find-file VOID-CAPTURE-FILE)))
#+end_src

**** void-log buffer
:PROPERTIES:
:ID:       0d696000-94bb-45af-a7af-b96f29714089
:END:

**** switch to scratch buffer
:PROPERTIES:
:ID:       7d9af4b6-7744-437f-b088-ec9397056113
:END:

#+begin_src emacs-lisp
(defun void/open-scratch ()
  "Pop scratch."
  (interactive)
  (pop-to-buffer "*scratch*"))
#+end_src

*** void specific funtions
:PROPERTIES:
:ID: 1b49e07a-466f-41da-8b31-18c28421cf62
:END:

**** all
:PROPERTIES:
:ID: e97267e8-fca8-4bf2-9899-7ec694e8a767
:END:

***** quit emacs without hook
:PROPERTIES:
:ID: b82f721c-39f5-4d41-bb0f-d4c391238eb4
:END:

Sometimes something goes wrong with [[helpvar:kill-emacs-hook][kill-emacs-hook]] and because of that I can't
close emacs. For that reason, I have this function.

#+begin_src emacs-lisp
(defun void/kill-emacs-no-hook ()
  "Kill emacs, ignoring `kill-emacs-hook'."
  (interactive)
  (when (yes-or-no-p "Quit without `kill-emacs-hook'?")
    (let (kill-emacs-hook) (kill-emacs))))
#+end_src

***** quit emacs brutally
:PROPERTIES:
:ID: 8753217c-4722-4183-bbb3-049707a37e54
:END:

I've never had to use this. But better be safe than sorry.

#+begin_src emacs-lisp
(defun void/kill-emacs-brutally ()
  "Tell an external process to kill emacs."
  (interactive)
  (when (yes-or-no-p "Do you want to BRUTALLY kill emacs?")
    (call-process "kill" nil nil nil "-9" (number-to-string (emacs-pid)))))
#+end_src

***** new emacs instance
:PROPERTIES:
:ID: eaf80ec3-2bd4-4f05-8a9c-fa525894a6fe
:END:

#+begin_src emacs-lisp
(defun void/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)

  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

***** kill all process of program
:PROPERTIES:
:ID: 913952e2-3727-4b38-aefc-4618c2771730
:END:

#+begin_src emacs-lisp
(defun void/kill-emacs-processes ()
  (interactive)
  (let ((count 1) (process "emacs"))
    (kill-process process)
    (while (ignore-errors (kill-process process))
      (setq process (format "emacs<%d>" count))
      (cl-incf count))
    (message "killed %d processes" count)))
#+end_src

**** turn on debug-mode
:PROPERTIES:
:ID: c1ac481a-6ebd-49ce-a930-3b0593283aee
:END:

#+begin_src emacs-lisp
(defun void/enable-debug-mode ()
  (interactive)
  (setq void-debug-p t))
#+end_src

**** quit emacs no prompt
:PROPERTIES:
:ID: d530718a-2b42-4e9b-8d7d-7813e0ae6381
:END:

#+begin_src emacs-lisp
(defun void/quit-emacs-no-prompt ()
  "Quit emacs without prompting."
  (interactive)
  (let (confirm-kill-emacs)
    (kill-emacs)))
#+end_src

* Completion
:PROPERTIES:
:ID:       744ac652-aebc-4f5b-883a-4464dd7b07cd
:END:

Completion has certainly become an integral part of any efficient workflow. One
commonality among things like searching emails, code-completing a word, surfing
the web is that in one way or another all of these things involve the suggestion
of likely candidates from a population that is too time consuming to look
through on our own. It's not much different in Emacs. We're constantly sifting
though files, buffers, commands, words--all to try to get through to the subset
of things that we actually want at this moment.

** company
:PROPERTIES:
:ID:       5c0ed97e-da66-42ab-a033-381ac9dd8972
:RECIPE:   [[id:0bcfacb9-7bd2-49f2-aa57-3ec62fcf1123][company]]
:END:

*** init
:PROPERTIES:
:ID:       0f670007-165b-4a2d-ac35-97eab9ada739
:END:

**** hooks
:PROPERTIES:
:ID:       5e5393d9-9f58-45be-9ecc-1bc9f0316379
:END:

#+begin_src emacs-lisp
(autoload #'company-mode "company" nil t nil)
(void-add-hook 'prog-mode-hook #'company-mode)
#+end_src

**** settings
:PROPERTIES:
:ID:       5b7962d9-0a43-4efc-b8ad-3f638f6abff3
:END:

#+begin_src emacs-lisp
(setq company-frontends '(company-pseudo-tooltip-frontend))
(setq company-tooltip-align-annotations t)
(setq company-show-numbers t)
(setq company-dabbrev-downcase nil)
(setq company-idle-delay 0.15)
(setq company-tooltip-limit 14)
(setq company-minimum-prefix-length 1)
(setq company-minimum-prefix-length 1)
(setq company-require-match 'never)
#+end_src

*** bindings
:PROPERTIES:
:ID:       ba170d95-7d86-4827-af6b-dc5fd4c1b7e5
:END:

#+begin_src emacs-lisp
(define-key! company-active-map
  [tab]     #'company-select-next
  [backtab] #'company-select-previous
  "C-k"     #'company-select-previous
  "C-j"     #'company-select-next)
#+end_src

*** backends
:PROPERTIES:
:ID:       bd47ec52-6428-4f37-80d2-3795f5a42d02
:END:

**** backends-alist
:PROPERTIES:
:ID:       dac0a998-e1b1-424f-8c40-e1bc19843153
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-tempo company-ispell))
    (prog-mode :derived ((:separate company-capf company-tempo))))
  "An alist modes to company backends.")
#+end_src

**** initialize backends
:PROPERTIES:
:ID:       4e82e869-b144-44aa-bc19-bb58b8c5ff2a
:END:

#+begin_src emacs-lisp
(defhook! setup-company-backends (after-change-major-mode-hook)
  "Set `company-backends' for the current buffer."
  (when (and (bound-and-true-p company-mode)
             (not (eq major-mode 'fundamental-mode)))
    (set (make-local-variable 'company-backends)
	 (company:backends-for-major-mode))))
#+end_src

**** get backends
:PROPERTIES:
:ID:       282a2c16-ae5f-4d81-acaa-8d60fb24e762
:END:

#+begin_src emacs-lisp
(defun company:backends-for-major-mode ()
  "Return a list of company backends for major-mode."
  (loopy ((list (mode type backends) company:backend-alist)
	  (expr derived-p (and (eq type :derived) (derived-mode-p mode)))
	  (expr exact-p (eq type exact-p))
	  (expr mm-enabled-p (or (eq major-mode mode)
                                 (and (boundp mode) (symbol-value mode))))
	  (when (and (eq type :only) (eq mode major-mode))
	    (return backends))
	  (when (or derived-p (and exact-p mm-enabled-p))
	    (append new-backends backends)))))
#+end_src

*** company-prescient
:PROPERTIES:
:ID:       be4bc19d-a25c-4e2d-9f12-5d2946bc9931
:RECIPE:   [[id:50f75aa4-d641-4502-8047-7465051f7b85][company-prescient]]
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(autoload #'company-prescient-mode "company-prescient" nil t nil)
(void-add-hook 'company-mode-hook #'company-prescient-mode)
#+end_src

*** close company on escape
:PROPERTIES:
:ID: 750cc608-865e-4f69-a7b2-826fc66a7b71
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (void-escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode) (eq company-mode t))
    (company-abort)
    t))
#+end_src

** selectrum
:PROPERTIES:
:ID:       294a9fde-e76f-40ce-9552-dd5801318717
:RECIPE:   [[id:97d81f61-e181-412d-a7f5-0f8b9192a2fc][selectrum]]
:END:

Selectrum is another completion framework. It distinguishes itself from the rest
by striving to work with the built-in emacs [[helpfn:completing-read][completing-read]] instead of
replacing it like [[https://github.com/emacs-helm/helm][helm]] and [[https://github.com/emacs-helm/helm][ivy]] do.

Because helm and ivy replace the existing framework, it means that whenever you
want a command be capable of using all of helm or ivy's features, you need to
define it their way. Otherwise, there's no guarantee their features will work at
least any features besides the basic choosing of a single candidate. That's a
big reason why there are [[][so many]] helm and ivy packages: many of those
packages are just ivy and helm wrappers around existing commands.

In contrast, any command defined via completing-read should work consistently with
selectrum and its provided features.

*** init
:PROPERTIES:
:ID:       6e670980-7794-4505-a285-184416a5b377
:END:

#+begin_src emacs-lisp
(void-add-hook 'emacs-startup-hook #'selectrum-mode)
(autoload #'selectrum-mode "selectrum" nil t nil)

(setq selectrum-fix-minibuffer-height t)
(setq selectrum-should-sort-p t)
(setq selectrum-count-style nil)
(setq selectrum-num-candidates-displayed 15)
#+end_src

*** minibuffer bindings
:PROPERTIES:
:ID:       f9bc79b9-ec16-4311-aa4c-8fef5add8b55
:END:

#+begin_src emacs-lisp
(define-key! '(insert emacs) selectrum-minibuffer-map
  "TAB" #'selectrum-next-candidate
  "C-k" #'selectrum-previous-candidate
  "C-j" #'selectrum-next-candidate
  "C-;" #'selectrum-insert-current-candidate
  "C-l" #'selectrum/mark-candidate
  [backtab] #'selectrum-previous-candidate)
#+end_src

*** advice for disable
:PROPERTIES:
:ID:       1e39a4d2-8d4a-4413-a86e-3f92547cff14
:END:

For most functions, sorting their candidates is good. This is advice
specifically designed to disable selectrum sorting.

#+begin_src emacs-lisp
(defun selectrum::disable-selectrum-sorting-advice (orig-fn &rest args)
  (if (bound-and-true-p selectrum-mode)
      (let (selectrum-should-sort-p) (apply orig-fn args))
    (apply orig-fn args)))
#+end_src

*** prescient
:PROPERTIES:
:ID:       4445c814-9899-4d54-affe-0cee38642690
:RECIPE:   [[id:03fbfe83-7f2b-4c84-bc08-571c4e32bcc6][prescient]]
:END:

Prescient.

#+begin_src emacs-lisp
(void-add-hook 'selectrum-mode-hook #'prescient-persist-mode)

(setq prescient-save-file (concat VOID-DATA-DIR "prescient-save-file"))
#+end_src

*** selectrum-prescient
:PROPERTIES:
:ID:       70668ed8-9c83-42d2-8dce-d8f7de923569
:type:     git
:RECIPE:   [[id:4dda08d1-a678-4e9c-b4c4-9bcb6563cea9][selectrum-prescient]]
:END:

#+begin_src emacs-lisp
(void-add-hook 'selectrum-mode-hook #'selectrum-prescient-mode)
(autoload #'selectrum-prescient-mode "selectrum-prescient" nil t nil)

(setq selectrum-preprocess-candidates-function #'selectrum-prescient--preprocess)
#+end_src

*** orderless
:PROPERTIES:
:ID:       2278ca33-dbf2-45a7-bba7-8c73942b08be
:RECIPE:   [[id:fb2d198a-18ac-40fa-9869-5e15eac6cb4e][orderless]]
:END:

**** init
:PROPERTIES:
:ID:       9702810e-2013-4c41-ba12-0b55de6ceb38
:END:

#+begin_src emacs-lisp
(--each (list #'orderless-filter #'orderless-highlight-matches)
  (autoload it "orderless" nil t nil))
#+end_src

**** use orderless filters
:PROPERTIES:
:ID:       02b92dca-f879-43ad-89a5-fcf8902ff0b6
:END:

#+begin_src emacs-lisp
(setq selectrum-refine-candidates-function #'orderless-filter)
(setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
#+end_src

**** stop selectrum filtering and highlight
:PROPERTIES:
:ID:       a6720cdc-9d51-463b-9ffe-f9341c6bd967
:END:

#+begin_src emacs-lisp
(defadvice! orderless:inhibit-filtering-and-highlighting (:around selectrum-prescient-mode)
  "Don't let `selectrum-prescient' filter or highlight.
Orderless will do this."
  (let ((selectrum-refine-candidates-function selectrum-refine-candidates-function)
        (selectrum-highlight-candidates-function selectrum-highlight-candidates-function))
    (apply <orig-fn> <args>)))
#+end_src

** tempo                                                                   :WIP:
:PROPERTIES:
:ID:       36573b5e-f880-4079-840f-625c0b39704c
:END:

Tempo is a built-in snippet package. It's advantage over =yasnippet= is that it
can define a template using a lisp form as opposed to a string. This means it's
more hackable and more expressive.

Because yasnippets are strings it makes them less friendly for storing as a lisp
form. You still could, mind you, but essentally you'd fill your config with long
template strings. I never liked storing snippets in their own directory and as
many little files. One thing is that you have to deal with making sure the files
exist and that they're in the right path. Another thing is that you need to
manage snippet file loading because it's expensive to load all the snippets at
once if you have alot.

*** company integration
:PROPERTIES:
:ID:       d6c830b5-7b51-4b4e-bcb5-e8a3c246306a
:END:

The goal here is to use tempo in company. Fortunately, company comes with a
tempo backend. So that it actually expands the snippets when you select the
tempo tag, you need to set =company-tempo-expand= to =t=.

#+begin_src emacs-lisp
(after! company (setq company-tempo-expand t))

;; Add `company-tempo' to backends during `prog-mode'.
(after! company
  ())
#+end_src

*** snippet macro
:PROPERTIES:
:ID:       33550f12-c282-48cb-8737-5f4240f51121
:END:

Functions such as.

#+begin_src emacs-lisp
(defmacro defsnippet! (name args docstring &rest body)
  "Define a snippet."
  (declare (indent defun))
  (-let ((name (symbol-name name))
	 ((tag taglist) args))
    `(after! tempo
       (require 'tempo-snippets nil t)
       (defvar)
       (tempo-define-snippet ,name ,(car body) ,tag ,docstring ',taglist))))
#+end_src

*** tempo-snippets
:PROPERTIES:
:ID:       fa5d20be-f873-4b64-b218-33fc0a54bea6
:END:

**** use tab and backtab
:PROPERTIES:
:ID:       7205d26c-b01b-4619-a8d4-f374be0a2006
:END:

By default the tempo-snippet uses the standard =M-n= and =M-p=
bindings. However, I prefer the more mainstream =TAB= and =BACKTAB=.

#+begin_src emacs-lisp
(general-def '(insert normal) tempo-snippets-keymap
  "TAB" #'tempo-snippets-next-field
  [backtab] #'tempo-snippets-previous-field)

(general-def tempo-snippets-keymap
  "TAB" #'tempo-snippets-next-field
  [backtab] #'tempo-snippets-previous-field)
#+end_src

**** stop template after completion
:PROPERTIES:
:ID:       7b1d005f-f743-4ce1-88f0-dd68de5fd3ee
:END:
The overlays from =tempo-snippets= don't disappear after you reach the last
mark. I need to call.


* Utility

** elog
:PROPERTIES:
:ID:       d73fd7b1-5610-4d93-8802-1aa57c8c1918
:RECIPE:   [[id:5a599a4d-5a47-4aa2-98d4-6e9bb5a413a0][elog]]
:END:

=elog= is a library for generating logging functions. I use [[][]] to generate a
function that logs to the buffer =*void-log*=.

*** init
:PROPERTIES:
:ID:       1a550471-3434-4980-9de4-6f708e0fc8f1
:END:

#+begin_src emacs-lisp
(require 'elog)
#+end_src

*** open elog
:PROPERTIES:
:ID:       f507fcff-f3c5-4dff-b5d8-c4bcec34b58b
:END:

This form creates a set of functions for logging.

#+begin_src emacs-lisp
(elog-open-log buffer "void-" :buffer "*void-log*" :fmt "VOID %M")
#+end_src

*** void-log
:PROPERTIES:
:ID:       b2ceb864-d9bf-4cbb-83ab-dd5f4d8004ee
:END:

#+begin_src emacs-lisp
(defun void-log (format-string &rest args)
  "Log to *Messages* if `void-debug-p' is on.
Does not interrupt the minibuffer if it is in use, but still log to *Messages*.
Accept the same arguments as `message'."
  (void--log 1 (apply #'format format-string args)))
#+end_src

** ht
:PROPERTIES:
:ID:       56bb0ff4-6ad1-44b7-a9a4-54abf48ed253
:RECIPE:   [[id:30bcab5a-24ba-4146-929a-fe760d5f4363][ht]]
:END:

=ht= is a package that tries to provide a consistently named API for dealing with
hash-tables.

** system-packages
:PROPERTIES:
:ID:       74bd0e5a-f6b0-48eb-a91e-3932eae23516
:RECIPE:   [[id:6c452231-9d3e-4ea0-a0b7-933b278a8dd9][system-packages]]
:END:

=system-packages= provides an api for installing system packages. This api strives
to abstract package installation on different operating systems. Unfortunately,
it does not include an interactive function that uses [[helpfn:completing-read][completing-read]] to list
packages

*** settings
:PROPERTIES:
:ID:       e43a8862-4e3a-4050-a15e-d39fd25dfccb
:END:

#+begin_src emacs-lisp
(setq system-packages-noconfirm t)
#+end_src

*** popup rule
:PROPERTIES:
:ID:       69631be9-ce8f-4f65-b112-229bf1722621
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "system-packages" :newname "\\*system-packages")
#+end_src

*** use yay for arch
:PROPERTIES:
:ID:       2fc48e66-83f3-4e35-8b2c-ef9113cb9b45
:END:

If we're in arch and we have yay intalled, use that.

#+begin_src emacs-lisp
(after! system-packages
  (when (and (eq system-packages-package-manager 'pacman)
             (system-packages-package-installed-p "yay"))
    (alet (alist-get 'pacman system-packages-supported-package-managers)
      (push `(yay (default-sudo . nil)
                  ,@(-map (-lambda ((action . command))
			    (cons action (s-replace "pacman" "yay" command)))
                          (cdr it)))
            system-packages-supported-package-managers))
    (setq system-packages-package-manager 'yay)))
#+end_src

** mmt
:PROPERTIES:
:ID:       a4377985-fe0e-4980-b839-08c334bde76c
:RECIPE:   [[id:d9fee386-dc24-40d5-8d55-a775a3d7f675][mmt]]
:END:

=mmt= is a library of tools for writing macros. Specifically, it provides the
quintessential =once-only= and =with-gensyms= macros which are used to prevent
variable leaking.

#+begin_src emacs-lisp
(defalias 'once-only! 'mmt-once-only)
(defalias 'with-gensyms! 'mmt-with-gensyms)
(defalias 'with-unique-names! 'mmt-with-gensyms)
#+end_src

** loopy
:PROPERTIES:
:ID:       3102adee-0474-4cf4-847a-011c2f8f48cd
:END:

=loopy= is an alternative to =cl-loop= that preserves lisp structure. It is akin to
[[][Common Lisp's iter]]. dash's functions and macros are good for most
cases. But they are not as good in my opinion when you're dealing with a complex loop
that involves accumulating several variables or atypical control-flow (as in, break
statements or return statements).

** ellocate
:PROPERTIES:
:ID:       e3590042-52fb-47ee-a5eb-a7860a3cdb17
:RECIPE:   [[id:66150582-79e7-4ce6-ab8e-e26f604e3684][ellocate]]
:END:

** epa
:PROPERTIES:
:ID:       ad3f6134-4fa6-492e-93a6-b94235ecad3d
:END:

Setting these variables in coordination with configuring =gpgconf= lets me enter
my gpg passphrase via emacs.

#+begin_src emacs-lisp
(setq epg-gpg-program "gpg2")
(setq epa-pinentry-mode 'loopback)
#+end_src

** pdf-tools
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:RECIPE:   [[id:2e12bf9d-e622-44e5-94e7-de20d7b1faa8][pdf-tools]]
:END:

*** init
:PROPERTIES:
:ID: 163d8880-6a7d-4479-a7e4-e333e4f930da
:END:

#+begin_src emacs-lisp
(autoload #'pdf-view-mode "pdf-tools" nil t nil)
(push '("%PDF" . pdf-view-mode) magic-mode-alist)
(push '("\\.[pP][dD][fF]\\'" . pdf-view-mode) auto-mode-alist)
#+end_src

*** epd-pdf-info-program
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defadvice! build-pdf-into-program-maybe (:before pdf-view-mode)
  "Build the pdf-info program if it hasn't already been built."
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (--each (buffer-list)
        (with-current-buffer it
          (when (eq major-mode 'pdf-view-mode)
            (fundamental-mode))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

*** bindings
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(general-def 'normal pdf-view-mode-map
  "j" #'pdf-view-next-line-or-next-page
  "k" #'pdf-view-previous-line-or-previous-page
  "0" #'pdf-view-first-page
  "9" #'pdf-view-last-page
  "s" #'pdf-view-fit-width-to-window)
#+end_src

** web browsing
:PROPERTIES:
:ID:       0be0a36f-67dc-4db5-8d0a-321d19bae08a
:END:

*** engine-mode
:PROPERTIES:
:ID:       d701f44f-85eb-4849-8f2d-15423eb41a02
:RECIPE:   [[id:de7badcd-94e6-4f2e-85cc-3a129467a7c2][engine-mode]]
:END:

**** init
:PROPERTIES:
:ID:       f5a2c47b-01df-4dcf-b012-b6311cf79683
:END:

#+begin_src emacs-lisp
(--each '(engine/search-duckduckgo engine/search-qwant
	      engine/search-duckduckgo engine/search-wikipedia)
  (autoload it "engine-mode" nil t nil))
#+end_src

**** different engines
:PROPERTIES:
:ID:       2f5c974e-b26e-4080-a9b3-acd6406ab118
:END:

This package essentially automates the creation of an interactive web searching
functions.

#+begin_src emacs-lisp
(after! engine-mode
  (defengine amazon
    "http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&field-keywords=%s")
  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s")
  (defengine qwant
    "https://www.qwant.com/?q=%s")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"))
#+end_src

*** eww
:PROPERTIES:
:ID:       77d23774-7f42-45ee-90ec-5f28efddee65
:END:

**** ability to add new windows
:PROPERTIES:
:ID:       54dc52bb-f7e5-4a86-a306-aa42482cbd6d
:END:

=eww= doesn't create new buffers by default when you do a new search. Instead, it
replaces the existing buffer. I got this code snippet from [[https://stackoverflow.com/questions/28458784/emacs-and-eww-open-links-in-new-window][this-question]].

#+begin_src emacs-lisp
(defhook! create-new-buffer (eww-after-render-hook)
  (let* ((title  (plist-get eww-data :title))
	 (url    (plist-get eww-data :url))
	 (result (concat "*eww-" (or title
				     (if (string-match "://" url)
					 (substring url (match-beginning 0))
				       url)) "*")))
    (rename-buffer result t)))
#+end_src

*** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:RECIPE:   [[id:017727a9-dc89-4caa-aa80-57ed3e11a5f0][w3m]]
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[https://github.com/abo-abo/swiper.git][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

** restart-emacs
:PROPERTIES:
:ID:       7412bc2f-0db1-44e9-8ea7-0dc595a04fca
:RECIPE:   [[id:b44fae75-ff21-4dbf-885f-54bde7f9a971][restart-emacs]]
:END:

#+begin_src emacs-lisp
(autoload #'restart-emacs "restart-emacs" nil t nil)
#+end_src

** multimedia
:PROPERTIES:
:ID:       5675cbbc-beb1-4470-a1d2-08f253bb4535
:END:

*** escr
:PROPERTIES:
:ID: 0038e1ed-ac6a-4529-9ecd-dfa8a44d40c9
:END:

Pictures or GIFs of behaviors can relate emacs behaviors in away descriptions
cannot. From my experience looking at posts on [[https://emacs.stackexchange.com/][emacs stackexchange]] or
[[https://www.reddit.com/r/emacs/][emacs-reddit]] or even other [[https://github.com/caisah/emacs.dz][emacs configs]], screenshots are underutilized (or
often not utilized at all).

There are three screenshot packages I know of [[https://github.com/emacsmirror/screenshot][screenshot]], [[https://github.com/dakra/scrot.el][scrot]] and [[https://github.com/atykhonov/escr][escr]]. But
they all have their downsides. Screenshot's main command, =screenshot=, assumes
that you want. =escr= doesn't provide prompt you for the filename or provide any
option that would prompt you for the file name.

**** init
:PROPERTIES:
:ID:       a6a8610e-84b5-471d-8f07-2ad2c67c2998
:END:

#+begin_src emacs-lisp
(--each '(escr-window-screenshot escr-frame-screenshot escr-window-screenshot)
  (autoload it "escr" nil t nil))
#+end_src

**** settings
:PROPERTIES:
:ID:       4ec97ac8-cad6-4536-be21-6ae2ee1655f3
:END:

#+begin_src emacs-lisp
(setq escr-screenshot-quality 10)
;; (setq escr-screenshot-directory VOID-SCREENSHOT-DIR)
#+end_src

**** function for geting screenshot filename
:PROPERTIES:
:ID:       58405f4f-e891-494e-afc7-a227415ec12b
:END:

=escr= doesn't prompt for the filename. While this is faster in the shortrun and
may be useful for situations when you're short on time, it does mean that I'll
need to invest time in looking at the screenshots again so you can properly name
them.

#+begin_src emacs-lisp
(defun escr:get-filename ()
  "Return the filename."
  (alet (format "%s-%s.png"
                (alet (read-string "Image name: ")
                  (if (string-empty-p it) "screenshot" it))
                (format-time-string "%Y-%m-%d-%H-%M-%S.png"))
    (expand-file-name it escr-screenshot-directory)))
#+end_src

**** tell =escr--screenshot= to use maim
:PROPERTIES:
:ID:       3b17fb6e-a15b-4b4a-bdcf-a756961c00d3
:END:

If we don't use an short idle timer to take the screenshot, we'll end up
capturing the prompt for the filename (like in [[][this example]]).

#+begin_src emacs-lisp
(defadvice! use-miam (:override (x y width height) escr--screenshot)
  (let ((window-id (frame-parameter (selected-frame) 'window-id))
        (crop (format "%sx%s+%s+%s" width height x y))
        (filename (escr:get-filename)))
    (alet `(lambda ()
             (call-process "maim" nil nil nil
                           "--window" ,window-id
                           "--geometry" ,crop
                           "--quality" ,(number-to-string escr-screenshot-quality)
                           ,filename)
             (message "Screenshot Taken!"))
      (run-with-timer 1 nil it))))
#+end_src

*** gif-screencast
:PROPERTIES:
:ID:       d8553132-c244-4319-bcc9-51905a296e34
:RECIPE:   [[id:b1b1ff30-3236-4777-8891-55c52b1aff13][gif-screencast]]
:END:

#+begin_src emacs-lisp
(autoload #'gif-screencast-start-or-stop "gif-screencast" nil t nil)

(define-key! "<f9>" 'gif-screencast-start-or-stop)

(setq gif-screencast-program "scrot")
(setq gif-screencast-args '("--quality" "25" "--focused"))

;; To shut up the shutter sound of `screencapture' (see `gif-screencast-command').

(setq gif-screencast-cropping-program "mogrify")

;; Optional: Used to crop the capture to the Emacs frame.

(setq gif-screencast-optimize-program "gifsicle")
(setq gif-screencast-capture-format "png")
#+end_src

*** emms
:PROPERTIES:
:ID:       6f3eaa69-bbbb-458e-bcad-1c121a3174e9
:RECIPE:   [[id:b3bf658a-47c8-4fcd-a963-682a460568a7][emms]]
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player.

**** init
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(--each (list #'emms-play-directory #'emms-play-file)
  (autoload it "emms" nil t nil))
#+end_src

**** settings
:PROPERTIES:
:ID:       3861c03d-b08e-463b-a28e-e88c191993fc
:END:

#+begin_src emacs-lisp
(setq emms-directory (concat VOID-DATA-DIR "emms/"))
(setq emms-seek-seconds 5)
(setq emms-player-list '(emms-player-mpv))
(setq emms-source-file-default-directory "~/Multimedia/music")
(setq emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
(setq emms-playlist-buffer-name "*EMMS-PLAYLIST*")
(setq mpc-host "127.0.0.1:6600")
#+end_src

**** quitting
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(defhook! quit-emms (kill-emacs-hook)
  "Shut down EMMS."
  (when emms-player-playing-p (emms-pause))
  (emms-stop)
  ;; kill any existing mpd processes
  (when (member 'emms-player-mpd emms-player-list)
    (call-process "killall" nil nil nil "mpd")))
#+end_src

** outorg
:PROPERTIES:
:ID:       85570385-ff5b-47ba-907b-5ef3666288bb
:RECIPE:   [[id:972227a1-76f8-4ab9-a2cb-f1905908549d][outorg]]
:END:

*** dont add overlays for blank lines
:PROPERTIES:
:ID:       5f3f3e5a-3d57-44d2-9d61-9779d7b3051d
:END:

For some reason outorg adds overlays to the outorg buffers. They make it look
like the outorg buffer has less whitespace in between headlines than it should.

#+begin_src emacs-lisp
(defadvice! dont-add-overlays-for-blanks (:around outorg-wrap-source-in-block)
  "Adding overlays for blank lines."
  (cl-letf (((symbol-function #'overlay-put) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

** testing
:PROPERTIES:
:ID:       49fe171f-d1b9-4b90-89ab-bddd2748bbd0
:END:

*** ert
:PROPERTIES:
:ID:       5fbf293e-84ae-4f47-bdcd-850ff552465a
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "ert" :newname "\\*ert\\*")
#+end_src

*** ert-expectations
:PROPERTIES:
:ID:       3062b8a4-4261-49fc-9bdb-895ba75bbd19
:RECIPE:   [[id:6249757e-2807-4772-884a-d94e85edcb36][ert-expectations]]
:END:

#+begin_src emacs-lisp
(autoload 'expect "ert-expectations" nil nil 'macro)
(autoload 'expectations "ert-expectations" nil nil 'macro)
#+end_src

*** el-mock
:PROPERTIES:
:ID:       46df66b0-5820-4550-aa99-c913d3022fe1
:RECIPE:   [[id:fdadef20-5159-45db-bc7c-eac06ac89937][el-mock]]
:END:

** email
:PROPERTIES:
:ID: b31fc41c-135d-45d9-9c05-5889d21d1cd4
:RECIPE:   [[id:46cb1764-75fd-4a01-b4c7-0c035da707b6][email]]
:END:

In today's world communication is largely done via emails. Whether at work or at
school it's common to receive emails every day. In fact, you hear of people that
have 20,000+ emails in a particular account. Unsurprisingly, when we're getting
so many emails, it's easy to become overwhelmed. Fortunately, there are numerous
ways to read and send emails in Emacs.

*** built-in settings
:PROPERTIES:
:ID:       f2f187ab-caef-4fa6-85e7-628f76e3da41
:END:

**** sendmail
:PROPERTIES:
:ID:       48c3332f-975d-4f22-94a8-4ccd394ca82a
:END:

#+begin_src emacs-lisp
(setq send-mail-function #'sendmail-send-it)
(setq sendmail-program (executable-find "msmtp"))
(setq mail-specify-envelope-from t)
#+end_src

**** smtpmail
:PROPERTIES:
:ID: 4dc1e0a6-5441-4b3e-8b75-ed3626a59154
:END:

#+begin_src emacs-lisp
(setq smtp-default-mail-server "mail.example.com")
(setq smtp-smtp-server "mail.example.com")
(setq smtpmail-smtp-service 587)
(setq smtpmail-debug-info t)
#+end_src

**** message
:PROPERTIES:
:ID:       4cf38804-18d6-470c-a9c3-e3327f2bebf9
:END:

#+begin_src emacs-lisp
(setq message-signature user-full-name)
(setq message-sendmail-envelope-from 'header)
(setq message-send-mail-function #'sendmail-send-it)
(setq message-kill-buffer-on-exit t)
#+end_src

*** password-store
:PROPERTIES:
:ID:       3c57590c-1507-4369-b615-795965d4b182
:RECIPE:   [[id:df72e626-fabb-42a5-9bd9-af4a0e50d348][password-store]]
:END:

*** mu4e
:PROPERTIES:
:ID: 1ec73e33-5b94-4199-976d-1d72f8fb5a8e
:RECIPE:   [[id:179c0195-e24b-45f5-8558-b31a2114620d][mu4e]]
:END:

The most popular emacs mail client is =mu4e=. And, there is good reason why. =mu4e=
has many juicy features. Overall, =mu4e= is definitely a great mail client.
However, it's not all roses and rainbows; it does have a few annoying quicks.
One is that unlike virtually all other emacs packages it does not come decoupled
from =mu=. Another is that it is hard to set up multiple accounts properly despite
it's [[explicit support]] for multiple accounts. =mu4e= comes bundled with =mu=. A
significant advantage of using it is it's the most popular option and,
therefore, has the most support (in the form of setup blogs and packages).

**** init
:PROPERTIES:
:ID:       bcd9b479-1ed6-48cb-bd2e-35a46cf614e2
:END:

#+begin_src emacs-lisp
(autoload #'mu4e "mu4e" nil t nil)
#+end_src

**** settings
:PROPERTIES:
:ID:       11a37383-0316-49fa-900e-c06f830c0e3f
:END:

#+begin_src emacs-lisp
(setq mu4e-completing-read-function #'completing-read)
(setq mu4e-view-show-addresses t)
(setq mu4e-view-show-images t)
(setq mu4e-view-image-max-width 800)
(setq mu4e-compose-signature-auto-include t)
(setq mu4e-compose-format-flowed t)
(setq mu4e-get-mail-command "mbsync -a")
(setq mu4e-index-cleanup t)
(setq mu4e-index-lazy-check nil)
(setq mu4e-update-interval 180)
(setq mu4e-headers-auto-update t)
(setq mu4e-context-policy 'pick-first)
(setq mu4e-compose-context-policy 'ask-if-none)
(setq mu4e-confirm-quit nil)
#+end_src

**** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:RECIPE:   [[id:9ad31e31-e46b-409a-a53b-4a9d0b39abd5][mu4e]]
:END:

#+begin_src emacs-lisp
(setq mu4e-header-fields '((:human-date . 12)
                           (:flags . 4)
                           (:from . 25)
                           (:subject)))

(setq mu4e-html2text-command
      (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text))
#+end_src

**** setup mu4e
:PROPERTIES:
:ID:       8ed2fe81-eda9-4343-a6e1-0a6a725866a4
:END:

#+begin_src emacs-lisp
(defun mu4e/init ()
  "Initialize mu4e."
  (interactive)
  (require 'password-store)
  (let ((email-dirs (--map (concat VOID-EMAIL-DIR it) (pass:email-list))))
    (when (or (not (-all-p #'f-exists-p email-dirs))
              (-some-p #'f-empty-p email-dirs))
      (message "creating directories that don't exist.")
      (--each email-dirs (mkdir it t))
      (shell-command (format "mu init -m %s" VOID-EMAIL-DIR))
      (message "Updating mail...")
      (mu4e-update-mail-and-index t))))
#+end_src

**** mu4e headers
:PROPERTIES:
:ID:       8bc93633-f3a0-494d-ae61-c05f6490cd87
:END:

#+begin_src emacs-lisp
(after! (mu4e all-the-icons)
  (setq mu4e-use-fancy-chars t)
  (setq mu4e-headers-draft-mark     (cons "D" (all-the-icons-faicon "pencil")))
  (setq mu4e-headers-flagged-mark   (cons "F" (all-the-icons-faicon "flag")))
  (setq mu4e-headers-new-mark       (cons "N" (all-the-icons-material "fiber_new")))
  (setq mu4e-headers-passed-mark    (cons "P" (all-the-icons-faicon "arrow-right")))
  (setq mu4e-headers-seen-mark      (cons "S" (all-the-icons-faicon "eye")))
  (setq mu4e-headers-attach-mark    (cons "a" (all-the-icons-material "attach_file")))
  (setq mu4e-headers-replied-mark   (cons "R" (all-the-icons-faicon "reply")))
  (setq mu4e-headers-unread-mark    (cons "u" (all-the-icons-faicon "eye-slash")))
  (setq mu4e-headers-encrypted-mark (cons "x" (all-the-icons-octicon "lock")))
  (setq mu4e-headers-signed-mark    (cons "s" (all-the-icons-faicon "certificate")))
  (setq mu4e-headers-trash-mark     (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

**** org-mu4e
:PROPERTIES:
:ID:       eaa1577b-bcb9-4f6e-9927-8c6d8042dda2
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed. I have yet to explore this feature but
it is definitely on my list of things to try out.

***** init
:PROPERTIES:
:ID:       47c8d5d8-575f-4b73-9247-38f32cb706fd
:END:

#+begin_src emacs-lisp
(void-add-hook 'mu4e-compose-mode-hook #'org-mu4e-compose-org-mode)

(setq org-mu4e-link-query-in-headers-mode nil)
(setq org-mu4e-convert-to-html t)
#+end_src

***** hook
:PROPERTIES:
:ID:       fcdbaa17-20c6-4322-baed-27df5a0ad9a2
:END:

Only render to html once. If the first send fails for whatever reason,
org-mu4e would do so each time you try again.

#+begin_src emacs-lisp
(defhook! org-mu4e-render-html-only-once (message-send-hook)
  (setq-local org-mu4e-convert-to-html nil))
#+end_src

**** multiple accounts
:PROPERTIES:
:ID: ad6de3a4-674c-490f-841e-19b8f891cd65
:END:

Mu4e certainly gave me some trouble setting up multiple accounts despite [its
attempt] to make this easy. I have one directory =~/.mail= where which stores all
my mail. The subdirectories of =~/.mail= correspond to my individual email
accounts. Until I set multiple accounts correctly it keeps prompting me to
create folders (such as =sent/=) in the =~/.mail= directory. I think part of the
reason I spent so much time setting this up is because.

***** return the list of emails with credentials
:PROPERTIES:
:ID:       3f7b1728-b855-447f-9f15-43bd79a94c14
:END:

#+begin_src emacs-lisp
(defun pass:email-list ()
  "Return a list of emails."
  (->> (password-store-list)
       (--map (elt (s-match "email/\\(.*\\)" it) 1))
       (-non-nil)))
#+end_src

***** return the stuff as a plist
:PROPERTIES:
:ID:       8129ca16-8641-4f2f-a4b6-03477d5b78f3
:END:

#+begin_src emacs-lisp
(defun pass:email-account-plist (email)
  "Return a plist of the relevant values of an email."
  (shut-up
    (->> (cdr (password-store-parse-entry email))
         (mapcar #'car)
         (--mapcat (list (intern it)
                         (password-store-get-field (concat "email/" email) it))))))
#+end_src

***** mu4e folder name alist
:PROPERTIES:
:ID:       2ef07842-e321-4fff-ae73-f19c41d263a4
:END:

Mu4e keeps prompting you for the sent, trash, and drafts directory if you do not
assign the corresponding mu4e variables. The way certain email servers name
their directories varies. For example, outlook names its sent directory as =Sent
Items=.

#+begin_src emacs-lisp
(defun mu4e:guess-folder (base-dir possible-name &rest other-possible-names)
  "Return the first file in BASE-DIR that matches POSSIBLE-NAME or any POSSIBLE-NAMES.
If there is no match, return POSSIBLE-NAME."
  (alet (or (--first (-some-p (-cut s-contains-p <> it t)
                              (cons possible-name other-possible-names))
                     (cddr (directory-files base-dir)))
            possible-name)
    (format "/%s/%s" (f-filename base-dir) it)))
#+end_src

***** set up contexts for single account
:PROPERTIES:
:ID:       66d460d7-9647-4c29-8348-eb7b3d571630
:END:

#+begin_src emacs-lisp
(defun mu4e::account-context (email)
  "Return an mu4e account context for specified EMAIL."
  (let* ((base-dir (concat VOID-EMAIL-DIR email "/"))
         (name (cl-second (s-match ".*@\\([^.]*\\)" email)))
         (account (pass:email-account-plist email))
         (out-host (plist-get 'out-host account))
         (out-port (plist-get 'out-port account)))
    (alet `((mu4e-sent-folder      . ,(mu4e:guess-folder base-dir "sent"))
            (mu4e-drafts-folder    . ,(mu4e:guess-folder base-dir "draft"))
            (mu4e-trash-folder     . ,(mu4e:guess-folder base-dir "trash" "delete" "junk"))
            (user-email-address    . ,email)
            (smtpmail-smtp-server  . ,out-host)
            (smtpmail-smtp-user    . ,base-dir)
            (smtpmail-smtp-service . ,out-port))
      (make-mu4e-context :name name :vars it))))
#+end_src

***** multiple contexts
:PROPERTIES:
:ID: e56b64ac-ed36-4689-b8f4-8711c1f4f79f
:END:

#+begin_src emacs-lisp
(defadvice! setup-contexts (:before mu4e)
  "Initiaize context for each email account."
  (require 'password-store)
  (--each (-map #'mu4e::account-context (pass:email-list))
    (cl-pushnew it mu4e-contexts)))
#+end_src

**** truncate lines in messages
;; :PROPERTIES:
;; :ID: e6addd49-6aa4-4b9e-8e50-4f0ea43aedb7
;; :END:

(defhook! wrap-text-in-message (mu4e-view-mode-hook)
  (setq-local truncate-lines nil))

** shells & terminals
:PROPERTIES:
:ID:       214edd41-3ba1-4184-b484-fe7bb256d319
:END:

*** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

**** init
:PROPERTIES:
:ID:       f91b3d13-3470-4108-aae3-2b8b4e5f5edb
:END:

***** idle require
:PROPERTIES:
:ID:       9ff94547-b138-41dc-836f-71fc37171ec3
:END:

#+begin_src emacs-lisp
(-each '(em-alias em-banner em-basic em-cmpl
         em-dirs em-glob em-hist em-ls em-prompt
         em-script em-term em-unix)
  #'idle-require)
#+end_src

***** settings
:PROPERTIES:
:ID:       e8c08c7b-9b62-45c2-aa3e-b901bbcd66a1
:END:

#+begin_src emacs-lisp
(setq eshell-banner-message "")
(setq eshell-prefer-lisp-functions nil)
(setq eshell-scroll-to-bottom-on-input 'all)
(setq eshell-scroll-to-bottom-on-output 'all)
(setq eshell-buffer-shorthand t)
(setq eshell-kill-processes-on-exit t)
(setq eshell-hist-ignoredups t)
(setq eshell-input-filter #'eshell-input-filter-initial-space)
(setq eshell-glob-case-insensitive t)
(setq eshell-error-if-no-glob t)
#+end_src

***** popup rule
:PROPERTIES:
:ID:       bd580e0c-1736-4855-8cfb-e4e365ecd8d3
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "eshell" :newname "\\*eshell\\*")
#+end_src

***** directories
:PROPERTIES:
:ID:       4923faac-1630-4389-8f2c-d9e75c88eecf
:END:

#+begin_src emacs-lisp
(setq eshell-directory-name (concat VOID-DATA-DIR "eshell/"))
(setq eshell-history-file-name (concat eshell-directory-name "history"))
#+end_src

***** bootstrap
:PROPERTIES:
:ID: 8ed5b69c-be1f-4181-bd01-88fc33b148d6
:END:

#+begin_src emacs-lisp
(remove-hook 'eshell-output-filter-functions #'eshell-postoutput-scroll-to-bottom)
#+end_src

**** visual commands
:PROPERTIES:
:ID: fedfa200-7d17-408d-ba42-da401cba6419
:END:

#+begin_src emacs-lisp
(after! em-term
  (--each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (add-to-list 'eshell-visual-commands it)))
#+end_src

**** improvements
:PROPERTIES:
:ID: b3da5d39-1591-4a19-ae96-45a117a13f24
:END:

Eshell uses pcomplete as its completion engine.

***** pcomplete
:PROPERTIES:
:ID: 63de7a7f-431c-4652-aa55-45973b5a4c2a
:END:

This replaces the default popup window at the bottom of eshell. By using the
=completion-in-region= backend, it triggers ivy/helm for completion.

#+begin_src emacs-lisp
(defun eshell/pcomplete ()
  "Use pcomplete with completion-in-region backend."
  (interactive)
  (require 'pcomplete)
  (ignore-errors (pcomplete-std-complete)))
#+end_src

***** go to prompt on insert
;; :PROPERTIES:
;; :ID: 76bd909c-901c-4bc6-8848-d84b121a06c3
;; :END:

(defun eshell:goto-prompt-on-insert-h ()
  "Move cursor to the prompt when switching to insert state."
  (when (< (point) eshell-last-output-end)
    (goto-char
     (if (memq this-command '(evil-append evil-append-line))
         (point-max)
       eshell-last-output-end))))

**** eshell commands
:PROPERTIES:
:ID: 4a7074f6-7f53-4950-9c92-be39b23e1d70
:END:

****** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:RECIPE:   [[id:ffc2cfcf-f95e-4080-a257-8d9427f15de4][eshell-z]]
:END:

#+begin_src emacs-lisp
(after! eshell
  (defalias 'eshell:z-file 'eshell-z-freq-dir-hash-table-file-name)
  (setq eshell:z-file (expand-file-name "z" eshell-directory-name))
  (autoload #'eshell-z "eshell-z" nil t nil))
#+end_src

***** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:RECIPE:   [[id:0b80ea25-b4b4-4f58-89a1-495cd9b72ec7][eshell-up]]
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(defalias 'eshell/up 'eshell-up)
(defalias 'eshell/pk 'eshell-up-peek)
(defalias 'eshell/peek 'eshell-up-peek)

(--each '(eshell-up eshell-up-peek)
  (autoload it "eshell-up" nil t nil))
#+end_src

***** eshell-clear
:PROPERTIES:
:ID: 6ae332e7-f2e8-4a78-9bb8-c9b4f271a6a2
:END:

The shell often gets cluttered with many commands. It's often useful to clear it
and indeed there are many suggestions on how to do so online. However, many of
them involve erasing the eshell buffer or making it's previous contents
inaccessable. I don't like getting rid of information that could be important.
All I really wanted is to just scroll up to the top of the window so that the
previous contents weren't visible. Note that it is important that this command
returns nil. Eshell shell ignores output returns nil. However, when it returns
non-nil it prints it to the eshell buffer, which results in a residue
line--that's not what we want.

https://emacs.stackexchange.com/questions/28819/eshell-goes-to-the-bottom-of-the-page-after-executing-a-command

#+begin_src emacs-lisp
(defadvice! scroll-to-top (:override eshell/clear)
  "Scroll eshell buffer to top.
The effect of this is to clear the contents of the eshell buffer."
  (progn (call-interactively #'evil-scroll-line-to-top) nil))
#+end_src

**** display
:PROPERTIES:
:ID: 66d647e3-b83b-4469-bb62-75546c2fee64
:END:

***** prompt
:PROPERTIES:
:ID: c21591c9-43a2-4c6b-aac8-b46b41f4dc63
:END:

I got a lot of inspiration from the [[http://www.modernemacs.com/post/custom-eshell/][modern emacs blog]]. I think the
author's code is in general a good example of how to use macros to abstract a
task and make it much simpler than it would be otherwise.

****** with-face
:PROPERTIES:
:ID: ae757b22-27e1-4243-8da0-35c3a8e6ff65
:END:

#+begin_src emacs-lisp
(defmacro with-face! (string &rest props)
  "Return STR propertized with PROPS."
  `(propertize ,string 'face '(,@props)))
#+end_src

****** helpers
:PROPERTIES:
:ID: c29bac50-32e4-4128-8446-6f4153d3a7a0
:END:

Eshell prompt function finds eshell section functions specified by
[[helpvar:eshell:enabled-sections][+eshell-enabled-sections]] and concatenates their results in order to
generate the body of the eshell prompt.

#+begin_src emacs-lisp
(defun eshell:acc (acc x)
  "Accumulator for evaluating and concatenating `eshell:enabled-sections'."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc eshell:sep it))
    acc))

(defun eshell:prompt-func ()
  "Generate the eshell prompt.
This function generates the eshell prompt by concatenating `eshell:header' with
valid `eshell:enabled-sections' and the `eshell-prompt-string'."
  (concat eshell:header
          (->> eshell:enabled-sections
               (mapcar (lambda (it) (void-symbol-intern 'eshell-prompt-- it)))
               (-filter #'fboundp)
               (-reduce-from #'eshell:acc ""))
          eshell-prompt-string))
#+end_src

****** eshell components
:PROPERTIES:
:ID: c22a9cdb-9b9f-4f06-9c09-f330d454ab1f
:END:

This heading contains the parts that make up the eshell prompt. They are the
header, the separator, the section delimiter and, the meat of the prompt, the
actual eshell sections.

#+begin_src emacs-lisp
(defvar eshell:sep "\s|\s"
  "Separator between eshell sections.")

(defvar eshell:section-delim "\s"
  "Separator between an eshell section icon and form.")

(defvar eshell:header "\s"
  "Eshell prompt header.")

(defvar eshell:enabled-sections '(dir git)
  "List of enabled eshell sections.
Each element of the list is an abbreviated.")
#+end_src

This is a regex that matches your eshell prompt so that eshell knows what to
keep readonly and what not to.
#+begin_src emacs-lisp
(setq eshell-prompt-regexp (rx (*? anything) "-> "))
(setq eshell-prompt-string " -> ")

(setq eshell-prompt-function #'eshell:prompt-func)
#+end_src

***** text wrapping
:PROPERTIES:
:ID: 7d155cf8-a90c-4183-a9be-5ffdc266d82a
:END:

#+begin_src emacs-lisp
(defhook! enable-text-wrapping (eshell-mode-hook)
  "Enable text wrapping."
  (visual-line-mode +1)
  (set-display-table-slot standard-display-table 0 ?\ ))
#+end_src

***** fringes
:PROPERTIES:
:ID: 312652e5-9975-4241-b709-7ed5b8537202
:END:

#+begin_src emacs-lisp
(defhook! remove-fringes (eshell-mode-hook)
  "Remove fringes for eshell."
  (set-window-fringes nil 0 0)
  (set-window-margins nil 1 nil))
#+end_src

***** hide modeline
:PROPERTIES:
:ID: 6dc13e60-abd4-40d0-be15-55b11c1faeb2
:END:

(add-hook 'eshell-mode-hook #'hide-mode-line-mode)

**** shrink-path
:PROPERTIES:
:ID: eef8ea28-4de2-44ab-a09d-26f58c0a75ac
:RECIPE:   [[id:6b972082-6c22-40e7-aa4a-21a59ffc1af2][shrink-path]]
:END:

#+begin_src emacs-lisp
(autoload #'shrink-path-file "shrink-path" nil t nil)
#+end_src

** file browsing
:PROPERTIES:
:ID:       324ede5f-4606-40f2-a424-1cdf0c974853
:END:

*** dired
:PROPERTIES:
:ID:       877b66c0-7952-4b37-839a-4a9aa5af164a
:END:

**** settings
:PROPERTIES:
:ID: 55109eeb-8e59-4d15-926e-fbe42ed28056
:END:

#+begin_src emacs-lisp
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'top)
(setq dired-hide-details-hide-symlink-targets nil)
(setq dired-clean-confirm-killing-deleted-buffers nil)
#+end_src

**** sort directories first
:PROPERTIES:
:ID: 4b6c0ed8-dbf2-4a65-adcc-1ce326eac465
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

**** create non-existent directory
:PROPERTIES:
:ID: 66981d0c-fe40-4552-9f63-2c39a7d584d2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

*** ranger
:PROPERTIES:
:ID: 7504cab0-ddd9-4069-b6bb-9a5f3161cace
:RECIPE:   [[id:279852a6-d337-4ac5-b828-2bf438b6e781][ranger]]
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

**** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  ";" #'execute-extended-command
  "u" #'dired-unmark)
#+end_src

**** general bindings
:PROPERTIES:
:ID:       f69d31ab-1385-498c-9423-8fb3d5e4e94e
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "A" #'dired-do-find-regexp
  "C" #'dired-do-copy
  "B" #'dired-do-byte-compile
  "D" #'dired-do-delete
  "H" #'dired-do-hardlink
  "L" #'dired-do-load
  "M" #'dired-do-chmod
  "O" #'dired-do-chown
  "P" #'dired-do-print
  "Q" #'dired-do-find-regexp-and-replace
  "R" #'dired-do-rename
  "S" #'dired-do-symlink
  "T" #'dired-do-touch
  "X" #'dired-do-shell-command
  "Z" #'dired-do-compress
  "c" #'dired-do-compress-to
  "!" #'dired-do-shell-command
  "&" #'dired-do-async-shell-command)
#+end_src

**** entry
:PROPERTIES:
:ID: 2edf3f72-726f-4b31-9ff0-20e5e7d251b1
:END:

#+begin_src emacs-lisp
(--each (list #'deer #'ranger)
  (autoload it "ranger" nil t nil))

(setq ranger-override-dired-mode t)
(setq ranger-cleanup-eagerly t)
(setq ranger-cleanup-on-disable t)
(setq ranger-omit-regexp "^.DS_Store$")
(setq ranger-excluded-extensions
      '("mkv" "iso" "mp4"))
(setq ranger-deer-show-details nil)
(setq ranger-max-preview-size 10)
(setq ranger-modify-header t)
(setq ranger-hide-cursor t)
(setq ranger-dont-show-binary t)
#+end_src

**** refresh contents
:PROPERTIES:
:ID:       cef37397-53aa-47e1-a519-ef56a311ae30
:END:

Ranger doesn't refresh the buffer after stuff like moving and pasting has
happend. It results in a very jarring display.

#+begin_src emacs-lisp
(defadvice! refresh-contents (:after ranger-paste dired-do-rename)
  "Refresh contents."
  (when (eq major-mode 'ranger-mode)
    (ranger-refresh)))
#+end_src

**** toggle dotfiles
:PROPERTIES:
:ID: 5b9b190c-b4a6-4834-b8c9-def16b0457ac
:END:

There's this wierd intermidiate stage between =hidden= and =format= called =prefer= in
which only some files are hidden. That's wierd, so I get rid of it.

#+begin_src emacs-lisp
(defadvice! toggle-between-two-only (:override ranger-toggle-dotfiles)
  "Show/hide dot-files."
  (interactive)
  (setq ranger-show-hidden
        (cl-case ranger-show-hidden
          (hidden 'format)
          (format 'hidden)))
  (ranger-setup))
#+end_src

**** silence window check
:PROPERTIES:
:ID: e9d83b37-1257-4d78-ae5f-863c4e7198d1
:END:

#+begin_src emacs-lisp
(void-silence-output #'ranger-window-check)
#+end_src

** version control
:PROPERTIES:
:ID: d99a378c-449f-4a0d-9b88-dd77d5a41bb1
:END:

*** git-auto-commit-mode
:PROPERTIES:
:ID:       00a518e9-56ae-4c0b-b2cd-518fb4c5d201
:RECIPE:   [[id:06eff195-611f-4f4a-964b-be245ac3d821][git-auto-commit-mode]]
:END:

To avoid losing information. You should commit often in git--like every 10
seconds or so. Obviously doing this manually on the command line (or even on
[[id:d6088ed3-417a-44e8-822b-ce4743f497d0][magit]]) every time is a pain. This package commits your changes every time
you save your file--which for me is all the time because I use [[id:bd455e73-4035-49b9-bbdf-3d59d4906c97][super-save]].

**** settings
:PROPERTIES:
:ID:       8a46cee4-624c-4440-8b99-c6b34d356a6b
:END:

#+begin_src emacs-lisp
(setq gac-automatically-push-p nil)
(setq gac-ask-for-summary nil)
(setq gac-default-message #'gac:commit-message)
(setq gac-commit-additional-flag "-S")
(setq gac-silent-message-p t)
#+end_src

**** toggle summary
:PROPERTIES:
:ID:       50641d0a-0908-4207-bcb9-8e7437e75159
:END:

**** auto-commit
:PROPERTIES:
:ID:       36b71eb7-b71d-47a0-ad0a-5d62825fffa3
:END:

#+begin_src emacs-lisp
(autoload #'git-auto-commit-mode "git-auto-commit-mode" nil t nil)
#+end_src

**** commit message
:PROPERTIES:
:ID:       3f0297a0-5929-4217-a109-545a2a010473
:END:

Committing often as I recommend will inevitably result with commits that are
many bits and pieces of a change. The idea is to then squash together all
related commits for the "polished" result. With this function I create "smart"
commit messages that take advantage of the org headline structure. This makes it
easy to go back and group commits which are related. Note that this function
fails when you have a change that spans across multiple headlines (such as the
replacement of a name throughout a document). This is something I plan to
address later.

#+begin_src emacs-lisp
(defun gac:commit-message (file)
  "Return the commit message for changes to FILE."
  (format "Update %s" (f-base file)))
#+end_src

*** magit
:PROPERTIES:
:ID:       d6088ed3-417a-44e8-822b-ce4743f497d0
:RECIPE:   [[id:49430079-ae8d-4765-8af6-b1596b36d715][magit]]
:END:

**** transient
:PROPERTIES:
:ID: baf64a0f-f9fa-4700-bebf-d996018f894f
:RECIPE:   [[id:2430d838-1202-430f-8371-89f60d996e4f][transient]]
:END:

#+begin_src emacs-lisp
(setq transient-default-level 5)
(setq transient-levels-file (concat VOID-DATA-DIR "transient/levels"))
(setq transient-values-file (concat VOID-DATA-DIR "transient/values"))
(setq transient-history-file (concat VOID-DATA-DIR "transient/history"))
#+end_src

**** magit
:PROPERTIES:
:ID: c8a37b6a-46c7-406e-8793-1186f14407e0
:RECIPE:   [[id:8c795be1-b104-410a-a736-207769302d41][magit]]
:END:

#+begin_src emacs-lisp
(-each '(f s with-editor git-commit package eieio lv transient)
  #'idle-require)

(dbc-add-rule "bottom" "magit" :newname "magit: ")

(ignore! (void-add-hook 'magit-popup-mode-hook #'hide-mode-line-mode))

(setq magit-completing-read-function #'completing-read)
(setq magit-diff-refine-hunk t)
(setq magit-auto-revert-mode t)
#+end_src

**** quitting
:PROPERTIES:
:ID: 49088c3e-6d3a-41b7-aee4-f0bb34c71a0c
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

**** evil-magit
:PROPERTIES:
:ID:       a86e7a69-4e0a-41fd-aca7-66e514332e7f
:RECIPE:   [[id:682fa40e-6c1e-49a1-8599-cc8dff94a682][evil-magit]]
:END:

#+begin_src emacs-lisp
(setq evil-magit-state 'normal)
(autoload #'magit-status "evil-magit" nil t nil)
(void-load-before-call 'evil-magit #'magit-status)
(void-silence-output #'evil-magit-init)
(after! evil-magit (evil-magit-init))
#+end_src


*** git-gutter
:PROPERTIES:
:ID: 96f0c876-533c-4b1a-a4c1-7b6c9bf58c03
:RECIPE:   [[id:951ceac1-a457-419a-874f-827d7348f6ff][git-gutter]]
:END:

#+begin_src emacs-lisp
(autoload #'git-gutter-mode "git-gutter" nil t nil)
#+end_src

** persistence
:PROPERTIES:
:ID:       c73a2fc2-5c43-4f99-9336-3bb2154852b7
:END:

Packages and features that involve saving to external files.

*** saveplace
:PROPERTIES:
:ID:       41cb3357-9b4b-4205-987d-ff72f9a35df3
:END:

This package takes you to the last point you were at when you visited a file.

**** recenter cursor
:PROPERTIES:
:ID:       dda57b64-b645-4eda-be54-9dda4af35404
:END:

#+begin_src emacs-lisp
(defadvice! recenter-on-load (:after-while save-place-find-file-hook)
  "Recenter on cursor when loading a saved place."
  (when buffer-file-name (ignore-errors (recenter))))
#+end_src

**** saveplace
:PROPERTIES:
:ID: 6da42724-3137-4d70-9aed-9a978357679f
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(void-load-after-call #'after-find-file #'saveplace t)

(setq save-place-file (concat VOID-DATA-DIR "saveplace"))
(setq save-place-limit nil)
#+end_src

*** recentf
:PROPERTIES:
:ID: f26bedb3-a172-4543-afd0-4c47f5872d15
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[id:f26bedb3-a172-4543-afd0-4c47f5872d15][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

**** init
:PROPERTIES:
:ID:       3e25c6a3-6a0f-47a4-a63f-ceca6476cc59
:END:

#+begin_src emacs-lisp
(-each '(easymenu tree-widget timer) #'idle-require)
(void-load-before-call 'recentf #'find-file t)
#+end_src

**** settings
:PROPERTIES:
:ID:       3b9ab738-de00-40d4-93be-b2c84bfaac5c
:END:

#+begin_src emacs-lisp
(setq recentf-max-menu-items 0)
(setq recentf-max-saved-items 700)

(setq recentf-exclude
      (list #'file-remote-p
            "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
	    ;; ignore private Void temp files (but not all of them)
            #'(lambda (file)
                (-some-p (apply-partially #'file-in-directory-p file)
		 (list VOID-DATA-DIR)))))

(gsetq recentf-save-file (concat VOID-DATA-DIR "recentf"))
(gsetq recentf-auto-cleanup 'never)
(gsetq recentf-filename-handlers '(file-truename abbreviate-file-name))
#+end_src

**** cleanup before saving
:PROPERTIES:
:ID:       8b682202-b948-4e6a-ac64-089726f7d84e
:END:

#+begin_src emacs-lisp
(void-add-advice #'recentf-save-list :before #'recentf-cleanup)
#+end_src

**** silence recentf
:PROPERTIES:
:ID: 15a971c4-b43a-4539-846e-70fe4e90d84a
:END:

[[][recentf-mode]] as well as [[][recentf-cleanup]] output to the messages buffer.

#+begin_src emacs-lisp
(-each (list #'recentf-mode #'recentf-cleanup)
  #'void-silence-output)
#+end_src

*** savehist
:PROPERTIES:
:ID:       dd4b9da7-e54d-4d62-bb70-aa8f7f4a016f
:END:

=savehist= is a built-in feature for saving the minibuffer-history to a file--the
[[helpvar:savehist][savehist]] file. Additionally, it provides the ability to save additional
variables which may or may not be related to minibuffer history. You add the
ones you want to save to [[helpvar:savehist-additional-variables][savehist-additional-variables]].

**** init
:PROPERTIES:
:ID:       54183df6-b4f5-4b01-9ddb-4054ef0583b0
:END:

#+begin_src emacs-lisp
(setq savehist-save-minibuffer-history t)
(setq savehist-autosave-interval nil)
(setq savehist-file (concat VOID-DATA-DIR "savehist"))

(idle-require 'custom)
(void-add-hook 'emacs-startup-hook #'savehist-mode)

(setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
#+end_src

**** unpropertize kill ring
:PROPERTIES:
:ID:       da2b6c31-d251-48aa-a6ed-8f01b9fa0b8d
:END:

#+begin_src elisp
(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (setq kill-ring
        (--map (when (stringp it) (substring-no-properties it))
               (-non-nil kill-ring))))
#+end_src

* Window management
:PROPERTIES:
:ID:       f8f186bd-a701-4bd4-a249-86ec4faff83b
:END:

** workspaces
:PROPERTIES:
:ID:       c979c631-4098-4204-b067-82f58b5b9ebe
:END:

*** tab-bar-mode
:PROPERTIES:
:ID:       0a72fe9a-1948-4022-a300-18a4881da382
:END:

**** settings
:PROPERTIES:
:ID:       bb63f5b2-cc45-454b-a032-be248f801636
:END:

#+begin_src emacs-lisp
(void-add-hook 'tab-bar-mode-hook #'tab-bar-history-mode)
#+end_src

**** tabbar-mode
:PROPERTIES:
:ID:       5ffc2d82-533d-4bad-8e15-8032b5d3b0dc
:END:

#+begin_src emacs-lisp
(gsetq tab-bar-history-limit 25)
(gsetq tab-bar-new-tab-choice "*scratch*")
(gsetq tab-bar-tab-hints nil)
(gsetq tab-bar-show nil)
#+end_src

**** dont actually display the tabs
:PROPERTIES:
:ID:       e4cee146-f6ac-47f1-9e98-f209ae9f9bec
:END:

I want the tabs to exist as a concept, but (ironically) I don't actually want
them displayed.

#+begin_src emacs-lisp
(defadvice! inhibit-tab-display (:after tab-bar-mode make-frame)
  "Inhibit the display of tags in tab-bar-mode."
  (--each (frame-list)
    (set-frame-parameter it 'tab-bar-lines 0)))
#+end_src

*** desktop
:PROPERTIES:
:ID:       902a11fc-b9aa-4875-ba92-8d2561a12a50
:END:

=desktop= is a built-in emacs package for saving window configuration setup.

**** some settings
:PROPERTIES:
:ID:       e4c30275-db62-4e6d-890c-6199b0594fd8
:END:

#+begin_src emacs-lisp
(setq desktop-save t) ; what should happen when desktop is killed.
(setq desktop-dirname VOID-DATA-DIR)
(setq desktop-auto-save-timeout auto-save-timeout)
(setq desktop-base-file-name "emacs.desktop")
(setq desktop-base-lock-name "emacs.desktop.lock")
(setq desktop-path (list VOID-DATA-DIR))
(setq desktop-missing-file-warning nil)
#+end_src

**** allowing desktops to go in one directory
:PROPERTIES:
:ID:       22b0be3a-ef36-47d4-8684-602f3a8c8462
:END:

These functions are all based on the =desktop+= functions. The main thing it
does is provide a directory where desktop files can be placed. This should
really have been done by =desktop.el= but oh well.

***** base directory
:PROPERTIES:
:ID:       e1ce2616-2280-435d-85c4-8d71c30c6a75
:END:

#+begin_src emacs-lisp
(defvar desktop:base-dir (concat VOID-DATA-DIR "desktops/")
  "Directory where desktops should go.")
#+end_src

***** generate the base directory
:PROPERTIES:
:ID:       fa173f38-2888-465a-8de4-282233322363
:END:

#+begin_src emacs-lisp
(defun desktop:dirname (name)
  "Return the path where desktop named NAME should go."
  (require 'f)
  (f-join desktop:base-dir name))
#+end_src

***** ensure the base directory
:PROPERTIES:
:ID:       3662ceaa-aed9-4dbc-bea9-7e1878237c87
:END:

#+begin_src emacs-lisp
(defhook! ensure-desktop-directory (desktop-mode-hook)
  "Make `desktop:base-dir' if it does not exist."
  (mkdir desktop:base-dir t))
#+end_src

***** desktop names
:PROPERTIES:
:ID:       5286a22f-dc93-4e32-8a35-3bfbdfda8668
:END:

#+begin_src emacs-lisp
(defun desktop:list ()
  "Return a list of the names of all desktops."
  (-difference (directory-files desktop:base-dir)
	       (list ".." ".")))
#+end_src

***** create a desktop
:PROPERTIES:
:ID:       331367bb-a1eb-414f-89ef-386ba6fc1e60
:END:

#+begin_src emacs-lisp
(defun desktop:create-desktop (name)
  "Create a new desktop named NAME."
  (let ((desktop-dirname (desktop:dirname name)))
    (desktop-kill)
    (make-directory desktop-dirname 'parents)
    (desktop-save desktop-dirname)))
#+end_src

***** load an existing desktop
:PROPERTIES:
:ID:       691dd9bf-b207-4885-9f7c-b8791d972dc1
:END:

#+begin_src emacs-lisp
(defun desktop:load-desktop (name)
  (desktop-change-dir (desktop:dirname name)))
#+end_src

**** create desktop in new tab
:PROPERTIES:
:ID:       4bbb0f3a-bc51-4552-b91f-8404ab19cdd8
:END:

This is an integration with desktop and tab mode.

#+begin_src emacs-lisp
(defun desktop/create-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Create desktop:" (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:create-desktop name))
#+end_src

**** load desktop in a new tab
:PROPERTIES:
:ID:       391c0817-bb2f-4334-b320-f039ab23cfb7
:END:

#+begin_src emacs-lisp
(defun desktop/load-desktop-in-new-tab (name)
  "Create desktop named NAME in new tab.
The tab's new name is the same as the desktop name."
  (interactive
   (list (completing-read "Load desktop: " (desktop:list))))
  (tab-bar-new-tab)
  (tab-bar-rename-tab name)
  (desktop:load-desktop name))
#+end_src

**** desktop restore functions
:PROPERTIES:
:ID:       0f82a1dc-d28e-4875-a622-e6116c0d3843
:END:

***** helpful-buffers
:PROPERTIES:
:ID:       f7d3a8ce-7115-47d6-b0ac-2d078741a49a
:END:

#+begin_src emacs-lisp
(defun desktop:restore-helpful-buffer ()
  "Restore helpful buffer.")
#+end_src

*** workgroups2
:PROPERTIES:
:ID:       890c8e5b-524d-44b6-b90e-c830436b9da8
:RECIPE:   [[id:e3d00a24-740f-4760-af33-25327d04d97d][workgroups2]]
:END:

There is a need to save buffers and window configurations in their own groups.
Often we'll have a group of buffers we've setup to work on a project or task and
suddenly, in the middle of that task we'll want to work on another task. It's
inconvenient to get rid of the window configuration we've set up just to have to
come back to it and set it up again. This is what workspaces, also called
workgroups, are for. You can save the window configuration you're using and
switch to a new one.

Workgroup provides a. One notable advantage of workgroups is that it does not
use emacs's built-in serialization of window configs. Usually, it is better to
use something that's built-in. However, emacs's serialization has the drawback
that it's not a lisp object; implying that it is not.

**** settings
:PROPERTIES:
:ID:       3de17bba-1c3e-4d7d-a30c-f34f1eda640b
:END:

#+begin_src emacs-lisp
(setq wg-load-last-workgroup nil)
(setq wg-open-this-wg nil)
(setq wg-control-frames nil)
(setq wg-session-load-on-start nil)
(setq wg-flag-modified nil)
(setq wg-session-file (concat VOID-DATA-DIR "wg-session"))
#+end_src

**** init
:PROPERTIES:
:ID:       eb3016f9-5c3d-407c-99db-b23d5bf4e7f8
:END:

#+begin_src emacs-lisp
(autoload #'wg-switch-workgroup "workgroup" nil)
#+end_src

**** ignore changing the modeline
:PROPERTIES:
:ID:       a036dc89-7d5e-49b6-880c-87b4a4c2105e
:END:

#+begin_src emacs-lisp
(setq wg-mode-line-display-on nil)
(advice-add #'wg-change-modeline :override #'ignore)
#+end_src

**** save sessions on quit
:PROPERTIES:
:ID:       1ca7da0b-7227-48be-88a7-8ad738c5263e
:END:

#+begin_src emacs-lisp
(setq wg-emacs-exit-save-behavior 'save)
(setq wg-workgroups-mode-exit-save-behavior 'save)
(setq wg-flag-modified nil)
#+end_src

**** shut up messages from workgroup commands
:PROPERTIES:
:ID:       6dc3b7c4-7afd-46a0-850a-1a362cd7e601
:END:

#+begin_src emacs-lisp
(--each (list #'wg-create-workgroup #'wg-switch-workgroup)
  #'void-silence-output)
#+end_src

**** by default create a new workgroup using scratch buffer
:PROPERTIES:
:ID:       5b5357d2-1c11-4d58-9eba-450772a15009
:END:

When a new workgroup is created it's done by.

** zoom-window
:PROPERTIES:
:ID:       d506fde5-d1bc-4807-a1d0-a8ed5c33def2
:RECIPE:   [[id:a75d9e92-3b11-4b05-bb13-8a2a95f402a2][zoom-window]]
:END:

This package provides a command that temporarily makes a window occupy full
screen. And then reverts the window configuration to what it was again
afterwards.

#+begin_src emacs-lisp
(autoload #'zoom-window-zoom "zoom-window" nil t nil)
#+end_src

** exwm
:PROPERTIES:
:ID: dbb69880-2180-4ecc-897d-78ff72a6358b
:RECIPE:   [[id:92ff5d3c-1716-4fd4-be51-34c6b02c6115][exwm]]
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.
There are benefits and drawbacks to making emacs your window manager. One
benefit is that you get a super consistent window management experience. If you
use a typical window manager, you have to.

*** init
:PROPERTIES:
:ID:       f1fd1ea5-2e96-4842-8bab-4080628bf357
:END:

#+begin_src emacs-lisp
#+end_src

*** init
:PROPERTIES:
:ID:       581b8529-00a0-4935-9363-60dba9dbe5f4
:END:

This isn't precise, I want exwm to trigger itself when I try to open
any external application but right now I'm not sure of how to do that
so I deal with my most often case--opening the browser. This assumes
[[helpfn:browse-url][browse-url]] will be used to open an external browser, which might not
be the case. I'll address this in time.

=exwm= provides an option [[helpvar:exwm-replace][exwm-replace]] to deal with the case of an existing
window manager when exwm is initializing itself. There are three
ways. You could replace it with exwm without asking, ask whether to
replace it, or abort the initialization of exwm.

I always want exwm to assume that if I'm using another window manager,
I don't want to use exwm. Only problem is =exwm= aborts with an annoying
=user-error=.

#+begin_src emacs-lisp
(alet #'void--load-and-initialize-exwm-maybe-advice
  (void-add-advice #'browse-url :before it nil t))

(defun void--load-and-initialize-exwm-maybe-advice (&rest _)
  "Try to initialize exwm.
If it's not possible, abort initialization gracefully."
  (with-os! linux
    (require 'exwm)
    ;; Try to enable exwm.
    (let ((exwm-replace nil))
      (if (ignore-errors (exwm-init))
	  ;; Enable the clipboard.
	  (progn (require 'exwm-systemtray)
		 (exwm-systemtray-enable))
	(void-log "Another window manager is present (or something went wrong).")))))
#+end_src

*** org capture from an exwm buffer
:PROPERTIES:
:ID:       5428bdc1-c075-4387-b3ab-080d372c478f
:END:

A common dream among many Org users is to integrate [[info:org#Capture][org-capture]] into their browser.
Indeed, the browser by nature would be a place you'd want to capture from a lot.
However, since graphical browsers are not in emacs the main way to do this was
via a hacky and difficult to set up [[https://orgmode.org/worg/org-contrib/org-protocol.html][org-protocol]].

https://www.reddit.com/r/emacs/comments/f6zzux/capturing_website_url_with_orgcapture_and_exwm/

**** exwm title
:PROPERTIES:
:ID:       ce78d409-e635-4d94-b20e-38c2034ab5e8
:END:

#+begin_src emacs-lisp
(defun exwm::title-info (title)
  "Return the webpage and the program."
  (-let [(_ webpage program) (s-match "\\([^z-a]+\\) - \\([^z-a]+\\)\\'" title)]
    (list webpage program)))
#+end_src

**** download webpage as pdf
:PROPERTIES:
:ID:       bd7165df-9dae-4954-b153-96335678e296
:END:

Storing the links is better, but not good enough. Webpages die. They can be
taken off by a third-party or removed by the owner themselves. Even if they
aren't though, they can be modified so that what you originally found isn't
there anymore. As a solution for this I came upon [[https://wkhtmltopdf.org/][wkhtmltopdf]], a command that
downloads a given webpage as pdf. A consequence of doing this is that you will
have access to all the webpages you used for research offline.

#+begin_src emacs-lisp
(defun void-download-webpage-as-pdf (url webpage-title)
  "Save the webpage at URL to `VOID-SCREENSHOT-DIR'."
  (let* ((program "wkhtmltopdf")
         (process-name (format "%s - %s" program (ts-format)))
         (webpage-title (s-replace "/" "~" webpage-title))
         (pdf-path (format "%s%s.pdf" VOID-SCREENSHOT-DIR webpage-title))
         (fn `(lambda (&rest _)
                (if (file-exists-p ,pdf-path)
                    (message "Webpage saved succesfully.")
                  (warn "Failed to save webpage %s to %s." ,url ,pdf-path)))))
    (message "%s <-- %s" (f-abbrev pdf-path) url)
    (async-start-process process-name "firejail" fn program url pdf-path)))
#+end_src

**** replacement for fake id
:PROPERTIES:
:ID:       4f0436c4-bc37-49b0-a8a3-894e212d4d13
:END:

#+begin_src emacs-lisp
(defun exwm-input::fake-key-to-id (event id)
  "Fake a key event equivalent to Emacs event EVENT and send it
 to program with x window ID."
  (let* ((keysym (xcb:keysyms:event->keysym exwm--connection event))
         keycode)
    (when (= 0 (car keysym))
      (user-error "[EXWM] Invalid key: %s" (single-key-description event)))
    (setq keycode (xcb:keysyms:keysym->keycode exwm--connection
					       (car keysym)))
    (when (/= 0 keycode)
      (dolist (class '(xcb:KeyPress xcb:KeyRelease))
        (xcb:+request exwm--connection
	    (make-instance
	     'xcb:SendEvent
	     :propagate 0 :destination id
	     :event-mask xcb:EventMask:NoEvent
	     :event
	     (xcb:marshal
	      (make-instance
	       class
	       :detail keycode :time xcb:Time:CurrentTime
	       :root exwm--root :event id :child 0 :root-x 0 :root-y 0
	       :event-x 0 :event-y 0 :state (cdr keysym) :same-screen 0)
	      exwm--connection)))))
    (xcb:flush exwm--connection)))
#+end_src

**** url from firefox
:PROPERTIES:
:ID:       f407cc8c-0bb9-47fe-adeb-4e9d27b5c5b7
:END:

Emacs simulates a keypress to firefox--specifically the keypresses to select the
current url and to add it to the kill ring.

#+begin_src emacs-lisp
(defun exwm::firefox-url ()
  "Save the current firefox url to kill ring."
  ;; We get the xwindow id of the buffer named Firefox
  (let ((fid (exwm--buffer->id (current-buffer))))
    ;; Send c-l to select url
    (exwm-input::fake-key-to-id 'C-l fid)
    ;; We sleep to avoid race conditions.
    (sleep-for 0 300)
    ;; Copy url to kill ring (note: this is not affected by simulation keys)
    (exwm-input::fake-key-to-id 'C-c fid)
    (sleep-for 0 300)
    ;; try to set the state back
    (exwm-input::fake-key-to-id 'escape fid)
    (current-kill 0)))
#+end_src

**** url from qutebrowser
:PROPERTIES:
:ID:       822cbb61-60b4-445e-9756-4bf797500375
:END:

#+begin_src emacs-lisp
(defun exwm::qutebrowser-url ()
  (interactive)
  (let ((fid (exwm--buffer->id (current-buffer))))
    (sleep-for 0 300)
    ;; if in insert state exit it.
    (exwm-input::fake-key-to-id 'escape fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (exwm-input::fake-key-to-id 'y fid)
    (sleep-for 0 300)
    (aprog1 (current-kill 0)
      (void-log "Copied %S to the kill ring." it))))
#+end_src

*** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

By default each exwm buffer is named =*EXWM*=. We want them to have
a more descriptive name.

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

*** popup rules for exwm buffers
:PROPERTIES:
:ID:       0ecf05ce-4a76-4130-855e-e8d0d7390df1
:END:

*** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

**** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar exwm:char-mode-apps (list "emacs" "next" "nyxt" "qutebrowser")
  "List of applications to exwm should start in char-mode.")
#+end_src

**** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `exwm:char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) exwm:char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

*** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:RECIPE:   [[id:ff34a425-de3a-4334-8f0e-eea036468930][exwm-edit]]
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

Concerning the loading of exwm-edit. Ideally, I should load it after
certain applications where I'd use it need to be loaded.

#+begin_src emacs-lisp
(autoload #'exwm-edit "exwm-edit" nil t nil)

(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
	   'exwm-input-global-keys
	   `((,(kbd "C-'") . exwm-edit))))
#+end_src

*** keybindings
:PROPERTIES:
:ID: 293bc7c5-1320-4f3f-af2b-198d56694f71
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . void/open-qutebrowser)
             (,(kbd "s-e") . void/open-emacs-instance)))
  (general-def
    "s-R" #'exwm-reset
    "s-x" #'exwm-input-toggle-keyboard
    "s-h" #'windmove-left
    "s-j" #'windmove-down
    "s-k" #'windmove-up
    "s-l" #'windmove-right
    "s-t" #'transpose-frame
    "s-D" #'kill-this-buffer
    "s-b" #'switch-to-buffer
    "s-f" #'find-file
    "s-O" #'exwm-layout-toggle-fullscreen
    "s-p" #'previous-buffer
    "s-n" #'next-buffer
    "s-q" #'void/open-qutebrowser
    "s-e" #'void/open-emacs-instance))
#+end_src

** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun void/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun void/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

** window bindings
:PROPERTIES:
:ID:       5b4d2ce0-667f-42c8-bad4-880f371fddc4
:END:

These bindings pertain to manipulating windows.

*** set the window leader
:PROPERTIES:
:ID: 784956e2-3696-4f92-80ca-41b7e30e5b2b
:END:

Efficient window management in Emacs crucial for success. These keys all pertain
to window/workspace actions.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  ""  (list :ignore nil :wk "window"))
#+end_src

*** motion
:PROPERTIES:
:ID:       ef50a2d7-deab-40b8-a654-133d9d3edd48
:END:

This headline is for bindings that involve traversing windows. The typical
bindings for moving up, down, left and right between windows. And as a bonus, a
binding to.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "h" (list :def #'windmove-left  :wk "left")
  "j" (list :def #'windmove-down  :wk "down")
  "k" (list :def #'windmove-up    :wk "up")
  "l" (list :def #'windmove-right :wk "right")
  "o" (list :def #'ace-window     :wk "other"))
#+end_src

*** splitting
:PROPERTIES:
:ID:       6c49babb-b749-4501-8699-dd2d7f885488
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "S" (list :def #'void/window-split-below-and-focus :wk "split below and focus")
  "V" (list :def #'void/window-split-right-and-focus :wk "split right and focus")
  "s" (list :def #'window-split-below                :wk "split below")
  "v" (list :def #'window-split-right                :wk "split right"))
#+end_src

*** deleting
:PROPERTIES:
:ID:       218f650f-f52f-4cdf-9731-032631612ad3
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "d" (list :def #'delete-window        :wk "delete current")
  "D" (list :def #'delete-other-windows :wk "delete others"))
#+end_src

*** resizing
:PROPERTIES:
:ID:       0aed1e9d-acff-430c-8372-23a620726bae
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "M" (list :def #'maximize-window  :wk "maximize")
  "m" (list :def #'minimize-window  :wk "maximize")
  "b" (list :def #'window-balance   :wk "maximize")
  "z" (list :def #'zoom-window-zoom :wk "zoom"))
#+end_src

*** layout
:PROPERTIES:
:ID:       864e890f-d67c-40bc-8f72-49f4d6a21d5d
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "x" (list :def #'ace-swap-window :wk "swap windows")
  "t" (list :def #'transpose-frame :wk "transpose"))
#+end_src

*** workgroups
:PROPERTIES:
:ID:       8cb7ee3d-6d9e-4fbf-a96a-5f7cdc2aa363
:RECIPE:   [[id:c5cca2d0-2479-4ced-8b97-fcc2d9995203][workgroups]]
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  "w" (list :ignore t :wk "workgroup"))

(defun wg/create-workgroup ()
  (call-interactively #'wg-open-workgroup))

(define-leader-key!
  :infix "w w"
  "c" (list :def #'wg-create-workgroup          :wk "open") 
  "o" (list :def #'wg-open-workgroup            :wk "open") 
  "s" (list :def #'wg-switch-workgroup          :wk "switch") 
  "h" (list :def #'wg-switch-to-workgroup-left  :wk "left") 
  "l" (list :def #'wg-switch-to-workgroup-right :wk "right"))
#+end_src

* Text Editing
:PROPERTIES:
:ID:       40fb1b29-b772-456f-aac6-cf4a3b5cde3f
:END:

** separedit
:PROPERTIES:
:ID:       07021099-6cea-4016-929b-d9310ea305f8
:RECIPE:   [[id:bd9d7045-b6df-4fd1-8aaf-2341efe1cde4][separedit]]
:END:

#+begin_src emacs-lisp
(autoload #'separedit-dwim "separedit" nil t nil)
#+end_src

** edit-indirect
:PROPERTIES:
:ID:       786b11a6-561b-4793-9c6c-f7630aba3774
:RECIPE:   [[id:33c74235-2ece-42fb-aab8-b5522f86d895][edit-indirect]]
:END:

=edit-indirect= is a package that provides a means to edit text in an indirect
buffer. It's the same concept as org-src buffers but is not tied to org-mode.

*** editing org descriptions
:PROPERTIES:
:ID:       bdabe0b9-4116-423b-9fc0-049651bed58a
:END:

This headline contains customizations and extensions to =edit-indirect= so that I
can use it to edit org descriptions in the same way that we edit source blocks.

There are two cases when editing a description. There's the case of an existing
description and there's the case of a new one.

**** init
:PROPERTIES:
:ID:       8eb7b300-4df2-4a27-bae5-12bb982060f6
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "org description" :newname "\\*Org Desc - .+")
#+end_src

**** description bounds
:PROPERTIES:
:ID:       74367212-cbd0-4871-94d5-24980e997bd7
:END:

=edit-indirect= requires the beginning and end of the editing region, so I need
to determine the beginning and end of the description.

I want my descriptions after property drawers (and any whitespace that follows
them).

After an org heading node there is a section subnode which is the parent of all
the heading's contents. If it has more than one child, the blank following the
property drawer child pertains to the property drawer. However, if it's only
child is the property drawer then the post blank pertains to the section
itself.

The approach I took to doing figuring this out is using the =org-element= parser
to determine.

It is important to note that my
tendency in org mode is to have a headline with at most one description and at
most one source block.

When there is no existing description, the beginning and the end are the
same--the end point of the property drawer. And yes, I assume the heading has a
property drawer, at least for now. In my usage it's a good assumption because
every headline in my org file should have a property drawer.

#+begin_src emacs-lisp
(defun org:description-bounds ()
  "Return the bounds of description at headline.
If there is no existing description return nil."
  (interactive)
  (let* ((parse-tree (org-ml-parse-subtree-at (point)))
	 (elements '(headline section property-drawer src-block paragraph))
	 (nodes (->> (org-element-map parse-tree elements #'identity)
		     (--split-when (eq (org-element-type it) 'headline))
		     (car))))
    (aif (car (--split-when (not (eq (org-element-type it) 'paragraph)) nodes))
	(cons (org-element-property :begin (-first-item it))
	      (org-element-property :end (-last-item it)))
      (-let* ((section (--first (eq (org-element-type it) 'section) nodes))
	      ((property-drawer others) (org-element-contents section)))
	(alet (org-element-property :end (if others property-drawer section))
	  (cons it it))))))
#+end_src

**** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org:description-default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

**** hooks
:PROPERTIES:
:ID:       6ab3a2cc-17aa-4166-aa3f-8627afe40c1a
:END:

=edit-indirect= has hooks for whenever you want to do a quick thing.

***** goto last non-white
:PROPERTIES:
:ID:       f9afdc3d-ceea-4e9e-a986-9f6bb7e860f6
:END:

Most of the time I will want to add to the end of a description. Therefore, I
want the cursor to start at the last non-whitespace character of the
description.

#+begin_src emacs-lisp
(defun org:description-goto-last-non-white ()
  (goto-char (point-max))
  (skip-chars-backward "\n\s"))
#+end_src

***** add newlines in the beginning
:PROPERTIES:
:ID:       46917f50-8e0b-4c29-8f9b-1aab7e0e9550
:END:

In the case where there was no existing description, we need to add newlines to
the description buffer so that if we end up committing a change the description
will be placed properly in relation to what's below it. This hook is designed to
make sure this happens.

#+begin_src emacs-lisp
(defun org:description-add-newlines ()
  "Add newlines."
  (save-excursion
    (--dotimes (1+ org:description-default-post-blanks)
      (insert "\n"))))
#+end_src

***** maybe remove newline
:PROPERTIES:
:ID:       cfa12a0f-fd23-4684-bb10-b86b2e4e5c58
:END:

When you open a description buffer and close it again, you'd expect the source
buffer to stay the same--and you should expect this. Since we add newlines to
the description buffer when there's no existing description, we could
inadvertently edit the source buffer in this case. So this hook is to remove any
newlines added in the case that nothing was changed.

#+begin_src emacs-lisp
(defun org:description-maybe-remove-newline ()
  "Remove newline if that's all there is."
  (alet (buffer-string)
    (when (and (seq-every-p (lambda (char) (= 10 char)) it)
	       (= (1+ org:description-default-post-blanks) (length it)))
      (erase-buffer))))
#+end_src

**** define a minor mode for editing descriptions
:PROPERTIES:
:ID:       8775acdc-0389-40af-a5f4-e74c78144944
:END:

The way I've set things up editing descriptions is it's own "thing". I'm going
to be adding hooks and maybe even binding keys with editing descriptions in mind.
Therefore, I think it's worthy to give it it's own mode.

#+begin_src emacs-lisp
(define-minor-mode org:description-edit-mode
  "Mode for editing org descriptions.")
#+end_src

**** requirements for editing descriptions
:PROPERTIES:
:ID:       9a789e79-84b8-4415-b152-e11fca786587
:END:

The edit description function requires =org-ml= and =edit-indirect=. I don't
know if this is the best way to declare these dependencies. It certaintly is
efficient.

#+begin_src emacs-lisp
(void-load-before-call 'org-ml #'org/dwim-edit-description)
(void-load-before-call 'edit-indirect #'org/dwim-edit-description)
#+end_src

**** edit description
:PROPERTIES:
:ID:       3a7da5c8-f445-4592-b0c0-7fbff3be912e
:END:

It is uncough to edit the text of the buffer when we're not commit it--even
worse to have to edit it again afterwards if we don't end up committing
anything. No, instead we should work with the edit indirect buffer.

We need to make sure that we respect [[helpvar:edit-indirect-after-creation-hook][edit-indirect-after-creation-hook]] by doing
our description management stuff before anything is done in that hook. It may be
worth it to consider creating a hook specifically for org descriptions.

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  (interactive)
  (-let* (((beg . end) (org:description-bounds))
	  (was-empty-p (= beg end)))
    (unless beg (user-error "No description at headline."))
    (let ((edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	  (headline (org-get-heading t t t t)))
      (when was-empty-p
	(add-hook 'edit-indirect-after-creation-hook #'org:description-add-newlines 0))
      (add-hook 'edit-indirect-after-creation-hook #'org:description-goto-last-non-white 0)
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Desc - %s*" headline) t)
	(org:description-edit-mode 1)
	(add-hook 'edit-indirect-before-commit-hook
		  #'org:description-maybe-remove-newline nil t)
	(select-window (display-buffer (buffer-name)))))))
#+end_src

**** evil support
:PROPERTIES:
:ID:       f270092b-19ca-40ba-87aa-77b3d314c9a6
:END:

When I open a buffer for editing a description it is very likely that I'll end
up appending more commentary to the existing description. I think it will save
me more time making that common case easier than the cost for the few situations
where I don't do this.

#+begin_src emacs-lisp
(after! evil
  (void-add-hook 'org:description-edit-mode-hook #'evil-insert-state))
#+end_src

**** custom hooks
:PROPERTIES:
:ID:       240acf8a-621e-4e44-9c11-250b70a0e3dc
:END:

#+begin_src emacs-lisp
(alet (list #'auto-capitalize-mode #'aggressive-fill-paragraph-mode
	    #'org-link-minor-mode)
  (void-add-hook 'org:description-edit-mode-hook it))
#+end_src

*** editing org source blocks
:PROPERTIES:
:ID:       5d7edceb-9934-4bfe-a556-cdc0512288e0
:END:

Why reinvent the wheel? While we can already edit source blocks with org
built-in [[helpfn:org-edit-src-code][org-edit-src-code]], I value consistency. Instead of using two different
implementations for editing in an indirect buffer, I'd rather just use
one. =edit-indirect= is simpler, more general and more customizable than the
source block editing tools used by org mode.

**** popup rule
:PROPERTIES:
:ID:       56dc7e88-35a1-471d-8123-fcd0fdd85590
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "org source blocks" :newname "\\*Org[[:space:]]\\(?:S\\(?:ource\\|rc\\)\\).+")
#+end_src

**** minor mode for org source buffers
:PROPERTIES:
:ID:       9e55d8ab-23d8-4b40-beac-ab0fb151f02f
:END:

#+begin_src emacs-lisp
(define-minor-mode org:source-mode ())
#+end_src

**** hooks
:PROPERTIES:
:ID:       84daf376-561e-4b12-a134-b3d50ec14efe
:END:

***** add newlines
:PROPERTIES:
:ID:       adc49d00-604c-47c7-b8fd-df3a30eb243a
:END:

#+begin_src emacs-lisp
(defun org-source:remove-if-only-newline ()
  (when (string= (buffer-string) "\n")
    (erase-buffer)))
#+end_src

**** default post blanks
:PROPERTIES:
:ID:       117478bf-3759-4a00-b738-9b1aad99ed54
:END:

It is my preference to have one blank line after a description--or any org item
for that matter. I just find it much more readable and less cluttered.

#+begin_src emacs-lisp
(defvar org:source-default-post-blanks 1
  "Number of blank lines that should follow a description.")
#+end_src

**** main function for editing source block
:PROPERTIES:
:ID:       519013b5-258b-48e1-801b-84bda1175101
:END:

When editing a source block we face a similar problem to descriptions--namely,
the case when the org source buffer is empty. In this case we need to add a
newline and only commit if the user has added content to the source block.

The style in which I wrote this function is different from the last because it
was inconvenient to get the start and end points of the source block contents. I
have not finished with this source block.

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit org source block."
  (interactive)
  (alet (-> (org-ml-parse-subtree-at (point))
	    (org-element-map '(headline src-block) #'identity nil))
    (-let* ((headline (car-safe (org-element-property :title (car it))))
	    (source-block (--first (eq 'src-block (org-element-type it)) it))
	    (edit-indirect-after-creation-hook edit-indirect-after-creation-hook)
	    (lang (org-element-property :language source-block))
	    ((beg end) (org-src--contents-area source-block)))
      (with-current-buffer (edit-indirect-region beg end)
	(rename-buffer (format "*Org Source - %s*" headline) t)
	(funcall (org-src-get-lang-mode lang))
	(when (= beg end)
	  (goto-char (point-max))
	  (insert "\n")
	  (alet #'org-source:remove-if-only-newline
	    (add-hook 'edit-indirect-before-commit-hook it nil t)))
	(goto-char (point-min))
	(select-window (display-buffer (buffer-name)))))))
#+end_src

**** trim any trailing whitespace
:PROPERTIES:
:ID:       3a3d2ddb-7f80-4627-9733-986f4af1d2d7
:END:

A common annoyance is dealing accidentally leaving trailing whitespace in the
source buffer and then finding out when you see it written to the org file. With
this I never have to think about this again.

#+begin_src emacs-lisp
(void-add-hook 'org-edit-source-mode-hook #'delete-trailing-whitespace)
#+end_src

*** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(define-localleader-key!
  :keymaps 'edit-indirect-mode-map
  "," #'edit-indirect-commit
  "c" #'edit-indirect-commit
  "a" #'edit-indirect-abort)
#+end_src

** expand-region
:PROPERTIES:
:ID:       7e873fba-33ea-4720-ad79-bd8d557cc4b3
:RECIPE:   [[id:90888b86-f47f-4cbc-9c41-aa8d6e40035b][expand-region]]
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

*** init
:PROPERTIES:
:ID:       41a1cebc-8da8-4e5c-8258-2ce440f1af50
:END:

#+begin_src emacs-lisp
(--each (list #'er/expand-region #'er/contract-region #'er/mark-symbol)
  (autoload it "expand-region" nil t nil))
#+end_src

*** quit expand region
:PROPERTIES:
:ID:       639824e1-0dcf-46bc-98b4-c70b9c7cb2a6
:END:

#+begin_src emacs-lisp
(defadvice! quit-expand-region (:before evil-escape)
  "Properly abort an expand-region region."
  (when (memq last-command '(er/expand-region er/contract-region))
    (er/contract-region 0)))
#+end_src

*** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:RECIPE:   [[id:1065c8ad-96c6-49a0-8318-05ffa6f44896][expand-region]]
:END:

#+begin_src emacs-lisp
(define-key! 'visual
  "V" #'er/contract-region
  "v" #'er/expand-region)
#+end_src

** writing
:PROPERTIES:
:ID:       98b567f1-00ad-4c99-aace-0a12f4d1b353
:END:

This headline is for packages and configuration related to writing such as spell
and grammer checking.

*** plural
:PROPERTIES:
:ID:       bf2ed9b7-144c-4d4b-92ae-74c93dfc6db5
:RECIPE:   [[id:164d9446-f9f8-4c2f-9b8c-628d8d59a382][plural]]
:END:

This package determines whether a noun is plural and provides a function to
convert a singular noun to a plural one. For example ~(plural-pluralize
"goose")~ returns ~"geese"~.

My intended use for this package is to help automate prompts, docstrings or the
like that concern N number of things, where N could be 1 or more things.

#+begin_src emacs-lisp
(autoload #'plural-make-plural "plural" nil t nil)

(after! plural
  (push (cons (rx bos "is" eos) "are") plural-knowledge)
  (push (cons (rx bos "thas" eos) "those") plural-knowledge)
  (push (cons (rx bos "this" eos) "these") plural-knowledge))
#+end_src

*** auto-capitalize
:PROPERTIES:
:ID:       4ddfacc1-a25e-466e-ab6b-2a5ec306f3be
:RECIPE:   [[id:b7b8a9d8-82f8-4080-8f9d-5372dd8b0c75][auto-capitalize]]
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(void-add-hook 'text-mode-hook #'auto-capitalize-mode)
(autoload #'auto-capitalize-mode "auto-capitalize" nil t nil)
(setq auto-capitalize-words '("I" "English"))
#+end_src

*** spell-number
:PROPERTIES:
:ID:       8bf270a6-6003-4430-bb03-0b665d5a162f
:RECIPE:   [[id:0c121a7a-51f9-43f1-a8ba-6fd68570f044][spell-number]]
:END:

#+begin_src emacs-lisp
(setq spelln-language 'english-us)
(setq spelln-country 'united-states)
(setq spelln-period-character ?,)
(setq spelln-decimal-character ?.)
#+end_src

** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:RECIPE:   [[id:9ee02a4c-c3ab-41d9-bee8-77ed1a542121][xr]]
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(autoload #'xr "xr" nil nil nil)
#+end_src

** saving & backups
:PROPERTIES:
:ID:       58228a67-3f7f-4654-8452-81194e75da07
:END:

*** super-save
:PROPERTIES:
:ID:       684e788c-6db9-4e6e-826b-d4871c0a3f90
:RECIPE:   [[id:9af7e3c1-42b8-452d-8390-c0af58745d9c][super-save]]
:END:

The default auto-saving feature in emacs saves after a certain number of
characters are typed (see [[helpvar:auto-save-interval][auto-save-interval]]). The problem is that if you're in
the middle of typing and you've just hit the number of characters that trigger a
save, you could experience a lag, particularly if you are dealing with a large
file being saved. Instead of doing this, [[https://github.com/bbatsov/super-save][super-save]] saves buffers during idle
time and after certain commands like [[helpfn:switch-to-buffer][switch-to-buffer]] (see [[helpvar:super-save-triggers][super-save-triggers]]).
Note that this is the same strategy employed by [[id:c550f82a-9608-47e6-972b-eca460015e3c][idle-require]] to load packages.
Saving files like this reduces the likelihood of user delays.

#+begin_src emacs-lisp
(void-load-before-call 'super-save #'find-file t)

(setq super-save-idle-duration 5)
(setq super-save-auto-save-when-idle t)
#+end_src

** spacing & indentation
:PROPERTIES:
:ID:       ae5416cd-ffa2-456a-9c56-afcfc65a33f8
:END:

*** aggressive-fill-paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:RECIPE:   [[id:49808e7b-c04c-472f-93d1-aecd474bab08][aggressive-fill-paragraph]]
:END:

*** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:RECIPE:   [[id:d9f45bee-5c79-44d6-9f57-5f5ef3dd5aeb][aggressive-indent]]
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(straight-use-package
 '(aggressive-indent :type git :flavor melpa :host github :repo "Malabarba/aggressive-indent-mode"))

(autoload #'aggressive-indent-mode "aggressive-indent" nil t nil)
(void-add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
#+end_src

** parentheses
:PROPERTIES:
:ID:       e82d2b4e-659e-4c7d-8071-c413b8e540f7
:END:

*** smartparens
:PROPERTIES:
:ID:       f4ffbb57-1fb6-43ab-a747-470dfcfbd0ac
:RECIPE:   [[id:ea890ea5-8da1-4295-9bc9-55b4b85c65be][smartparens]]
:END:

**** init
:PROPERTIES:
:ID:       e26f4c55-9585-4544-bed6-9733d50823e7
:END:

#+begin_src emacs-lisp
(autoload #'smartparens-mode "smartparens" nil t nil)
(autoload #'smartparens-strict-mode "smartparens" nil t nil)
(alet '(prog-mode-hook eshell-mode-hook ielm-mode-hook)
  (void-add-hook it #'smartparens-strict-mode))
#+end_src

**** settings
:PROPERTIES:
:ID:       d4c619a8-c3e3-49ae-9e43-8274aeab1ba9
:END:

#+begin_src emacs-lisp
(setq sp-highlight-pair-overlay nil)
(setq sp-highlight-wrap-overlay nil)
(setq sp-highlight-wrap-tag-overlay nil)
(setq sp-show-pair-from-inside t)
(setq sp-cancel-autoskip-on-backward-movement nil)
(setq sp-show-pair-delay 0.1)
(setq sp-max-pair-length 4)
(setq sp-max-prefix-length 50)
(setq sp-escape-quotes-after-insert nil)
#+end_src

**** config
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(after! smartparens
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

**** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(after! smartparens
  (defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
    "Disable smartparents skip match feature."
    (setq sp-navigate-skip-match nil)
    (setq sp-navigate-consider-sgml-tags nil)))
#+end_src

**** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(void-load-before-call 'smartparens (list #'evil-expression #'evil-ex) t)

(after! smartparens
  (defhook! enable-smartparens-maybe (minibuffer-setup-hook)
    "Enable `smartparens-mode' in the minibuffer, during `eval-expression' or
`evil-ex'."
    (when (memq this-command '(eval-expression evil-ex))
      (smartparens-mode 1))))
#+end_src

*** rainbow-delimiters
:PROPERTIES:
:ID:       5b58bb1c-5d3c-4f04-b4fb-c55f1588839e
:RECIPE:   [[id:19563430-e405-4e59-9546-e02ba3327e2b][rainbow-delimiters]]
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(void-add-hook '(prog-mode-hook reb-mode-hook) #'rainbow-delimiters-mode)
(autoload #'rainbow-delimiters-mode "rainbow-delimiters" nil t nil)

(setq rainbow-delimiters-max-face-count 9)
#+end_src

** outshine
:PROPERTIES:
:ID:       6aeccc22-2ebe-43c0-a245-5535b5bd6f6c
:RECIPE:   [[id:1f92a982-3c7d-4c11-8732-937280388c4a][outshine]]
:END:

#+begin_src emacs-lisp
(autoload #'outshine-mode "outshine" nil t nil)
#+end_src

** modal editing
:PROPERTIES:
:ID:       175ad5b9-3f0e-445e-b0ae-da3bce144929
:END:

Modal editing is widely accepted to be more efficient than modeless editing.

*** evil - the "extensible VI layer"
:PROPERTIES:
:ID:       9639633f-ec3d-4499-9615-db0dcc9650c9
:END:

=evil= is the most complete vim emulation in existence.

**** text objects
:PROPERTIES:
:ID: 07366548-2960-49c6-9ab7-cb177b06ad70
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

***** general delimiter text object
:PROPERTIES:
:ID: f551956d-440c-431b-8fb0-8e71c9714f11
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (general-def evil-inner-text-objects-map
    "f" #'evil:textobj-inner-form)
  (general-def evil-outer-text-objects-map
    "f" #'evil:textobj-outer-form))
#+end_src

***** fix vim/evil around =""=
:PROPERTIES:
:ID: b57bf245-3d63-4078-8bcb-2ec0b9952ab9
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (general-def evil-outer-text-objects-map
    "\"" #'evil:textobj-a-string))
#+end_src

**** evil-lion
:PROPERTIES:
:ID:       95d248be-601e-4dbd-b318-febcd0e49d71
:RECIPE:   [[id:d57a4850-81a6-47d4-b409-d4512e0fb78d][evil-lion]]
:END:

=evil-lion= provides a very useful way of aligning text.

#+begin_src emacs-lisp
(--each (list #'evil-lion-right #'evil-lion-left)
  (autoload it "evil-lion" nil t nil))

(general-def 'normal
  :infix "g"
  "l" #'evil-lion-left
  "L" #'evil-lion-right)
#+end_src

**** evil-visualstar
:PROPERTIES:
:ID: 6ebca72d-f90a-4423-9ecd-706f9d426002
:RECIPE:   [[id:a73fe41d-46e5-4641-a07c-01ae06d8f04f][evil-visualstar]]
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(--each (list #'evil-visualstar/begin-search-backward
              #'evil-visualstar/begin-search-forward)
  (autoload it "evil-visualstar" nil t nil))

(define-key! evil-visual-state-map
  "#" #'evil-visualstar/begin-search-backward
  "*" #'evil-visualstar/begin-search-forward)
#+end_src

**** evil-surround
:PROPERTIES:
:ID:       9ab88644-3c33-463c-8f24-3b048209e082
:RECIPE:   [[id:607895bf-3be6-49a8-9743-ad3b4aee7594][evil-surround]]
:END:

#+begin_src emacs-lisp
(autoload #'evil-surround-mode "evil-surround" nil t nil)
(void-add-hook '(prog-mode-hook text-mode-hook) #'evil-surround-mode)
#+end_src

**** evil
:PROPERTIES:
:ID: 3b9aaf0c-a69c-474a-b1a3-f0e748e83558
:RECIPE:   [[id:ba195841-cfdb-48b1-b223-dcf4ef642821][evil]]
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

***** init
:PROPERTIES:
:ID:       af3a9791-76ac-4fd5-96fe-d361cef3b5b3
:END:

#+begin_src emacs-lisp
(autoload #'evil-mode "evil" nil t nil)
(void-add-hook 'window-setup-hook #'evil-mode)
#+end_src

***** custom
:PROPERTIES:
:ID:       f7ece898-25e2-4b2c-94f3-e832a687114c
:END:

#+begin_src emacs-lisp
(custom-set-default 'evil-want-C-u-scroll t)
#+end_src

***** settings
:PROPERTIES:
:ID:       9f184a21-ef04-4b3d-a1b7-88a16eaa7b97
:END:

#+begin_src emacs-lisp
(setq evil-want-C-w-in-emacs-state nil)
(setq evil-want-visual-char-semi-exclusive t)
(setq evil-move-beyond-eol nil)
(setq evil-magic t)
(setq evil-echo-state nil)
(setq evil-indent-convert-tabs t)
(setq evil-ex-search-vim-style-regexp t)
(setq evil-ex-substitute-global t)
(setq evil-ex-visual-char-range t)
(setq evil-insert-skip-empty-lines t)
(setq evil-mode-line-format nil)
(setq evil-respect-visual-line-mode t)
(setq evil-symbol-word-search t)
#+end_src

***** cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

****** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Changing the cursor shape and color depending on the state is a convenient and
asthetically pleasing way of determining which state you're in. Some add some
modeline indicator for this but I find that the cursor suffices.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

****** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:void-after-load-theme-hook][void-after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (void-after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

***** normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

Noctuid pointed out

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default `evil-mode' state."
  (setq evil-normal-state-modes (append evil-emacs-state-modes evil-normal-state-modes))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! replace-motion-with-normal (:around evil-make-overriding-map)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  (-let (((keymap state copy) <args>))
    (funcall <orig-fn> keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! replace-motion-with-normal (:around evil-set-initial-state)
  (-let (((mode state) <args>))
    (funcall <orig-fn> mode (if (eq state 'motion) 'normal state))))

(void-add-advice #'evil-motion-state :override #'evil-normal-state)
#+end_src

***** insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-enter-hook)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

***** escape
:PROPERTIES:
:ID:       e4b9d33d-c64d-47ef-9bff-baa80d1b34b2
:END:

****** silence keyboard quit
:PROPERTIES:
:ID:       33f2010f-df3d-4b2b-8b4b-488cc037c6fc
:END:

#+begin_src emacs-lisp
(void-silence-output #'keyboard-quit)
#+end_src

****** escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a general "quit everything".

#+begin_src emacs-lisp
(general-def :states '(emacs insert) [escape] #'evil-force-normal-state)

(defadvice! exit-everything (:after evil-force-normal-state lispyville-normal-state)
  "Exits out of whatever is happening after escape."
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'void-escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

****** key-chord
:PROPERTIES:
:ID:       8fd1bcdc-c4b3-4fee-b91b-dcdf96167582
:RECIPE:   [[id:ce53a6a1-8386-4b0c-99e4-2f52fca5efbd][key-chord]]
:END:

Sometimes we don't have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press =jk= really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

******* init
:PROPERTIES:
:ID:       6d02f80a-6d77-4a02-911e-98b7f4004048
:END:

#+begin_src emacs-lisp
(autoload #'key-chord-mode "key-chord" nil t nil)

(alet (list #'evil-insert-state #'evil-emacs-state)
  (void-load-before-call 'key-chord it t))
#+end_src

******* be quiet when turning on
:PROPERTIES:
:ID:       1e1cff0d-3a2b-45cf-ab32-30379a86023c
:END:

#+begin_src emacs-lisp
(void-silence-output #'key-chord-mode)
#+end_src

******* keychord bindings
:PROPERTIES:
:ID:       738065e2-d607-4672-b44e-1fff5ed249bc
:END:

#+begin_src emacs-lisp
(general-def :states '(visual insert)
  (general-chord "jk") 'evil-force-normal-state
  (general-chord "kj") 'evil-force-normal-state)
#+end_src

* Languages
:PROPERTIES:
:ID:       fa8dc2fc-96f4-4820-b368-4d61d1db0ee5
:END:

** lisp
:PROPERTIES:
:ID:       2b7db121-f807-4274-9347-70c996d3c6f7
:END:

This headline is for packages and configuration which pertain to editing lisp
code.

*** lispyville
:PROPERTIES:
:ID: 9d22714a-086d-49a1-9f8b-66da3b646110
:RECIPE:   [[id:77727936-a230-431c-862f-1cb2c5d30f64][lispyville]]
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

**** initialize
:PROPERTIES:
:ID:       fad4cb7c-ff1e-485d-99d1-f55384c26402
:END:

#+begin_src emacs-lisp
(autoload #'lispyville-mode "lispyville" nil t nil)
(void-add-hook 'emacs-lisp-mode-hook #'lispyville-mode)
#+end_src

**** remappings
:PROPERTIES:
:ID: 5567b70d-60f2-4161-9a19-d6098f45cd95
:END:

#+begin_src emacs-lisp
(define-key! lipsyville-mode-map
  [remap evil-yank]                 #'lispyville-yank
  [remap evil-delete]               #'lispyville-delete
  [remap evil-change]               #'lispyville-change
  [remap evil-yank-line]            #'lispyville-yank-line
  [remap evil-delete-line]          #'lispyville-delete-line
  [remap evil-change-line]          #'lispyville-change-line
  [remap evil-delete-char]          #'lispyville-delete-char-or-splice
  [remap evil-delete-backward-char] #'lispyville-delete-char-or-splice-backwards
  [remap evil-substitute]           #'lispyville-substitute
  [remap evil-change-whole-line]    #'lispyville-change-whole-line
  [remap evil-join]                 #'lispyville-join)
#+end_src

**** inner text objects
:PROPERTIES:
:ID:       f9f82ebe-5749-452f-ba49-269e60526b04
:END:

#+begin_src emacs-lisp
(define-key! evil-inner-text-objects-map
  "a" #'lispyville-inner-atom
  "l" #'lispyville-inner-list
  "x" #'lispyville-inner-sexp
  "c" #'lispyville-inner-comment
  "s" #'lispyville-inner-string)
#+end_src

**** outer text objects
:PROPERTIES:
:ID:       9dda9a1b-c76f-4537-9554-45ad3c77977a
:END:

#+begin_src emacs-lisp
(define-key! evil-outer-text-objects-map
  "a" #'lispyville-a-atom
  "l" #'lispyville-a-list
  "x" #'lispyville-a-sexp
  "c" #'lispyville-a-comment
  "s" #'lispyville-a-string)
#+end_src

**** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(define-key! 'normal lispyville-mode-map
  ">" #'lispyville-slurp
  "<" #'lispyville-barf)
#+end_src

**** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =void-escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(define-key! '(emacs insert) lispyville-mode-map [escape] #'lispyville-normal-state)
#+end_src

**** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(define-key! '(emacs insert) lispyville-mode-map
  "SPC" #'lispy-space
  ";"   #'lispy-comment)

(define-key! '(normal visual) lispyville-mode-map
  "M-j" #'lispyville-drag-forward
  "M-k" #'lispyville-drag-backward
  "M-R" #'lispyville-raise-list
  "M-v" #'lispy-convolute-sexp)
#+end_src

*** lispy
:PROPERTIES:
:ID:       47f19607-13a7-4857-bb1a-33760f95cb7e
:RECIPE:   [[id:1429bff3-29d6-4a5a-a68a-87494417ff71][lispy]]
:END:

For learning how to use lispy. [[https://github.com/abo-abo/lispy][the README]] and the [[http://oremacs.com/lispy/#lispy-different][lispy function reference]] were
very useful to me.

**** hook
:PROPERTIES:
:ID:       37bd49d1-3e34-4579-87d2-e791278be017
:END:

#+begin_src emacs-lisp
(autoload #'lispy-mode "lispy" nil t nil)
(void-add-hook 'emacs-lisp-mode-hook #'lispy-mode)
#+end_src

**** settings
:PROPERTIES:
:ID:       20d99206-ddc4-42db-b4c1-8721decbaf8d
:END:

#+begin_src emacs-lisp
(setq lispy-avy-style-paren 'at-full)
(setq lispy-eval-display-style 'overlay)
(setq lispy-safe-delete t)
(setq lispy-safe-copy t)
(setq lispy-safe-paste t)
(setq lispy-safe-actions-no-pull-delimiters-into-comments t)
(setq lispy-delete-sexp-from-within t)
(setq lispy-parens-only-left-in-string-or-comment nil)
(setq lispy-safe-threshold 5000)
(setq lispy-use-sly t)
;; allow space before asterisk for headings (e.g. ";; *")
(setq lispy-outline "^;;\\(?:;[^#]\\|[[:space:]]*\\*+\\)")
(setq lispy-key-theme nil)
#+end_src

**** enter lispy state via =H= and =L=
:PROPERTIES:
:ID:       55955252-d35f-493f-bb2c-73a2363ca1c6
:END:

#+begin_src emacs-lisp
(define-key! 'normal evil-lispy-mode-map
  "H" #'evil-lispy/enter-state-left
  "L" #'evil-lispy/enter-state-right)
#+end_src

**** key-theme
:PROPERTIES:
:ID:       8977fd1e-5603-4acc-b3d7-c767f6b913fe
:END:

Key themes are keybinding themes used for.

#+begin_src emacs-lisp
(after! lispy (lispy-set-key-theme '(special)))
#+end_src

**** eros
:PROPERTIES:
:ID:       265b3b87-012e-452e-aa1f-c7c8e3308a73
:RECIPE:   [[id:07e8fbb3-6bc0-411f-9e3c-f29faeb2cc01][eros]]
:END:

**** avoid void variable error
:PROPERTIES:
:ID:       a73ff9be-1a3d-4007-ad40-5a34c38767f6
:END:

You'll get void variable if you don't do this.

#+begin_src emacs-lisp
(after! (avy lispy) (setq lispy-avy-keys avy-keys))
#+end_src

*** evil-lispy
:PROPERTIES:
:ID:       f79c2035-ce79-491a-acf6-5e80f72cffe9
:RECIPE:   [[id:6fe1548d-b170-4881-a191-0a79daf27e17][evil-lispy]]
:END:

**** lispy state cursor
:PROPERTIES:
:ID:       c44cf8dc-e80c-4be6-9c11-221b446cc87b
:END:

#+begin_src emacs-lisp
(gsetq evil-lispy-state-cursor  '((bar . 4) "red"))
#+end_src

**** run after lispy
:PROPERTIES:
:ID:       18173a29-7442-473e-a851-f46182f56447
:END:

#+begin_src emacs-lisp
(autoload #'evil-lispy-mode "evil-lispy" nil t nil)
(void-add-hook 'lispy-mode-hook #'evil-lispy-mode)
#+end_src

*** highlight-quoted
:PROPERTIES:
:ID:       d0973dce-693b-45ca-88e3-27da1bb217f7
:RECIPE:   [[id:ac621121-93b1-4769-b290-624a5bc10908][highlight-quoted]]
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(autoload #'highlight-quoted-mode "highlight-quoted" nil t nil)
(void-add-hook 'emacs-lisp-mode-hook #'highlight-quoted-mode)
#+end_src

*** fix elisp indentation
:PROPERTIES:
:ID: aa7f846f-8802-4c75-88d8-a438e2f63ccd
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! properly-calculate-indent (:override calculate-lisp-indent)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp <parse-start>) (integerp <parse-start>))
             (goto-char <parse-start>))
            ((null <parse-start>) (beginning-of-defun))
            (t (setq state <parse-start>)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

*** macrostep
:PROPERTIES:
:ID:       fefc5700-3bd7-4a89-ae7b-bf68368e8bc4
:RECIPE:   [[id:4f558137-7212-4d50-a6b5-e47630537545][macrostep]]
:END:

#+begin_src emacs-lisp
(--each (list #'macrostep-expand #'macrostep-collapse #'macrostep-collapse-all)
  (autoload it "macrostep" nil t nil))

(define-localleader-key!
  :infix "m"
  :keymaps 'emacs-lisp-mode-map
  "e" (list :def #'macrostep-expand :wk "expand")
  "c" (list :def #'macrostep-collapse :wk "collapse")
  "C" (list :def #'macrostep-collapse-all :wk "collapse all"))
#+end_src

*** ppp
:PROPERTIES:
:ID:       82dbb88a-4bce-4ca3-90fe-38cfbea7abc6
:RECIPE:   [[id:96d0d851-439f-4e6d-9c79-661663f4656b][ppp]]
:END:

This is a pretty printer.

Sometimes you want to see what an object looks like represented as text so you
know what you're dealing with. For example, I've wanted to see what a straight
recipe looks like. The problem is by default [[][]] prints something on one
line. And to avoid long lines, emacs truncates the output so you can't even see
the whole thing.

*** elisp snippets
:PROPERTIES:
:ID:       bbb2299f-6960-43c2-bf1d-b849ef8ecff0
:END:

**** define a variable
:PROPERTIES:
:ID:       38ecee81-18e8-482e-ae91-280bdcaf096e
:END:

#+begin_src emacs-lisp
(defvar void-elisp-tempo-tags nil
  "Variable containing elisp tempo tags.")
#+end_src

**** defvar
:PROPERTIES:
:ID:       bbbba4d9-a2f4-47b1-8447-082f8ea4cf86
:END:

#+begin_src emacs-lisp
(defsnippet! defvar ("dvar")
  "Insert a defvar expression."
  '("(defvar " (p "var" varname) " " (p "initial-value" value)
    n> "\"" (p "docstring" docstring) "\"" ")"))
#+end_src

**** defun
:PROPERTIES:
:ID:       3fdb199e-b76e-41ea-85fb-4f62c398453d
:END:

#+begin_src emacs-lisp
(defsnippet! defun ("defn")
  "Insert a defun form"
  '(> "(defun " (p "name" name) " " "(" (p "args" it) ")"
    n> "\"" (p "docstring" docstring) "\""
    n> (p "body" body)
    ")" (p "")))
#+end_src

**** when
:PROPERTIES:
:ID:       8eb34ddf-ae81-42dd-bf7a-4be9562ceae5
:END:

#+begin_src emacs-lisp
(defsnippet! when ("when")
  "Insert a when expression"
  '("(when " (p "condition" condition) n> (r "body" body) ")" (p "" last)))
#+end_src

**** cond
:PROPERTIES:
:ID:       cd622b5f-92f5-48a0-9f54-b2526b079c49
:END:

#+begin_src emacs-lisp
(defsnippet! cond ("cond")
  '("(cond (("   ")"))
#+end_src

** org
:PROPERTIES:
:ID:       63748940-c1b9-47ea-b1ce-d6519453ad03
:RECIPE:   [[id:27ccfc0f-57b9-42ea-acf6-d103af7619bc][org]]
:END:

*** init
:PROPERTIES:
:ID:       6d08d180-5b96-4f1f-98f9-53086c13561a
:END:

**** directories
:PROPERTIES:
:ID:       42e759b0-c676-4b87-ac84-20796500da5a
:END:

#+begin_src emacs-lisp
(setq org-directory (concat user-emacs-directory "org/"))
(setq org-archive-location (concat org-directory "archive.org::"))
(setq org-default-notes-file (concat org-directory "notes.org"))
#+end_src

**** define capture file
:PROPERTIES:
:ID:       97a3bb5a-f485-45d0-a7f4-4bdd3963a16b
:END:

#+begin_src emacs-lisp
(defvar org:capture-file (concat org-directory "capture.org"))
#+end_src

**** general settings
:PROPERTIES:
:ID:       b0aa3f0b-876a-4527-b8ba-4fdac5e7ebe8
:END:

#+begin_src emacs-lisp
(setq org-fontify-emphasized-text t)
(setq org-hide-emphasis-markers t)
(setq org-pretty-entities t)
(setq org-fontify-whole-heading-line t)
(setq org-fontify-done-headline t)
(setq org-fontify-quote-and-verse-blocks t)
(setq org-adapt-indentation nil)
(setq org-cycle-separator-lines 2)
(setq outline-blank-line t)
(setq org-enforce-todo-dependencies t)
(setq org-use-fast-tag-selection nil)
(setq org-tags-column -80)
(setq org-tag-alist nil)
(setq org-log-done 'time)
#+end_src

**** required packages
:PROPERTIES:
:ID:       939d4fd6-85df-4ba2-8a67-23343d484bf9
:END:

#+begin_src emacs-lisp
(alet '(calendar find-func format-spec org-macs org-compat org-faces org-entities
        org-list org-pcomplete org-src org-footnote org-macro ob org org-agenda
	    org-capture)
  (-each it #'idle-require))
#+end_src

*** customization
:PROPERTIES:
:ID:       3f0570f0-436b-4a53-92c4-52b06ae26a15
:END:

**** bindings
:PROPERTIES:
:ID:       4ca3fe54-54b1-47ca-90f1-a14b3df1cc59
:END:

Org mode demands its own editing.

***** navigation
:PROPERTIES:
:ID:       25a91495-073d-4557-8407-49ea63f13383
:END:

#+begin_src emacs-lisp
(define-key! 'normal org-mode-map
  "j" #'org/dwim-next-line
  "k" #'org/dwim-previous-line)
#+end_src

***** org mode local bindings
:PROPERTIES:
:ID:       a950d732-b0d2-46b9-82ce-1b9a474e7d76
:END:

#+begin_src emacs-lisp
(define-localleader-key!
  :keymaps 'org-mode-map
  "o" (list :def #'outorg-edit-as-org         :wk "edit as org")
  "w" (list :def #'widen                      :wk "widen")
  "n" (list :def #'org-narrow-to-subtree      :wk "narrow")
  "k" (list :def #'org-cut-subtree            :wk "cut subtree")
  "c" (list :def #'org-copy-subtree           :wk "copy subtree")
  "r" (list :def #'org-refile                 :wk "refile")
  "j" (list :def #'org/avy-goto-headline      :wk "jump to headline")
  "E" (list :def #'org-babel-execute-subtree  :wk "execute subtree")
  "d" (list :def #'org/dwim-edit-description  :wk "edit description")
  "e" (list :def #'org/dwim-edit-source-block :wk "edit source block")
  "," (list :def #'org/dwim-edit-source-block :wk "edit source block"))
#+end_src

***** generic org bindings
:PROPERTIES:
:ID:       583bd7ac-64e0-48ea-bd75-5b6a20f2deae
:END:

Org mode just does not lend itself to typical evil bindings. These bindings are
much more useful considering the specific structure of org mode documents.

#+begin_src emacs-lisp
(general-def 'normal org-mode-map
  "E" #'org/dwim-eval-block
  "e" #'org/dwim-eval-block
  "b" #'org/dwim-insert-elisp-block
  "o" #'org/insert-heading-below
  "O" #'org/insert-heading-above
  "h" #'org-up-heading-safe
  "l" #'org-do-demote
  "H" #'org-promote-subtree
  "S" #'org-demote-subtree
  ">" #'org-shiftmetaright
  "<" #'org-shiftmetaleft
  "t" #'org-set-tags-command
  "r" #'org/choose-capture-template
  "s" #'org/dwim-edit-source-block
  "R" #'org-refile
  "T" #'org-todo
  "D" #'org-cut-subtree
  "Y" #'org-copy-subtree
  "K" #'org-metaup
  "J" #'org-metadown)
#+end_src

***** bindings
:PROPERTIES:
:ID:       3f4144ee-a780-478e-a1ad-47591f181ff3
:END:

#+begin_src emacs-lisp
(define-key! '(normal) org-mode-map
  ;; Doesn't work for some reason -> "TAB" #'outline-toggle-children
  "D" #'org-cut-subtree
  "P" #'org-paste-subtree)

(define-key! [remap org-cycle] #'outline-toggle-children)
#+end_src

**** custom commands
:PROPERTIES:
:ID:       4dfeccc9-f12e-4449-a5fe-17541070b40e
:END:

***** goto start of heading
:PROPERTIES:
:ID:       0431e49f-ef6b-4edb-854c-6427479e5ee2
:END:

#+begin_src emacs-lisp
(defun org:heading-goto-start ()
  "Go to the end of headline."
  (save-match-data
    (beginning-of-line)
    (when (looking-at (rx (1+ "*")))
      (goto-char (1- (match-end 0))))))
#+end_src

***** do the right thing after jumping to headline
:PROPERTIES:
:ID:       2ca61454-a0ca-47b3-8622-91d7969653da
:END:

When I search for a headline with [[helpfn:void/goto-line][void/goto-line]] or [[helpfn:void/goto-headline][void/goto-headline]] or even their
counsel equivalents, the proper headlines aren't automatically revealed.

[[screenshot:][This]] is what headline structure looks after using counsel/ivy's [[helpfn:swiper][swiper]] to find
the word =void/goto-line= in my emacs. You can see that only the headline that has
the target word is revealed but it's parents are (akwardly) hidden. I never want
headlines to be unfolded like this.

****** show branch
:PROPERTIES:
:ID:       d95fab52-7d8f-439f-9221-188490f4ad5f
:END:

This shows all headlines that make up the branch of the current headine and
their children. This is the typical behavior you would expect in any outlining
program.

#+begin_src emacs-lisp
(defun org:show-branch ()
  "Reveal the current org branch.
Show all of the current headine's parents and their children. This includes this
headline."
  (loopy (before-do (org-back-to-heading t))
         ((org-up-heading-safe)
          (collect points (point)))
         (finally-do
          (--each-r points
            (goto-char it)
            (outline-show-children)
            (outline-show-entry)))))
#+end_src

****** show branch after jumping to point
:PROPERTIES:
:ID:       251e5df0-0a7d-4bf9-8fd9-69991d89a074
:END:

Note that I use points to store the heading points and go back to them inreverse
order. This is important because org does not unfold headlines properly if you
start from an invisible subheading.

Notably, I do not try to conserve the return value of =void/goto-line= or
=void/jump-to-headline= because these functions are and should only be used for
their side-effects.

#+begin_src emacs-lisp
(defadvice! show-current-branch-in-org-mode (:after void/goto-line org/goto-headline)
  "Properly unfold nearby headlines and reveal current headline."
  (when (eq major-mode 'org-mode)
    (org:show-branch)))
#+end_src

***** return
:PROPERTIES:
:ID:       8314f2e0-da63-4f2f-ad89-b97987ca5843
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond ((org-at-heading-p)
         (org/insert-heading-below))
        (t
         (call-interactively #'org-return))))
#+end_src

****** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

***** navigation
:PROPERTIES:
:ID:       3d9ea885-e679-46e5-9541-dea0436d05ec
:END:

****** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

****** previous-line
:PROPERTIES:
:ID: e7562921-77ca-4d90-be57-1d586ec26ee5
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

***** inserting
:PROPERTIES:
:ID: e99abeff-328b-48e4-aebb-00db34fa98e8
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

****** newlines between headings
:PROPERTIES:
:ID: e0dcf718-120c-488d-9d37-96243132bf0b
:END:

#+begin_src emacs-lisp
(defvar org:newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

****** heading above
:PROPERTIES:
:ID: 6c227dea-e10b-4f86-a01b-5d223d18e3a4
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

****** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org:newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

****** subheading
:PROPERTIES:
:ID: cf910dcf-6250-4b6a-80d5-63ac457d4a81
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

****** elisp block
:PROPERTIES:
:ID:       e03149e3-500f-45d6-a4c1-b2f69947b4d5
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

***** org choose tags
:PROPERTIES:
:ID:       b8b0c3a2-2cdc-424f-9cd6-ef3ad3d1512c
:END:

#+begin_src emacs-lisp
(defun org/choose-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (->> (org-get-buffer-tags)
                        (completing-read-multiple "Select org tag(s): "))))
    (alet (-distinct (append (-difference current selected)
                             (-difference selected current)))
      (org-set-tags it))))
#+end_src

***** eval
:PROPERTIES:
:ID: e804805a-ba96-41d0-aa6f-6756c65e9abf
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

*** links
:PROPERTIES:
:ID:       f70f36ae-1ef1-4dce-ad84-e4a8430f40a5
:END:

**** org-super-links
:PROPERTIES:
:ID:       f3eed884-408f-44cb-becc-17c1431060c5
:END:

***** settings
:PROPERTIES:
:ID:       c7a7e21c-88b9-485e-9ae3-874d324981b5
:END:

#+begin_src emacs-lisp
(setq sl-backlink-prefix nil)
(setq sl-related-into-drawer "LINKS")
(setq sl-backlink-into-drawer "BACKLINKS")
#+end_src

**** org-link-minor-mode
:PROPERTIES:
:ID:       25b93a1f-b105-47aa-9647-5015d23a4ac3
:RECIPE:   [[id:ee595fa2-da02-4cb8-a5ab-a003cd214598][org-link-minor-mode]]
:END:

This is a minor mode for displaying links in non-org buffers.

#+begin_src emacs-lisp
(autoload #'org-link-minor-mode "org-link-minor-mode" nil t nil)
(void-add-hook 'outshine-mode-hook #'org-link-minor-mode)
#+end_src

*** org-ml
:PROPERTIES:
:ID:       7f3ec0ad-45f8-4100-970e-773cfb9a625b
:RECIPE:   [[id:309aef25-feab-4bf6-a617-d932a482d6a8][org-ml]]
:END:

*** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:RECIPE:   [[id:2c54b607-1ba0-49a8-8d9c-fa55694db489][org-journal]]
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(autoload #'org-journal-new-entry "org-journal" nil t nil)

(after! org-journal
  (setq org-journal-file-type 'yearly)
  (setq org-journal-dir (concat org-directory "journal/"))
  (setq org-journal-find-file 'find-file))
#+end_src

*** org-src
:PROPERTIES:
:ID:       e00378a1-adcf-4e83-8533-b6b442b5f362
:END:

**** control org src popup
:PROPERTIES:
:ID:       f0f6ad72-b7bc-4894-86fe-32851698c319
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "org source" :newfile (rx "*Org Src"))
#+end_src

**** settings
:PROPERTIES:
:ID:       0f51ce73-d54e-4e89-8977-56c769940c5f
:END:

#+begin_src emacs-lisp
(setq org-edit-src-persistent-message nil)
(setq org-src-fontify-natively t)
(setq org-src-ask-before-returning-to-edit-buffer nil)
(setq org-src-preserve-indentation t)
(setq org-src-tab-acts-natively t)
(setq org-confirm-babel-evaluate nil)

(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "silent")
        (:exports . "code")
        (:cache . "no")
        (:initeb . "no")
        (:hlines . "no")
        (:tangle . "yes")))
#+end_src

**** bindings in source block
:PROPERTIES:
:ID:       df270638-f6a7-4f0e-abe7-dd0c4e7df7ce
:END:

Note that you should have bindings that are different for entering and exiting
source blocks.

#+begin_src emacs-lisp
(defhook! enable-org-exit-src-bindings (org-src-mode-hook)
  (define-localleader-key!
    "," (list :def #'org-edit-src-exit  :wk "exit source block")
    "a" (list :def #'org-edit-src-abort :wk "abort source block")
    "c" (list :def #'org-edit-src-exit  :wk "exit source block")))
#+end_src

*** org-capture
:PROPERTIES:
:ID:       3225bbc4-9685-4e7b-ae32-41a26780d191
:END:

=org-capture= is a feature that allows you to quickly save a thought that popped
into your head while keeing disctractions to a minimum.

**** init
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

#+begin_src emacs-lisp
(autoload #'org-capture "org-capture" nil t nil)
(dbc-add-rule "bottom" "capture" :newname "\\`CAPTURE-")

;; Make sure dependencies for `org-capture' are pulled.
;; (-each '(ts org-ml) (-partial #'void-load-before-call #'org-capture))
(--each '(ts org-ml)
  (void-load-before-call it #'org-capture))
#+end_src

**** remove capture headerline
:PROPERTIES:
:ID: 7b8a8e1d-3c72-492f-9311-56a2428a1f1d
:END:

By default org capture templates display a header line. This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my
question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  (setq-local header-line-format nil))
#+end_src

**** prevent capture templates from deleting windows
:PROPERTIES:
:ID:       a13e330a-33ff-4c1e-add4-00c5db4e6cd1
:END:

=org-capture= deletes all the other windows in the frame.

#+begin_src emacs-lisp
(defadvice! dont-delete-other-windows (:around org-capture-place-template)
  "Don't delete other windows when opening a capture template."
  (cl-letf (((symbol-function #'delete-other-windows) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

**** completing-read org-capture
:PROPERTIES:
:ID:       ad2cc056-edda-490a-8cf9-10b370a21dc0
:END:

Org provides it's own default interface for capturing. To be consistent with how
we complete everything else--via [[helpfn:][completing-read]], I create a function which
let's me choose the template via completing-read.

***** capture templates
:PROPERTIES:
:ID:       c4fdb186-3509-42f1-9c3e-8bf80a5e6b47
:END:

#+begin_src emacs-lisp
(defun org-capture:template-list ()
  "Return a list of capture templates."
  (thread-first org-capture-templates
    (org-capture-upgrade-templates)
    (org-contextualize-keys org-capture-templates-contexts)))
#+end_src

***** replacement for =org-capture=
:PROPERTIES:
:ID:       4dd55ff4-7e6e-41f5-82f8-0db597959a17
:END:

#+begin_src emacs-lisp
(defun org-capture/choose-template ()
  "Choose a capture template."
  (interactive)
  (let* ((read-string (seq-map (lambda (it) (format "%s %s" (car it) (cadr it)))
                               (org-capture:template-list)))
         (selection (completing-read "Capture template: " read-string nil :require-match))
         (key (car (split-string selection "\s" t))))
    (org-capture nil key)))
#+end_src

**** doct
:PROPERTIES:
:ID:       fa37f618-b58c-449b-a216-9d2f80ed12c6
:RECIPE:   [[id:6f3e1ca1-8828-455f-a012-7b35f657d53e][doct]]
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[helpfn:doct][doct docstring]]).
In org mode, capture templates are [[info:org#Capture templates][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

***** init
:PROPERTIES:
:ID:       0118ba87-219b-4611-9743-19228accaa2c
:END:

#+begin_src emacs-lisp
(void-load-before-call 'doct #'org-capture)
#+end_src

***** add to capture templates
:PROPERTIES:
:ID:       16c55272-f8c2-4798-9da1-2ab492769f44
:END:

[[helpfn:doct][doct]] returns the new value of capture templates. but it does not actually add
it. For convenience this function declare it and add it in all in one go.
Additionally, it removes any capture templates with the same key so that I can
freely re-evaluate it without cluttering my capture templates with duplicate
entries.

#+begin_src emacs-lisp
(defun doct:add-to-templates (declarations)
  "Set `org-capture-templates' to the result of (doct DECLARATIONS).
Before adding result, remove any members of `org-capture-templates' with the
same key as the one(s) being added."
  (cl-labels ((clean (templates)
                     (when templates
                       (cons (car templates)
                             (--remove (string= (caar templates) (car it))
                                       (clean (cdr templates)))))))
    (setq org-capture-templates
          (clean (-concat (doct declarations) org-capture-templates)))))
#+end_src

**** helpers
:PROPERTIES:
:ID:       0d333a6e-b6bc-437e-9bc1-3c11846c37f1
:END:

***** schedule and deadline times
:PROPERTIES:
:ID:       e5c8996f-0d93-4a76-9b30-baf40f70d74d
:END:

For capture templates that have deadlines, I set a start and an end date.

#+begin_src emacs-lisp
(defun org-capture::default-planning-node (&optional days-difference)
  "Return the default planning node for `org-capture-templates'."
  (let* ((days-difference (or days-difference 7))
         (now (ts-now))
         (later (ts-adjust 'day days-difference now))
         (beg (list (ts-year now) (ts-month now) (ts-day now)))
         (end (list (ts-year later) (ts-month later) (ts-day later)))
         (days-difference (or days-difference 7)))
    (org-ml-build-planning! :scheduled beg :deadline end)))
#+end_src

**** capture templates
:PROPERTIES:
:ID:       a2a3f682-322a-450f-91bf-169d90f040c0
:END:

***** emacs
:PROPERTIES:
:ID:       ef103d28-b746-42ba-ac1a-0462a19f03cd
:END:

This is a capture template for emacs usage.

****** emacs capture template string
:PROPERTIES:
:ID:       a58f1de7-2049-4195-abfb-daad93a6ff2a
:END:

Instead of passing in the string I use =org-ml= to print the string.

#+begin_src emacs-lisp
(defun doct:emacs-template-string ()
  "Return emacs capture template."
  (->> (org-ml-build-headline! :title-text "%?")
       (org-ml-headline-set-node-property "ID" (org-id-new))
       (org-ml-headline-set-node-property "CREATED" (ts-format))
       (org-ml-set-property :todo-keyword "TODO")
       (org-ml-set-property :tags '("emacs"))
       (org-ml-to-trimmed-string)))
#+end_src

****** emacs
:PROPERTIES:
:ID:       2682910c-9620-4cbf-ab71-371ed29e25a1
:END:

#+begin_src emacs-lisp
(after! org-capture
  (require 'doct)
  (doct:add-to-templates
   (list "emacs"
	 :keys "e"
	 :template #'doct:emacs-template-string
	 :file org:capture-file
	 :prepend t
	 :empty-lines 1)))
#+end_src

*** org-clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(--each (list #'org-clock-in #'org-clock-goto)
  (autoload it "org-clock" nil t nil))

(setq org-clock-persist 'history)
(setq org-clock-persist-file (concat VOID-DATA-DIR "org-clock-save.el"))
(setq org-clock-in-resume t)

(after! org-clock
  (void-add-hook 'kill-emacs-hook #'org-clock-save)
  (org-clock-persistence-insinuate))
#+end_src

*** org-agenda
:PROPERTIES:
:ID:       efa9d237-b055-4bfb-a1f9-86d964b5f007
:END:

**** settings
:PROPERTIES:
:ID:       168100e3-7157-411a-ad46-6389d1d0242a
:END:

#+begin_src emacs-lisp
(setq org-agenda-files (list org:capture-file))
(setq org-agenda-start-on-weekday 0)
(setq org-agenda-timegrid-use-ampm nil)
(setq org-agenda-skip-unavailable-files t)
(setq org-agenda-time-leading-zero t)
(setq org-agenda-text-search-extra-files '(agenda-archives))
(setq org-agenda-dim-blocked-tasks t)
(setq org-agenda-inhibit-startup t)
#+end_src

*** org-refile
:PROPERTIES:
:ID:       6dfc0415-2945-4259-a782-b569fcb397ea
:END:

**** org refile
:PROPERTIES:
:ID: 0174a708-8043-403e-b024-8ae29868564d
:END:

#+begin_src emacs-lisp
(setq org-refile-targets nil)
(setq org-refile-use-outline-path 'file)
(setq org-refile-allow-creating-parent-nodes t)
(setq org-reverse-note-order t)
(setq org-outline-path-complete-in-steps nil)
#+end_src

*** org-id
:PROPERTIES:
:ID:       95f2a096-2cf4-4634-aa32-13f00b31ea19
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

**** where ids are stored
:PROPERTIES:
:ID:       3be3c65d-ce48-4b93-a1e7-84f3e547dc69
:END:

#+begin_src emacs-lisp
(setq org-id-locations-file (concat VOID-DATA-DIR "org-id-locations"))
(setq org-id-locations-file-relative t)
#+end_src

**** where to look for ids
:PROPERTIES:
:ID:       41c0db80-94ad-4a99-b27d-7e043c0d7c1f
:END:

For org links to work they need to know where to search for these files.

#+begin_src emacs-lisp
(setq org-id-files (list VOID-MAIN-ORG-FILE VOID-RECIPE-FILE))
#+end_src

**** when creating a link use an org id instead
:PROPERTIES:
:ID:       c10e5674-1fee-4715-975c-36ccb021fcc9
:END:

This setting tells org-mode to use heading IDs when storing and inserting links.

#+begin_src emacs-lisp
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
#+end_src

**** automatically add an id when we create a headline
:PROPERTIES:
:ID: e7ecff83-7ba6-4620-ac05-ebac2f250b7a
:END:

#+begin_src emacs-lisp
(void-add-hook 'org-insert-heading-hook #'org-id-get-create)
#+end_src

*** org-superstar
:PROPERTIES:
:ID:       c4428756-a804-47e8-9586-f63b82dd1561
:RECIPE:   [[id:a6ccef06-5001-4c86-bab4-3cd22db1645c][org-superstar]]
:END:

**** init
:PROPERTIES:
:ID:       67e4a3c7-b1bb-4f8c-991f-53dc304e8450
:END:

#+begin_src emacs-lisp
(void-add-hook 'org-mode-hook #'org-superstar-mode)
(autoload #'org-superstar-mode "org-superstar" nil t nil)
#+end_src

**** remove leading bullets
:PROPERTIES:
:ID:       840ed952-e5ab-4092-ba71-ff1637500afc
:END:

This variable specifies the.

#+begin_src emacs-lisp
(setq org-superstar-leading-bullet ?\s)
#+end_src

**** settings
:PROPERTIES:
:ID: c43700f5-ff24-46b2-aed5-a12f8d8bb347
:END:

[[package:org-superstar][org-superstar]] is a an =org-bullets= remake redesigned from the ground up.

#+begin_src emacs-lisp
(setq org-superstar-special-todo-items t)
#+end_src

*** snippets
:PROPERTIES:
:ID:       cd25f425-a4db-4a4c-be9e-4b672116048c
:END:

**** helpvar
:PROPERTIES:
:ID:       cc0ae97d-4cce-42de-bea0-7e195bd6168b
:END:

#+begin_src emacs-lisp
(defsnippet! helpvar ("hvar")
  "Help function link."
  '("[[helpvar:" (p "var" var) "][" (s function) "]"))
#+end_src

**** helpfn
:PROPERTIES:
:ID:       7bd2651e-e3f8-4e76-822c-2208b71af0c3
:END:

#+begin_src emacs-lisp
(defsnippet! helpfn ("hfn")
  "Help function link."
  '("[[helpfn:" (p "function" function) "][" (s function) "]"))
#+end_src

* Asthetic
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** text scaling
:PROPERTIES:
:ID:       5d242d0e-eeab-46de-bcee-ecfd79b2bffc
:END:

I change the text scale frequently because in some cases, such as viewing my
main org file, I want a birds-eye view where I can see the structure of a
document at a glance. However, when I'm doing something like editing a source
block I want to focus on a very specific thing totally; therefore, I want the
text to take up most of the screen.

*** zoom-frm
:PROPERTIES:
:ID:       15b8577e-3f98-420a-81a5-c7b91292aca3
:RECIPE:   [[id:38a0f1df-106c-43ea-a860-184c9c786718][zoom-frm]]
:END:

This package increases or decreases the font of the current frame. It differs
from [[helpfn:text-scale-increase][text-scale-increase]] and [[helpfn:text-scale-decrease][text-scale-decrease]] in that it applies this
"zooming" to the whole frame instead of the current buffer.

#+begin_src emacs-lisp
(setq frame-zoom-font-difference 0.5)
(setq zoom-frame/buffer 'buffer)
(--each (list #'zoom-out #'zoom-in #'toggle-zoom-frame)
  (autoload it "zoom-frm" nil t nil))
#+end_src

** mini-modeline
:PROPERTIES:
:ID:       51768ba1-170f-497b-9479-541e7c6aadd6
:RECIPE:   [[id:4fba2478-f146-4f75-9d73-a4209b9c16fd][mini-modeline]]
:END:

*** setup
:PROPERTIES:
:ID:       d9acb47b-089f-4b18-8fdd-94ffefb2ef86
:END:

These variables do stuff with displaying lines and separators to make the
modeline more visible. I do that myself with =window-divider= so I don't need
this.

#+begin_src emacs-lisp
(setq mini-modeline-enhance-visual nil)
(setq mini-modeline-display-gui-line nil)

(require 'mini-modeline)
(void-add-hook 'emacs-startup-hook #'mini-modeline-mode)
#+end_src

*** default face
:PROPERTIES:
:ID:       1aab03cd-83b2-4d3a-bf3b-71f52dc6158d
:END:

If you don't set this, mini-modeline's background color won't
update with the theme. This is probably what the default value of this
variable should be anyway.

#+begin_src emacs-lisp
(setq mini-modeline-face-attr '(:inherit default))
#+end_src

*** set the modeline display
:PROPERTIES:
:ID:       37f062a8-b9d9-4533-ba8e-d675a1d5f10a
:END:

#+begin_src emacs-lisp
(defun mini-modeline:display-current-workgroup ()
  "Return the name of the current workgroup."
  (awhen (and (featurep 'workgroups2)
	      (wg-workgroup-name (wg-current-workgroup)))
    it))

(setq mini-modeline-r-format
      '("%e"
	(:eval (awhen (mini-modeline:display-current-workgroup)
		(concat it " ")))
	(:eval (format-time-string "%a %m/%d %T"))))

(setq mini-modeline-l-format
      '("%e" mode-line-buffer-identification))
#+end_src

*** dont redisplay
:PROPERTIES:
:ID:       b3afd056-7b0a-485f-8691-5cc7e4765ca1
:END:

Enabling =mini-modeline-mode= triggers a call to [[helpfn:redisplay][redisplay]]. During startup, this
takes a long time and makes emacs unresponsive for a few seconds. This redisplay
does not seem to be needed (feebleline doesn't do it and it works fine).

#+begin_src emacs-lisp
(defadvice! dont-redisplay (:around mini-modeline-mode)
  (cl-letf (((symbol-function #'redisplay) #'ignore))
    (apply <orig-fn> <args>)))
#+end_src

** info
:PROPERTIES:
:ID:       d49f83c4-ba8f-477e-beef-8156ed8b974b
:END:

This headline is for customizing info nodes.

*** popup rule
:PROPERTIES:
:ID:       a7215e72-ef0e-4910-a2b4-405348c21c24
:END:

#+begin_src emacs-lisp
(dbc-add-rule "top" "info" :newname (rx "*info"))
#+end_src

** helpful
:PROPERTIES:
:ID:       5340ddb3-92bc-42e5-bf0e-9f9650c41cd9
:RECIPE:   [[id:e2df3435-7e56-4070-8703-7ee12e96270e][helpful]]
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in
Emacs help facility which provides much more contextual information
in a better format.

*** init
:PROPERTIES:
:ID:       ff7b784e-3510-4f6c-9770-30f7dcf5e1c8
:END:

#+begin_src emacs-lisp
(--each (list #'helpful-callable #'helpful-command
	          #'helpful-variable #'helpful-key)
  (autoload it "helpful" nil t nil))

(general-def
  [remap describe-function] #'helpful-callable
  [remap describe-command]  #'helpful-command
  [remap describe-variable] #'helpful-variable
  [remap describe-key]      #'helpful-key)
#+end_src

*** popup rule
:PROPERTIES:
:ID: 25270809-b64e-4b9a-b0c2-95ffd047280c
:END:

#+begin_src emacs-lisp
(dbc-add-rule "bottom" "help" :newname "\\*help.+")
#+end_src

** which-key
:PROPERTIES:
:ID:       2ad092a3-ff63-49cd-91b9-380c91dbe9f5
:RECIPE:   [[id:eb37400a-a7fd-4366-8d9a-816ab75f190d][which-key]]
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them ([[][]] and [[][]] are screenshots of this in action). By doing this
you can "discover" the commands as you go along.

*** init
:PROPERTIES:
:ID:       c4aedc23-0be3-46fe-b046-32b5f0738c6b
:END:

**** hooks
:PROPERTIES:
:ID:       e6626cde-d243-4aac-a61c-2897e43b7e73
:END:

#+begin_src emacs-lisp
(void-add-hook 'emacs-startup-hook #'which-key-mode)
(autoload #'which-key-mode "which-key" nil t nil)
#+end_src

**** settings
:PROPERTIES:
:ID:       a4b5878c-1b3f-4d85-9403-7ed8cc52433f
:END:

#+begin_src emacs-lisp
(setq which-key-sort-uppercase-first nil)
(setq which-key-max-display-columns nil)
(setq which-key-add-column-padding 1)
(setq which-key-min-display-lines 6)
(setq which-key-side-window-slot -10)
(setq which-key-sort-order #'which-key-prefix-then-key-order)
(setq which-key-popup-type 'minibuffer)
(setq which-key-idle-delay 0.8)
#+end_src

*** set line spacing
:PROPERTIES:
:ID:       6abb35f4-c648-4bed-b59a-5a0636857fd8
:END:

#+begin_src emacs-lisp
(defhook! set-line-spacing (which-key-init-buffer-hook)
  (setq line-spacing 3))
#+end_src

*** leader keys
:PROPERTIES:
:ID:       1df41291-32c3-44ca-89a9-f042fb2bbd6c
:END:

#+begin_src emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements VOID-LEADER-KEY "<leader>")
  (which-key-add-key-based-replacements VOID-LOCALLEADER-KEY "<localleader>"))
#+end_src

** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:RECIPE:   [[id:d3035f59-65ca-4a68-bb1d-ea28b630d0fc][dashboard]]
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

*** init
:PROPERTIES:
:ID:       de94c9a8-fc05-46ec-ac06-510f1014e02d
:END:

**** require
:PROPERTIES:
:ID:       73d00f99-4b70-44d1-8359-01bd2c94b330
:END:

#+begin_src emacs-lisp
(require 'dashboard)
(void-add-hook 'window-setup-hook #'dashboard-insert-startupify-lists)
#+end_src

**** open dashboard at startup
:PROPERTIES:
:ID:       1bcc371e-61fa-480e-bdae-4a999d3b10c9
:END:

#+begin_src emacs-lisp
(defadvice! open-dashboard-instead (:around void-initial-buffer)
  (if void-debug-p
      (apply <orig-fn> <args>)
    (get-buffer-create "*dashboard*")))
#+end_src

**** settings
:PROPERTIES:
:ID:       f5434534-e767-4416-848a-8912bae0ede1
:END:

#+begin_src emacs-lisp
(setq dashboard-items nil)
(setq dashboard-startup-banner 2)
(setq dashboard-center-content t)
(setq initial-buffer-choice #'void-initial-buffer)
#+end_src

*** dashboard-init-info
:PROPERTIES:
:ID: 92c199ad-5862-4fe3-be04-44c94d4286b6
:END:

[[helpvar:void-init-time][void-init-time]] is more accurate than dashboard's init time measure. So I use it
instead.

#+begin_src emacs-lisp
(defadvice! show-package-load-time (:before dashboard-insert-startupify-lists)
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
                       (hash-table-size straight--profile-cache))
                      ((featurep 'package) (length package-activated-list))
                      (t 0))
                (string-to-number (emacs-init-time)))))
#+end_src

*** banner path
:PROPERTIES:
:ID: 597af7c3-f5d2-4cf5-a93e-3dd3564fb34a
:END:

#+begin_src emacs-lisp
(defadvice! set-custom-banner-path (:override dashboard-get-banner-path)
  "Use the Void text banner."
  (concat VOID-LOCAL-DIR "void-banner.txt"))
#+end_src

** window divider
:PROPERTIES:
:ID:       2cdd6e24-5153-4585-8f1f-206b33445359
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

*** init
:PROPERTIES:
:ID:       c3e2fda8-89c8-4f3b-951a-113e936d6206
:END:

**** hooks
:PROPERTIES:
:ID:       66ada8e3-2fce-428b-a096-e3495e573414
:END:

#+begin_src emacs-lisp
(void-add-hook 'window-setup-hook #'window-divider-mode)
#+end_src

**** custom variables
:PROPERTIES:
:ID:       21010045-e2e1-4c13-a9d7-63468e6a5739
:END:

#+begin_src emacs-lisp
(custom-set-default 'window-divider-default-places t)
(custom-set-default 'window-divider-default-bottom-width 7)
(custom-set-default 'window-divider-default-right-width  7)
#+end_src

*** window divider face
:PROPERTIES:
:ID:       61157149-dcce-40a9-8bfa-76a6af24838a
:END:

#+begin_src emacs-lisp
(defhook! set-window-divider-face (load-theme)
  (set-face-foreground 'window-divider "black"))
#+end_src

*** update on theme change
:PROPERTIES:
:ID: 342bd557-889b-4dbd-8e76-5cd9da3b0f74
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (void-after-load-theme-hook)
  "Ensure window divider persists after theme change."
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

*** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

**** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun frame:adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

**** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (frame:adjust-window-divider-size 1))
#+end_src

**** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (frame:adjust-window-divider-size -1))
#+end_src

* Keybindings
:PROPERTIES:
:ID:       e4605d42-4d57-40d9-8594-15b06f6196a4
:END:

** execute extended command
:PROPERTIES:
:ID: d8071a32-e58c-41ab-8fd7-7d7732708ee8
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently demands it have one of the shortest, easiest to press
bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and quick to
type as well as consistent with other =SPC= bindings. While =;= is super fast to
press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(define-leader-key! "SPC"
  (list :def #'execute-extended-command :wk "M-x"))

(general-def 'normal
  ";" #'execute-extended-command)

(general-def
  "A-x" #'execute-extended-command
  "M-x" #'execute-extended-command)
#+end_src

** bindings that should be available everywhere
:PROPERTIES:
:ID:       cfb08f5e-9e6e-4e9f-ab85-92f9cc26f1bd
:END:

#+begin_src emacs-lisp
(define-localleader-key!
  "a" (list :def #'org-agenda         :wk "agenda")
  "s" (list :def #'void/open-scratch  :wk "scratch")
  "f" (list :def #'void/set-font-size :wk "font size")
  "c" (list :def #'org-capture        :wk "capture"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

** space bindings
:PROPERTIES:
:ID:       8f00f10d-0ace-4531-a3f4-2508a6592e06
:END:

*** eval
:PROPERTIES:
:ID: afa6be08-a38c-45f1-867a-5620fc290aac
:END:

#+begin_src emacs-lisp
(define-leader-key! "e" (list :ignore t :wk "eval"))

(define-leader-key!
  :infix "e"
  "e" (list :def #'eval-expression :wk "expression")
  "r" (list :def #'eval-region          :wk "region")
  "d" (list :def #'eval-defun           :wk "defun")
  "l" (list :def #'eval-print-last-sexp :wk "sexp")
  "B" (list :def #'eval-buffer          :wk "buffer"))

(define-leader-key!
  :infix "e"
  :keymaps 'org-mode-map
  "b" (list :def #'org-babel-execute-src-block :wk "source block")
  "s" (list :def #'org-babel-execute-subtree :wk "subtree"))
#+end_src

*** packages
:PROPERTIES:
:ID: d3286920-ead4-4f7c-bf9d-8a6ed3d7ba46
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "p"
  ""  (list :ignore t                       :wk "package")
  "i" (list :def #'straight-use-package     :wk "install")
  "r" (list :def #'straight-rebuild-package :wk "rebuild")
  "p" (list :def #'straight-pull-package    :wk "pull")
  "s" (list :def #'straight/search-package  :wk "search"))
#+end_src

*** git
:PROPERTIES:
:ID: 87ba6613-6606-423c-84ec-f7c9ae10c9a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "g"
  ""  (list :ignore t           :wk "git")
  "c" (list :def #'magit-commit :wk "commit")
  "s" (list :def #'magit-status :wk "status"))
#+end_src

*** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(define-leader-key! "t" (list :ignore t :wk "toggle/set"))

(define-leader-key!
  :infix "t"
  "r" (list :def #'read-only-mode        :wk "read-only")
  "t" (list :def #'load-theme            :wk "load theme")
  "c" (list :def #'caps-lock-mode        :wk "caps lock")
  "d" (list :def #'toggle-debug-on-error :wk "debug")
  "F" (list :def #'void/set-font-face    :wk "set font")
  "f" (list :def #'void/set-font-size    :wk "font size"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

*** help
:PROPERTIES:
:ID: c7f3b699-7cf9-480b-a88c-10bdae4c165e
:END:

There's a lot of documentation finding and information searching involved in
Emacs and for that we need all the help we can get.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "h"
  ""  (list :ignore t                :wk "help")
  "i" (list :def #'info              :wk "info")
  "m" (list :def #'describe-mode     :wk "mode")
  "h" (list :def #'describe-function :wk "function")
  "v" (list :def #'describe-variable :wk "variable")
  "c" (list :def #'describe-char     :wk "char")
  "k" (list :def #'describe-key      :wk "key")
  "f" (list :def #'describe-function :wk "function")
  "a" (list :def #'apropos           :wk "apropos"))
#+end_src

*** quit
:PROPERTIES:
:ID:       ae435361-79e7-41c8-b490-8ec0f8d23a59
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "q"
  ""  (list :ignore t                        :wk "quit")
  "q" (list :def #'evil-quit-all             :wk "normally")
  "s" (list :def #'void/quit-emacs-no-prompt :wk "with no prompt")
  "Q" (list :def #'evil-save-and-quit        :wk "and save")
  "x" (list :def #'void/kill-emacs-no-hook   :wk "with no hook")
  "e" (list :def #'void/kill-emacs-processes :wk "emacs processes")
  "b" (list :def #'void/kill-emacs-brutally  :wk "brutally")
  ;; "r" (list :def #'restart-emacs             :wk "and restart")
  )
#+end_src

*** buffer
:PROPERTIES:
:ID: e3eec4f8-88d8-4010-adb5-2f8e05f14677
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "b"
  ""  (list :def nil                             :wk "buffer")
  "p" (list :def #'previous-buffer               :wk "previous")
  "n" (list :def #'next-buffer                   :wk "next")
  "o" (list :def #'switch-to-buffer-other-window :wk "switch other window")
  "b" (list :def #'switch-to-buffer              :wk "switch")
  "d" (list :def #'display-buffer                :wk "display"))

(define-leader-key!
  :infix "b k"
  ""  (list :ignore t             :wk "kill")
  "c" (list #'kill-current-buffer :wk "current"))

(define-leader-key!
  :infix "b c"
  ""  (list :ignore t                  :wk "common buffers")
  "m" (list :def #'void/open-messages  :wk "*Messages*")
  "s" (list :def #'void/open-scratch   :wk "*scratch*")
  "i" (list :def #'void/open-init-file :wk "init"))
#+end_src

*** code
:PROPERTIES:
:ID: 661f77fb-3435-4e4f-8adb-c4d6390ea6b8
:END:

These bindings are for generally working with code.

#+begin_src emacs-lisp
(define-leader-key! "c" (list :ignore t :wk "code"))

(define-leader-key!
  :infix "c"
  "a" (list :def #'ialign                               :wk "align")
  "l" (list :def #'lispyville-comment-or-uncomment-line :wk "toggle comment")
  "y" (list :def #'lispyvile-comment-and-cone-dwim      :wk "copy comment"))
#+end_src

*** app
:PROPERTIES:
:ID: 3f09a41a-03b8-4d5c-85c5-d7adeb7dd328
:END:

These are keybindings I use most frequently.

#+begin_src emacs-lisp
(define-leader-key! "a" (list :ignore t :wk "app"))

(define-leader-key!
  :infix "a"
  "a" (list :def #'void/open-org-agenda        :wk "agenda")
  "m" (list :def #'mu4e                        :wk "mu4e")
  "l" (list :def #'org-store-link              :wk "store link")
  "f" (list :def #'elfeed                      :wk "elfeed")
  "d" (list :def #'deer                        :wk "deer")
  "r" (list :def #'ranger                      :wk "ranger")
  "e" (list :def #'void/open-emacs-instance    :wk "emacs")
  "q" (list :def #'engine/search-duckduckgo    :wk "browse web")
  "j" (list :def #'org/avy-goto-headline       :wk "heading jump")
  "c" (list :def #'org-capture/choose-template :wk "capture"))

(define-leader-key! "as" (list :ignore nil :wk "screenshot"))

(define-leader-key!
  :infix "as"
  "s" (list :def #'escr-window-screenshot :wk "screenshot")
  "w" (list :def #'escr-window-screenshot :wk "window")
  "f" (list :def #'escr-frame-screenshot  :wk "frame"))
#+end_src

*** search
:PROPERTIES:
:ID: b50ed0da-652d-4d20-8a4e-e0cf053548a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "s"
  ""  (list :ignore t                       :wk "search")
  "s" (list :def #'consult-line             :wk "jump to line")
  "w" (list :def #'engine/search-duckduckgo :wk "web")
  "h" (list :def #'consult-outline          :wk "jump to outline heading"))
#+end_src

