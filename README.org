
* Core
:PROPERTIES:
:ID:       d68434bf-be6a-471f-ab65-e151f4f1c111
:END:

** Init
:PROPERTIES:
:ID:       71dbf82e-cf4f-4e8a-b14d-df78bea5b20f
:END:

*** gc cons threshold
:PROPERTIES:
:ID: 27ad0de3-620d-48f3-aa32-dfdd0324a979
:END:

A big contributor to long startup times is the garbage collector. When
performing a large number of calculations, it can make a big difference to
increase the [[helpvar:gc-cons-threshold][gc-cons-threshold]], or the /number of bytes of consing between
garbage collections/. The default value is usually too low for modern machines.

**** gc cons threshold
:PROPERTIES:
:ID: e15d257f-1b0f-421e-8b34-076b1d20e493
:END:

#+begin_src emacs-lisp
(defconst VOID:GC-CONS-THRESHOLD-MAX (eval-when-compile (* 256 1024 1024))
  "The upper limit for `gc-cons-threshold'.
When VOID is performing computationally intensive operations,
`gc-cons-threshold' is set to this value.")

(defconst VOID:GC-CONS-THRESHOLD (eval-when-compile (* 16 1024 1024))
  "The default value for `gc-cons-threshold'.
If you experience freezing, decrease this. If you experience stuttering,
increase this.")

(defconst VOID:GC-CONS-PERCENTAGE-MAX 0.6
  "The upper limit for `gc-cons-percentage'.
When VOID is performing computationally intensive operations,
`gc-cons-percentage' is set to this value.")

(defconst VOID:GC-CONS-PERCENTAGE 0.1
  "The default value for `gc-cons-percentage'.")
#+end_src

**** boost gc threshold
:PROPERTIES:
:ID: eac7cfbb-6576-4506-8118-5bfda151654b
:END:

Here I boost the gc-cons-threshold for my current emacs session. It will be
restored after package loading slows down.

#+begin_src emacs-lisp
(setq gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX)
(setq gc-cons-percentage VOID:GC-CONS-PERCENTAGE-MAX)
#+end_src

**** restore threshold after delay
:PROPERTIES:
:ID: d49bef67-0a1e-4026-838c-217b0d6ecad5
:END:

Restore gc-cons-threshold (after a 7 second delay). I got this from [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el#L283][doom]]. We
don't do it immediately because packages are still being lazy loaded at this
time.

#+begin_src emacs-lisp
(defun void:restore-gc-cons-threshold ()
  "Restore `gc-cons-threshold' to `VOID:GC-CONS-PERCENTAGE' after 7 idle seconds."
  (void:log "Restoring...gc-cons-threshold: %d -> %d | gc-cons-percentage %.2f -> %.2f"
            gc-cons-threshold
            VOID:GC-CONS-THRESHOLD
            gc-cons-percentage
            VOID:GC-CONS-PERCENTAGE)
  (setq gc-cons-threshold VOID:GC-CONS-THRESHOLD)
  (setq gc-cons-percentage VOID:GC-CONS-PERCENTAGE))

(run-with-idle-timer 7 nil #'void:restore-gc-cons-threshold)
#+end_src

*** directories
:PROPERTIES:
:ID: 93cc2db1-44c7-45ec-af98-5a4eb7145f61
:END:

**** core directories and files
:PROPERTIES:
:ID: ad18ebcb-803a-4fd6-adcb-c71cf54f3432
:END:

***** top level
:PROPERTIES:
:ID: 48bf884a-de27-45f8-a5b1-94567815942d
:END:

These are important files and directories that I end up referring to often in my
code. Well, not so much =VOID:README-FILE= and =VOID:TODO-FILE= but the others are
referenced alot.

#+begin_src emacs-lisp
(defconst VOID:EMACS-DIR (file-truename user-emacs-directory)
  "Path to `user-emacs-directory'.")

(defconst VOID:INIT-FILE (concat VOID:EMACS-DIR "init.el")
  "Path to the elisp file that bootstraps Void startup.")

(defconst VOID:README-FILE (concat VOID:EMACS-DIR "README.org")
  "Path to the Org file that when that Void.")

(defconst VOID:ORG-DIR (expand-file-name "~/Documents/org/")
  "Path where Void's org files go.")

(defconst VOID:SCREENSHOT-DIR (concat VOID:EMACS-DIR "screenshots/")
  "Path where any screenshots I take with Void go.")

(defconst VOID:TEST-FILE (concat VOID:EMACS-DIR "test.org")
  "Path to the file that contains all of Void's tests.")

(defconst VOID:TODO-FILE (concat VOID:ORG-DIR "emacs.org")
  "Path where all of Void's emacs related todos go.")
#+end_src

***** hidden
:PROPERTIES:
:ID: d46d573b-1d17-4d0b-9b49-9049dbb6f7c1
:END:

#+begin_src emacs-lisp
(defconst VOID:LOCAL-DIR (concat VOID:EMACS-DIR ".local/")
  "Path to the directory for local Emacs files.
Files that need to exist, but I don't typically want to see go here.")

(defconst VOID:DATA-DIR (concat VOID:LOCAL-DIR "data/")
  "Path to the directory where Void data files are stored.")

(defconst VOID:PACKAGES-DIR (concat VOID:LOCAL-DIR "packages/")
  "Path to the directory where packages are stored.")
#+end_src

**** system directories
:PROPERTIES:
:ID:       f3bdd353-b0ff-48fd-a2f2-295ccfa139ab
:END:

#+begin_src emacs-lisp
(defconst VOID:DOWNLOAD-DIR (expand-file-name "~/Downloads/")
  "Directory where downloads should go.")

(defconst VOID:MULTIMEDIA-DIR (expand-file-name "~/Multimedia/")
  "Directory where multimedia should go.")

(defconst VOID:VIDEO-DIR (concat VOID:MULTIMEDIA-DIR "Videos/")
  "Directory where videos should go.")

(defconst VOID:MUSIC-DIR (concat VOID:MULTIMEDIA-DIR "Music/")
  "Directory where music should go.")

(defconst VOID:ALERT-SOUNDS (concat VOID:MULTIMEDIA-DIR "Alert Sounds/")
  "Directory where alert sounds should go.")

(defconst VOID:EMAIL-DIR (expand-file-name "~/.mail/")
  "Directories where emails are stored.")
#+end_src

**** ensure directories exist
:PROPERTIES:
:ID: 56e80dda-5d0e-4c7c-a225-00d0028d4995
:END:

I create the directories that don't exist. But I assume they already exist if
Void is compiled.

#+begin_src emacs-lisp
(dolist (dir (list VOID:LOCAL-DIR VOID:DATA-DIR VOID:ORG-DIR))
  (make-directory dir t))
#+end_src

*** message logging
:PROPERTIES:
:ID:       4d4f4b4a-4fc3-47fe-bed7-acc8e8103933
:END:

Its not uncommon for the *Messages* buffer to become full of messages.

**** debug-p
:PROPERTIES:
:ID: b9e28d90-cdbe-412f-8ed8-1b8b97c1ab07
:END:

[[helpvar:void-debug-p][void:debug]] is snatched from [[https://github.com/hlissner/doom-emacs][Doom's]] [[https://github.com/hlissner/doom-emacs/blob/develop/core/core.el][doom-debug-mode]]. The point of this variable
is to serve as an indicator of whether the current Void instance is run for
debugging. When Void is set up for debugging it prints out many messages about
what its doing via [[hfn:void-log][void:log]].

#+begin_src emacs-lisp
(defvar void:debug-p (or (getenv "DEBUG") init-file-debug)
  "When non-nil print debug messages.
The --debug-init flag and setting the DEBUG envar will enable this at startup.")
#+end_src

**** logging
:PROPERTIES:
:ID: 84ded5f7-382e-4f59-af9e-ccb157ef5c42
:END:

The purpose of ~void:log~ is to distinguish regular messages from messages that
pertain specifically to Void, and to help debug Void functionality. When Void is
=void:debug= is non-nil, void:specific messages are logged in the =*messages*=
buffer.

#+begin_src emacs-lisp
(defun void:log (format-string &rest args)
  "Log to *Messages* if `void:debug-p' is on.
Does not interrupt the minibuffer if it is in use, but still log to *Messages*.
Accept the same arguments as `message'."
  (when void:debug-p
    (let ((inhibit-message (active-minibuffer-window)))
      (when void:debug-p
        (apply #'message (concat (propertize "VOID " 'face 'font-lock-comment-face)
                                 format-string)
               args)))))
#+end_src

*** default coding system
:PROPERTIES:
:ID:       4c55a0d4-dbd7-4405-b944-3b68d8a069f2
:END:

#+begin_src emacs-lisp
(defconst VOID:DEFAULT-CODING-SYSTEM 'utf-8
  "Default text encoding.")
#+end_src

*** UTF-8
:PROPERTIES:
:ID: dd0fc702-67a7-404c-849e-22804663308d
:END:

I set =utf-8= as the default encoding for everything except the clipboard on
windows. Window clipboard encoding could be wider than =utf-8=, so we let
Emacs/the OS decide what encoding to use.

#+begin_src emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
#+end_src

** Package Manager Bootstrap
:PROPERTIES:
:ID: 0397db22-91be-4311-beef-aeda4cd3a7f3
:END:

*** straight.el
:PROPERTIES:
:ID: a086d616-b90d-4826-b61f-93eb0b7efc8e
:END:

[[straight][straight.el]] is a package manager that strives to make emacs configurations
completely reproducable.

**** customize straight directory
:PROPERTIES:
:ID: 843cc8b9-edff-42f7-a767-65a59aa38fbc
:END:

The path of the straight directory within emacs is hardcoded into
straight so we need to trick it into thinking =VOID:PACKAGES-DIR= is the
our emacs directory. This needs to be done before bootstraping
straight, else the straight directory will be created anyway. I got
this from Doom's straight branch.

#+begin_src emacs-lisp
(defun straight:use-packages-dir-a (orig-fn &rest args)
  "Use `VOID:PACKAGES-DIR' for straight directory."
  (let ((user-emacs-directory VOID:PACKAGES-DIR))
    (apply orig-fn args)))

(advice-add #'straight--emacs-dir :around #'straight:use-packages-dir-a)
#+end_src

**** bootstrap code
:PROPERTIES:
:ID: 7816be80-4db8-4219-b7d1-9a6b1ea96035
:END:

This code initializes straight if it's not already installed.

#+begin_src emacs-lisp
(defun straight:init-fn ()
  "Initialize `straight.el'."
  (defvar bootstrap-version)
  (let* ((user-emacs-directory VOID:PACKAGES-DIR)
         (bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage)))
#+end_src

**** straight-installer
:PROPERTIES:
:ID: 5b38a3da-d237-45f5-804f-5fd7e2f88d83
:END:

#+begin_src emacs-lisp
(defun straight:install-package (package-or-recipe)
  "Install PACKAGE with optional RECIPE."
  (unless (featurep 'straight) (straight:init-fn))
  (let ((package (or (car-safe package-or-recipe) package-or-recipe)))
    (condition-case err
        (progn (straight-use-package package-or-recipe)
               (void:log "✓ installed %s" package))
      (error
       (void:log "✕ failed to install %s because of %s" package err)))))
#+end_src

*** required packages
:PROPERTIES:
:ID: 453cc36d-9174-4b63-b3f2-4d1dd7e3521d
:END:

#+begin_src emacs-lisp
(dolist (package '(leaf-keywords leaf dash anaphora))
  (funcall #'straight:install-package package)
  (require package))
#+end_src

*** leaf aliases
:PROPERTIES:
:ID:       1fc34b15-c6cc-450c-bcc9-61a9a8f5a39d
:END:

The name =leaf= is not very indicative of what the leaf macro does. Therefore, I
alias it to =use-package!= for external packages, and =use-feature!= for built-in
packages.

#+begin_src emacs-lisp
(defalias 'use-package! 'leaf)

(defmacro use-feature! (feature &rest args)
  (declare (indent defun))
  `(leaf ,feature :ensure nil ,@args))
#+end_src

** Library
:PROPERTIES:
:ID: 3e9e5e7a-9f9b-4e92-b569-b5e8ba93820f
:END:

This headline contains all the the helper functions and macros I defined for
customizing emacs.

*** macro writing tools
:PROPERTIES:
:ID:       ea5d3295-d8f9-4f3a-a1f6-25811696aa29
:END:

**** symbols
:PROPERTIES:
:ID: 2cdf8ab1-4e59-4128-a8a4-e5519ca0f4bf
:END:

Conversion between symbols, keywords, and strings are prevalent in
macro-writing.

***** symbol intern
:PROPERTIES:
:ID: 659e8389-84c5-4ac4-a9ba-7dd40599191d
:END:

#+begin_src emacs-lisp
(defun void:symbol-intern (&rest args)
  "Return ARGS as a symbol."
  (declare (pure t) (side-effect-free t))
  (intern (apply #'void:to-string args)))
#+end_src

***** keyword intern
:PROPERTIES:
:ID: f2668044-13b2-46e7-bf84-fcf998591e37
:END:

#+begin_src emacs-lisp
(defun void:keyword-intern (&rest args)
  "Return ARGS as a keyword."
  (declare (pure t) (side-effect-free t))
  (apply #'void:symbol-intern ":" args))
#+end_src

***** keyword name
:PROPERTIES:
:ID: fb867938-d62b-42fc-bf07-092f10b64f22
:END:

#+begin_src emacs-lisp
(defun void:keyword-name (keyword)
  "Return the name of the KEYWORD without the prepended `:'."
  (declare (pure t) (side-effect-free t))
  (substring-no-properties (void:to-string keyword) 1))
#+end_src

***** convert to string
:PROPERTIES:
:ID: 4ef52875-4ce6-4940-8b7e-13c96bedcb3d
:END:

#+begin_src emacs-lisp
(defun void:to-string (&rest args)
  "Return ARGS as a string."
  (declare (pure t) (side-effect-free t))
  (with-output-to-string
    (dolist (a args) (princ a))))
#+end_src

**** wrap-form
:PROPERTIES:
:ID:       48e48c0f-7bb3-45c9-b4af-2da0ce84b64e
:END:

When writing macros in lisp it is not uncommon to need to write a macro that can
nest a form within some number of other forms (for an example, see [[id][after!]]). This
macro makes this problem much easier.

#+begin_src emacs-lisp
(defun void:wrap-form (wrappers form)
  "Wrap FORM with each wrapper in WRAPPERS.
WRAPPERS are a list of forms to wrap around FORM."
  (declare (pure t) (side-effect-free t))
  (setq wrappers (reverse wrappers))
  (if (consp wrappers)
      (void:wrap-form (cdr wrappers)
                      (append (car wrappers)
                              (list form)))
    form))
#+end_src

**** anaphora
:PROPERTIES:
:ID:       9938b1e1-6c6e-4a45-a85e-1a7f2d0bf6df
:END:

Anaphora refers to the ability to refer to. I have decided it is best to use
=<>= to denote the symbol referred to by anaphoric macros because it is easy to
type (assuming parentheses completion), because such a symbol uncommon in lisp.
A key advantage to this is that there is a consistent "syntax" for anaphoric
variables as opposed to using =it=. A consequence of this is that you have more
flexibility to name variables. Additionally, I like that it looks like a slot or
placeholder.

https://en.wikipedia.org/wiki/Anaphoric_macro

***** anaphoric symbol regexp
:PROPERTIES:
:ID:       40c97bd5-dab1-44df-86f7-90274d5a8ea0
:END:

#+begin_src emacs-lisp
(defconst VOID:ANAPHORIC-SYMBOL-REGEXP
  (eval-when-compile (rx "<" (group (1+ (not (any white ">" "<")))) ">"))
  "Regular expression that matches an anaphoric symbol.")
#+end_src

***** anaphoric symbol
:PROPERTIES:
:ID:       db8169ba-1630-42fe-9ab7-e29c110a18c3
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-symbol-p (obj)
  "Return non-nil if OBJ is an anaphoric symbol."
  (and (symbolp obj)
       (string-match-p VOID:ANAPHORIC-SYMBOL-REGEXP (symbol-name obj))))
#+end_src

***** true anaphora name
:PROPERTIES:
:ID:       2833cd75-9c85-4c0e-9523-4489d387150a
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-true-symbol (symbol)
  "Return the symbol that corresponds to the anaphoric symbol."
  (save-match-data
    (string-match VOID:ANAPHORIC-SYMBOL-REGEXP (symbol-name symbol))
    (intern (match-string 1 (symbol-name symbol)))))
#+end_src

***** body symbols
:PROPERTIES:
:ID:       2bae458e-404a-48e7-b57e-ce7f543f6e6d
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-symbols (body)
  "Return all the anaphoric symbols in body."
  (->> (-flatten body)
    (-filter #'void:anaphoric-symbol-p)
    (-uniq)))
#+end_src

***** all anaphoric symbols in obj
:PROPERTIES:
:ID:       e0c0eb8c-52b3-4411-ab0b-06255490dacf
:END:

#+begin_src emacs-lisp
(defun void:anaphoric-symbols-in-obj (obj)
  "Return a list of anaphoric symbols in OBJ."
  (s-match-strings-all VOID:ANAPHORIC-SYMBOL-REGEXP (void:to-string obj)))
#+end_src

**** with-symbols!
:PROPERTIES:
:ID:       0ba70f30-f1a8-4a5d-acf9-07db9931bd54
:END:

#+begin_src emacs-lisp
(defmacro with-symbols! (names &rest body)
  "Bind each variable in NAMES to a unique symbol and evaluate BODY."
  (declare (indent defun))
  `(let ,(-map (lambda (symbol) `(,symbol (make-symbol ,(symbol-name symbol)))) names)
     ,@body))
#+end_src

**** once-only!
:PROPERTIES:
:ID:       23c10e2a-6ccc-42dc-a898-29ab39a1f79c
:END:

#+begin_src emacs-lisp
(defmacro once-only! (bindings &rest body)
  "Rebind symbols according to BINDINGS and evaluate BODY.

Each of BINDINGS must be either a symbol naming the variable to be
rebound or of the form:

  (SYMBOL INITFORM)

where INITFORM is guaranteed to be evaluated only once.

Bare symbols in BINDINGS are equivalent to:

  (SYMBOL SYMBOL)"
  (declare (indent defun))
  (let* ((bind-fn (lambda (bind)
                    (if (consp bind)
                        (cons (car bind) (cadr bind))
                      (cons bind bind))))
         (names-and-forms (-map bind-fn bindings))
         (names (-map #'car names-and-forms))
         (forms (-map #'cdr names-and-forms))
         (symbols (--map (make-symbol (symbol-name it)) names)))
    `(with-symbols! ,symbols
       (list 'let
             (-zip-with #'list (list ,@symbols) (list ,@forms))
             ,(cl-list* 'let
                        (-zip-with #'list names symbols)
                        body)))))
#+end_src

*** deferred loading
:PROPERTIES:
:ID:       1d0746ea-ecb2-46ad-8afa-a54aca74a185
:END:

**** with-os!
:PROPERTIES:
:ID: 1a645745-11ce-4cfb-8c5f-63470f0a61c3
:END:

Emacs is for the most part operating system agnostic. Packages written in elisp
should work across operating systems. Nevertheless, there are a handful of
settings that should favors particular operating systems over others.

#+begin_src emacs-lisp
(defmacro with-os! (os &rest body)
  "If OS is current system's operating system, execute body.
OS can be either `mac', `linux' or `windows'(unquoted)."
  (declare (indent defun))
  (setq os (if (listp os) os (list os)))
  (when (funcall (cond ((eq :not (car-safe os)) (lambda (a b) (not (member a b))))
                       (t #'member))
                 (pcase system-type
                   (`darwin 'mac)
                   (`gnu/linux 'linux)
                   (`(cygwin windows-nt ms-dos) 'windows)
                   (_ nil))
                 os)
    `(progn ,@body)))
#+end_src

**** defadvice!
:PROPERTIES:
:ID:       cc161eaf-a8fb-4e24-853f-a76a49c28dcf
:END:

#+begin_src emacs-lisp
(defmacro defadvice! (name args &rest body)
  "Add advice."
  (-let ((docstring (when (stringp (car body)) (pop body)))
         ((key advices . body) body))
    `(prog1 (defun ,name ,args ,docstring ,@body)
       ,@(--map `(advice-add #',it ,key #',name)
                (-list advices)))))
#+end_src

**** eval-after-load!
:PROPERTIES:
:ID:       8d831084-539b-4072-a86a-b55afb09bf02
:END:

If an =eval-after-load= block contains an error and it is triggered by a
feature, the error will keep raised everytime you load that feature.

#+begin_src emacs-lisp
(defmacro eval-after-load! (feature &rest body)
  ""
  (declare (indent defun))
  `(eval-after-load ',feature
     '(with-no-warnings
        (condition-case error
            (progn ,@body)
          (error
           (message "Error: %S" error)
           (message "BODY: %S" ',body))))))
#+end_src

**** after!
:PROPERTIES:
:ID: b31cd42d-cc57-492d-afae-d7d5e353e931
:END:

The reason that we check for the feature is to prevent [[hvar:eval-after-load][eval-after-load]] from polluting the
[[hvar:after-load-list][after-load-list]]. =eval-after-load= adds an entry to =after-load-list= whether or not it has
been loaded.

We intentionally avoid with-eval-after-load to prevent eager macro expansion
from pulling (or failing to pull) in autoloaded macros/features.

#+begin_src emacs-lisp
(defmacro after! (features &rest body)
  "Same as `with-eval-after-load' but."
  (declare (indent defun) (debug t))
  (pcase (car-safe features)
    ('or
     (macroexp-progn
      (--map `(after! ,it ,@body) (cdr features))))
    ('and
     (void:wrap-form (--map `(after! ,it) (cdr features))
                     (macroexp-progn body)))
    ((guard (listp features))
     `(after! ,(cons 'and features) ,@body))
    ((pred symbolp)
     `(if (featurep ',features)
          ,(macroexp-progn body)
        (eval-after-load! ,features ,@body)))
    (_ (error "Invalid argument."))))
#+end_src

*** macros
:PROPERTIES:
:ID:       f27aa611-a2bd-4b76-85ce-72feb1e9f19f
:END:

**** ignore!
:PROPERTIES:
:ID: 0597956f-d40c-4c2b-9adf-5ece8c5b38de
:END:

#+begin_src emacs-lisp
(defmacro ignore! (&rest _)
  "Do nothing and return nil."
  nil)
#+end_src

**** anaphoric macros
:PROPERTIES:
:ID:       001dde5a-bb43-4ce8-82ef-806e37ba7f6e
:END:

***** pair value extraction
:PROPERTIES:
:ID: e546a63f-eb75-4b72-9392-2a6041f87f50
:END:

When extracting one value from a plist, alist or another lisp data structure at
a time, it often suffices to use =plist-get=, =alist-get= or whatever function
is used to get a particular value based on the structure. Sometimes, however, we
need to get and use many values from the data structure. And in these cases it
becomes repetative to have to do ~(plist-get plist key)~ all the time.

****** with-structure!
:PROPERTIES:
:ID: c88dac35-9345-49f5-bdb5-e856071e6764
:END:

#+begin_src emacs-lisp
(defmacro with-structure! (structure fn &rest body)
  "Access items from STRUCTURE.
FN is a function that accepts two arguments, the structure and a symbol name. FN
should return the value of structure for that symbol.
BODY contains any number of `<NAME>' where NAME refers to the name of the symbol."
  (declare (indent 2))
  (let* ((symbols (->> (flatten-list body)
                       (-filter #'void:anaphoric-symbol-p)
                       (-uniq)))
         (names (-map #'void:anaphoric-true-symbol symbols))
         (structure-sym (make-symbol "structure")))
    `(let* ((,structure-sym ,structure)
            ,@(--map `(,it (funcall ,fn ,structure-sym ',it))
                     (-zip #'list symbols names)))
       ,@body)))
#+end_src

****** with-plist!
:PROPERTIES:
:ID: f84e30a9-b725-415e-b1df-7b4489913d2c
:END:

#+begin_src emacs-lisp
(defmacro with-plist! (plist &rest body)
  (declare (indent 1))
  `(with-structure! ,plist #'plist-get ,@body))
#+end_src

****** with-alist!
:PROPERTIES:
:ID: d594c666-0ec1-4c72-9159-5ddea9702d03
:END:

#+begin_src emacs-lisp
(defmacro with-alist! (alist &rest body)
  (declare (indent 1))
  `(with-structure! ,alist (lambda (key) (alist-get key alist)) ,@body))
#+end_src

**** list mutation
:PROPERTIES:
:ID:       d9f77404-5c29-4305-ae53-e409e1b06b99
:END:

***** append!
:PROPERTIES:
:ID: f314672c-f9f3-4630-9402-a9a65215c153
:END:

#+begin_src emacs-lisp
(defmacro append! (sym &rest lists)
  "Append LISTS to SYM.
SYM is a symbol that stores a list."
  (declare (indent 1))
  `(setq ,sym (append ,sym ,@lists)))
#+end_src

***** prepend!
:PROPERTIES:
:ID: 3395dec3-0915-49cd-9445-d3db2b1ffe7f
:END:

#+begin_src emacs-lisp
(defmacro prepend! (sym &rest lists)
  (declare (indent defun))
  `(setq ,sym (append ,@lists ,sym)))
#+end_src

***** nconc!
:PROPERTIES:
:ID: b24d1d8f-f3e1-4dca-afdb-8fb73d5299c3
:END:

#+begin_src emacs-lisp
(defmacro nconc! (sym &rest lists)
  "Append LISTS to SYM by altering them in place."
  (declare (indent 1))
  `(setq ,sym (nconc ,sym ,@lists)))
#+end_src

** Leaf

:PROPERTIES:
:ID:       109f58d7-525e-43f4-b997-658b1d5da0a8
:END:

Like =use-package=, leaf is a macro that fascilitates package configuration.

*** leaf
:PROPERTIES:
:ID:       7d72aec8-5523-473d-860d-181ce3d484d7
:END:

#+begin_src emacs-lisp
(use-package! leaf
  :setq
  (leaf-defaults . '(:ensure t))
  (leaf-expand-minimally . t))
#+end_src

*** leaf-keywords
:PROPERTIES:
:ID:       e47cf69e-4ba8-45d8-bb62-fd0c1d785583
:END:

#+begin_src emacs-lisp
(use-package! leaf-keywords
  :ensure nil
  :init (leaf-keywords-init))
#+end_src

*** defining leaf keywords
:PROPERTIES:
:ID:       5d7d9185-6897-419d-90bd-5e2d2cb3f1b1
:END:

Leaf is very low level. It does not provide a function or macro for fast new
keyword creation. Whenever you want to create a new keyword you have to
recall the underlying leaf data structure.

**** leaf variables
:PROPERTIES:
:ID:       40d6a763-279b-4a18-9761-93754472b1a7
:END:

#+begin_src emacs-lisp
(defvar leaf:process-variables
  '(leaf--raw leaf--name leaf--key leaf--keyname leaf--value leaf--body)
  "List of variables that leaf binds when processing a keyword.")
#+end_src

**** leaf insert keyword
:PROPERTIES:
:ID:       5369cb48-51f3-49c6-8374-5aa84db027e2
:END:

#+begin_src emacs-lisp
(defun leaf:insert-keyword (keyword where place form)
  "Insert KEYWORD at PLACE.
WHERE can be the symbol `before' or `after'."
  (alet (pcase where
          ('after #'leaf-insert-list-after)
          ('before #'leaf-insert-list-before)
          (_ (error "where is %S but expected `before' or `after'" where)))
    (setq leaf-keywords
          (funcall it leaf-keywords place (list keyword form)))))
#+end_src

**** defer
:PROPERTIES:
:ID:       a965af35-804c-460c-8787-1cf8a849dba1
:END:

#+begin_src emacs-lisp
(defun leaf:make-defer (keyword)
  "Add KEYWORD to `leaf-defer-keywords'."
  (add-to-list 'leaf-defer-keywords keyword))
#+end_src

**** alias
:PROPERTIES:
:ID:       7e515288-9071-44dd-b09d-bfddb58c1ea9
:END:

#+begin_src emacs-lisp
(defun leaf:set-alias (alias name)
  "Set ALIAS to NAME."
  (push (cons alias name) leaf-alias-keyword-alist))
#+end_src

**** define-leaf-keyword!
:PROPERTIES:
:ID:       db05b51b-bbe4-41a4-ae45-1e72aba57ae4
:END:

#+begin_src emacs-lisp
(defmacro define-leaf-keyword! (name args &rest body)
  "Define a leaf keyword."
  (declare (indent defun))
  (-let* ((keyword (intern (concat ":" (symbol-name name))))
          ((where place) args)
          (docstring (when (stringp body) (pop body)))
          (actions (--unfold (when (keywordp (car it))
                               (cons (-take 2 it)
                                     (setq body (-drop 2 it))))
                             body))
          (apply-fn (intern (concat "leaf::apply-" (symbol-name name))))
          (form `(,apply-fn ,@leaf:process-variables)))
    `(progn
       (leaf:insert-keyword ,keyword ',where ,place ',form)
       (defun ,apply-fn ,leaf:process-variables
         ,docstring
         (ignore ,@leaf:process-variables)
         ,@body))))
#+end_src

**** normalizer
:PROPERTIES:
:ID:       cc4b1777-9ee5-42bf-a268-c43afcd3fc20
:END:

***** add normalizer
:PROPERTIES:
:ID:       2abfe05c-010b-467f-aab8-2949af3f7b64
:END:

#+begin_src emacs-lisp
(defun leaf:set-normalizer (keyword normalizer)
  "Add KEYWORD."
  (push `((or (memq leaf--key '(,keyword))
              (eq (alist-get leaf--key leaf-alias-keyword-alist) ,keyword))
          (funcall #',normalizer leaf--value))
        leaf-normalize))
#+end_src

***** normalizers
:PROPERTIES:
:ID:       72c23168-98dd-4a74-85b8-c0e313aa96df
:END:

****** normalizers
:PROPERTIES:
:ID:       bcf96e13-f3bc-4b23-832f-f94b31dd48a5
:END:

leaf's setq does not correctly handle setting variables to forms that need to be
evaluated.

#+begin_src emacs-lisp
(defun leaf:normalize-setq (leaf--value)
  (-map (-lambda ((var . value)) (cons var value))
        leaf--value))

(defun leaf:normalize-commands (leaf--value)
  (-map (lambda (elm)
          (cond ((memq leaf--key '(:after))
                 (if (eq elm t) leaf--name elm))
                (t elm)))
        (-uniq (delq nil (leaf-flatten leaf--value)))))
#+end_src

*** use =after!= in leaf-defer
:PROPERTIES:
:ID:       3d3cf50c-20eb-4276-a81e-33a6c368d55f
:END:

#+begin_src emacs-lisp
(leaf:set-alias :leaf-defer :void-leaf-defer)

(define-leaf-keyword! void-leaf-defer (before :leaf-defer)
  (if (and leaf--body (eval (car leaf--value))
           (leaf-list-memq leaf-defer-keywords (leaf-plist-keys leaf--raw)))
      `((after! ,leaf--name ,@leaf--body))
    `(,@leaf--body)))
#+end_src

*** custom leaf keywords
:PROPERTIES:
:ID:       2e9dac82-0709-4294-ae58-bb3eccfbb9a5
:END:

**** set keywords
:PROPERTIES:
:ID:       225cdf80-0770-47c0-8a94-6d69f4583374
:END:

Leaf keywords do not.

***** setq
:PROPERTIES:
:ID:       6f38c45b-9382-4d72-a7ae-6d7a8748d07f
:END:

#+begin_src emacs-lisp
(leaf:set-normalizer :setq #'leaf:normalize-setq)
#+end_src

***** pre-setq
:PROPERTIES:
:ID:       aba01554-fa11-4120-9867-19e5e2025df4
:END:

#+begin_src emacs-lisp
(leaf:set-normalizer :pre-setq #'leaf:normalize-setq)
#+end_src

***** custom
:PROPERTIES:
:ID:       bfa61a7a-1660-4000-a80e-15851a32ffd5
:END:

#+begin_src emacs-lisp
(leaf:set-normalizer :custom #'leaf:normalize-setq)
#+end_src

***** setq-default
:PROPERTIES:
:ID:       b8ab2bf6-2b4e-41db-93f8-ed5c86392c84
:END:

#+begin_src emacs-lisp
(leaf:set-normalizer :setq-default #'leaf:normalize-setq)
#+end_src

**** defer keywords
:PROPERTIES:
:ID:       6a8189ab-9a7a-4670-aa7a-b6589c180011
:END:

These keywords are meant to improve on the deferred loading options already
provided by leaf. They are inspired from DOOM emacs.

***** leaf-generate-load-fn
:PROPERTIES:
:ID:       41c05e4a-a0f1-45e7-bed6-7de7a439faa1
:END:

#+begin_src emacs-lisp
(defun leaf:generate-load-form (package &optional hooks advice-place advices)
  "Return form that evals into function that loads the package."
  (let ((load-fn (intern (concat "leaf:load-" (symbol-name package)))))
    `(progn
       (defun ,load-fn (&rest _)
         (void:log "Loading %S..." ',package)
         (unless (require ',package nil t)
           (message "Error loading %S" ',package))
         ,@(mapcar (lambda (hook) `(remove-hook ',hook #',load-fn)) hooks)
         ,@(mapcar (lambda (advice) `(advice-remove #',advice #',load-fn)) advices)
         (fmakunbound #',load-fn))
       ,@(mapcar (lambda (hook) `(add-hook ',hook #',load-fn)) hooks)
       ,@(mapcar (lambda (advice) `(advice-add #',advice ,advice-place #',load-fn)) advices))))
#+end_src

***** before-call
:PROPERTIES:
:ID:       5378035c-206b-4479-8c60-4d57853e5754
:END:

#+begin_src emacs-lisp
(leaf:make-defer :before-call)

(leaf:set-normalizer :before-call #'leaf:normalize-commands)

(define-leaf-keyword! before-call (before :hook)
  `(,(leaf:generate-load-form leaf--name nil :before leaf--value)
    ,@leaf--body))
#+end_src

***** after-call
:PROPERTIES:
:ID:       36389857-c070-4221-8f76-b6b0da257b34
:END:

#+begin_src emacs-lisp
(leaf:make-defer :after-call)

(leaf:set-normalizer :after-call #'leaf:normalize-commands)

(define-leaf-keyword! after-call (before :hook)
  `(,(leaf:generate-load-form leaf--name nil :after leaf--value)
    ,@leaf--body))
#+end_src

***** defer-incrementally
:PROPERTIES:
:ID:       c7ab7604-6e7c-42d1-b956-c58854948e8f
:END:

#+begin_src emacs-lisp
(define-leaf-keyword! idle-require (before :before-call)
  `((-each ',leaf--value #'idle-require)
    ,@leaf--body))
#+end_src

**** straight keyword
:PROPERTIES:
:ID:       cba57988-21b2-456b-aed2-27254febf873
:END:

This keyword is designed to be compiled away, leaving only forms adding package
paths to the load-path. This is so that package installation isn't done after
VOID is compiled.

#+begin_src emacs-lisp
(leaf:set-alias :straight :void-straight)
(leaf:set-alias :ensure :void-straight)

(leaf:set-normalizer :void-straight #'leaf:void-straight-normalizer)

(define-leaf-keyword! void-straight (before :straight)
  `(,@(when (and leaf--value (car-safe leaf--value))
        `((straight:install-package ',(car leaf--value))))
    ,@leaf--body))

(defun leaf:void-straight-normalizer (leaf--value)
  (cond ((eq t (car leaf--value))
         (list leaf--name))
        ((eq nil (car leaf--value))
         nil)
        ((listp (car-safe leaf--value))
         (list (cons leaf--name (car leaf--value))))))
#+end_src

**** popup
:PROPERTIES:
:ID:       30845314-ac19-49bb-9065-591c13e55489
:END:

The point of this keyword is to let me configure the display of buffers for
specific packages.

#+begin_src emacs-lisp
(define-leaf-keyword! popup (before :mode)
  `(,@(--map `(push ',it display-buffer-alist) leaf--value)
    ,@leaf--body))
#+end_src

**** os
:PROPERTIES:
:ID:       3335e409-b963-4504-b9fb-2faf4fb0be3d
:END:

#+begin_src emacs-lisp
(define-leaf-keyword! os (before :when)
  (when leaf--body `((with-os! ,leaf--value ,@leaf--body))))
#+end_src

**** straight
:PROPERTIES:
:ID:       9dff9894-667c-4e74-9624-8aee533f8f70
:END:

#+begin_src emacs-lisp
(use-package! straight
  :require t
  :setq
  (straight-disable-autoloads . nil)
  (straight-cache-autoloads . t)
  (straight-check-for-modifications . nil)
  (straight-enable-package-integration . nil)
  (straight-recipes-emacsmirror-use-mirror . t))
#+end_src

**** alias
:PROPERTIES:
:ID:       9ce3a0f5-6b44-4c60-9599-b3b77199fa99
:END:

#+begin_src emacs-lisp
(leaf:set-normalizer :alias #'leaf:normalize-setq)

(define-leaf-keyword! alias (before :init)
  `((eval-and-compile
      ,@(-map (-lambda ((alias . def)) `(defalias ',alias ',def))
              leaf--value))
    ,@leaf--body))
#+end_src

**** ignore-buffers
:PROPERTIES:
:ID:       46e099c0-257b-4292-b5bc-acdf1bceaeea
:END:

#+begin_src emacs-lisp
(leaf:set-normalizer :ignore-buffers #'leaf:normalize-commands)

(define-leaf-keyword! ignore-buffers (before :init)
  `((after! midnight
      (--each ',leaf--value
        (push it clean-buffer-list-kill-regexps)))
    ,@leaf--body))
#+end_src

** Packages
:PROPERTIES:
:ID:       d5c0d112-319d-4271-a819-eb786a64bfc6
:END:

*** built-in
:PROPERTIES:
:ID: 40367976-12a0-4ccd-9aff-4df144a73edf
:END:

**** vc-hook
:PROPERTIES:
:ID:       a8dcb1f6-05a0-46cb-95b5-1d0cd0ad4467
:END:

#+begin_src emacs-lisp
(use-feature! vc-hooks
  :setq
  (vc-follow-link . t)
  (vc-follow-symlinks . t))
#+end_src

**** subr-x
:PROPERTIES:
:ID:       ee3ad1b5-920a-4337-9874-79e066ed53fe
:END:

#+begin_src emacs-lisp
(use-feature! subr-x :require t)
#+end_src

**** startup
:PROPERTIES:
:ID: 9725b7e0-54b8-4ab4-aa00-d950345d0aea
:END:

Emacs starts up with a default screen setup. No, thanks.

#+begin_src emacs-lisp
(use-feature! startup
  :setq
  (inhibit-startup-screen . t)
  (inhibit-default-init . t)
  (inhibit-startup-buffer-menu . t)
  (initial-major-mode . 'fundamental-mode)
  (initial-scratch-message . nil)
  (initial-buffer-choice . (if void:debug-p (lambda () (get-buffer "*Messages*")) t))
  (inhibit-startup-echo-area-message . user-login-name))
#+end_src

**** paren
:PROPERTIES:
:ID: 8ba80d6f-292e-4d44-acfe-d7b7ba939fa4
:END:

#+begin_src emacs-lisp
(use-feature! paren
  :hook (prog-mode-hook . show-paren-mode)
  :setq-default
  (show-paren-delay . 0))
#+end_src

**** clipboard
:PROPERTIES:
:ID: 60abb076-89b1-439b-8198-831b2df47782
:END:

#+begin_src emacs-lisp
;; Not windows.
(use-feature! select
  :setq
  (selection-coding-system . 'utf-8)
  (select-enable-clipboard . t)
  (select-enable-primary . t)
  (x-select-request-type . '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

**** simple
:PROPERTIES:
:ID: 89df102a-a2c9-4ece-9acc-ed90e8064ed8
:END:

#+begin_src emacs-lisp
(use-feature! simple
  :popup ("\\*Messages"
          (display-buffer-at-bottom)
          (window-height . 0.5))
  :setq-default
  (idle-update-delay . 1)
  (blink-matching-paren . t)
  (delete-trailing-lines . nil)
  :setq
  (mail-user-agent . 'mu4e-user-agent))
#+end_src

**** loaddefs
:PROPERTIES:
:ID:       5af4faf8-47e3-4db2-9d13-47fc828b8fca
:END:

These are *extremely* important lines if you use an external program as I do
([[https://wiki.archlinux.org/index.php/Msmtp][msmtp]]) to send your email. If you don't set these variables, emacs will
think you want to use =smtp=.

#+begin_src emacs-lisp
(use-feature! loaddefs
  :setq-default
  (disabled-command-function . nil)
  ;; very important if you're using msmtp
  )
#+end_src

**** files
:PROPERTIES:
:ID: 2a7862da-c863-416b-a976-4cf7840a8712
:END:

#+begin_src emacs-lisp
(use-feature! files
  :setq-default
  ;; Disable second, case-insensitive pass over `auto-mode-alist'.
  (auto-mode-case-fold . nil)
  ;; Whether to add a newline automatically at the end of the file.
  ;; Whether confirmation is requested before visiting a new file or buffer.
  (confirm-nonexistent-file-or-buffer . nil)
  ;; How to ask for confirmation when leaving Emacs.
  (confirm-kill-emacs . #'y-or-n-p)
  (require-final-newline . nil)
  (trash-directory . (expand-file-name "Trash" "~"))
  (auto-save-default . nil)
  (auto-save-interval . 300)
  (auto-save-timeout . 30)
  (backup-directory-alist . (list (cons ".*" (concat VOID:DATA-DIR "backup/"))))
  (make-backup-files . nil)
  (version-control . nil)
  (kept-old-versions . 2)
  (kept-new-versions . 2)
  (delete-old-versions . t)
  (backup-by-copying . t)
  (backup-by-copying-when-linked . t))
#+end_src

**** subr
:PROPERTIES:
:ID:       61603f44-780e-4456-88c6-7ffe1e5c7197
:END:

#+begin_src emacs-lisp
(use-feature! subr
  :init
  (fset #'yes-or-no-p #'y-or-n-p)
  (fset #'display-startup-echo-area-message #'ignore))
#+end_src

**** subr-x
:PROPERTIES:
:ID:       1ed0ba00-e5a1-4642-9ed5-a52f4b917a4d
:END:

#+begin_src emacs-lisp
;; This is where `->>' and `thread-first' come from.
(use-feature! subr-x
  :require t)
#+end_src

**** ffap
:PROPERTIES:
:ID: b1229201-a5ac-45c7-91fa-7a6b39bbb879
:END:

Don't ping things that look like domain names.

#+begin_src emacs-lisp
(use-feature! ffap
  :setq
  (ffap-machine-p-known . 'reject))
#+end_src

**** server
:PROPERTIES:
:ID: 3ddeb65c-9df6-4ede-9644-eb106b3ba1dd
:END:

#+begin_src emacs-lisp
(use-feature! server
  :setq
  (server-auth-dir . (concat VOID:DATA-DIR "server/")))
#+end_src

**** tramp
:PROPERTIES:
:ID: 3af0a4d6-bd08-4fe2-bc5c-79b1b811fc6b
:END:

#+begin_src emacs-lisp
(use-feature! tramp
  :setq
  (tramp-backup-directory-alist . backup-directory-alist)
  (tramp-auto-save-directory . (concat VOID:DATA-DIR "tramp-auto-save/"))
  (tramp-persistency-file-name . (concat VOID:DATA-DIR "tramp-persistency.el")))
#+end_src

**** desktop
:PROPERTIES:
:ID: 3a6b72e7-57c8-42f0-a8d7-1bbde72de9bd
:END:

#+begin_src emacs-lisp
(use-feature! desktop
  :setq
  (desktop-dirname . (concat VOID:DATA-DIR "desktop"))
  (desktop-base-file-name . "autosave")
  (desktop-base-lock-name . "autosave-lock"))
#+end_src

**** cus-edit
:PROPERTIES:
:ID: 8bd5683d-91e1-4c1b-a8a5-3b39921e995d
:END:

#+begin_src emacs-lisp
(use-feature! cus-edit
  :setq
  (custom-file . (concat VOID:DATA-DIR "custom.el"))
  (custom-theme-directory . (concat VOID:LOCAL-DIR "themes/")))
#+end_src

**** url cache
:PROPERTIES:
:ID: e4b5bfce-1111-48b2-bfee-da754974aa46
:END:

#+begin_src emacs-lisp
(use-feature! url
  :setq
  (url-cache-directory . (concat VOID:DATA-DIR "url/cache/"))
  (url-configuration-directory . (concat VOID:DATA-DIR "url/configuration/")))
#+end_src

**** bytecomp
:PROPERTIES:
:ID:       6b375bfb-a8c3-473c-8dbd-530e692a15ab
:END:

#+begin_src emacs-lisp
(use-feature! bytecomp
  :setq
  (byte-compile-verbose . void:debug-p)
  (byte-compile-warnings . '(not free-vars unresolved noruntime lexical make-local)))
#+end_src

**** compile
:PROPERTIES:
:ID:       913aa4f2-e42b-4b74-a2d4-e87b1738a5bd
:END:

#+begin_src emacs-lisp
(use-feature! compile
  :setq-default
  (compilation-always-kill . t)
  (compilation-ask-about-save . nil)
  (compilation-scroll-output . 'first-error))
#+end_src

**** uniquify
:PROPERTIES:
:ID:       9ba2726b-3fef-4e9b-9387-a80ab09bdb7d
:END:

#+begin_src emacs-lisp
(use-feature! uniquify
  :setq-default
  (uniquify-buffer-name-style . 'forward))
#+end_src

**** ansi-color
:PROPERTIES:
:ID:       5feaab76-e5c1-450c-94a6-8fdfb95ddb94
:END:

#+begin_src emacs-lisp
(use-feature! ansi-color
  :setq-default
  (ansi-color-for-comint-mode . t))
#+end_src

**** image mode
:PROPERTIES:
:ID:       32e2118a-c92b-4e8d-b2db-048428462783
:END:

#+begin_src emacs-lisp
(use-feature! image-mode
  :setq
  ;; Non-nil means animated images loop forever, rather than playing once.
  (image-animate-loop . t))
#+end_src

**** window
:PROPERTIES:
:ID:       af27cd7e-2096-4f6d-a749-63e4c38d136c
:END:

#+begin_src emacs-lisp
(use-feature! window
  :setq-default
  (split-width-threshold . 160))
#+end_src

**** paragraphs
:PROPERTIES:
:ID:       f289ade4-ad16-4f6a-8868-1f9b7af5ddca
:END:

#+begin_src emacs-lisp
(use-feature! paragraphs)
#+end_src

**** indent
:PROPERTIES:
:ID:       a5d97d4d-3af9-4fde-ae14-953ad4d28edd
:END:

#+begin_src emacs-lisp
(use-feature! indent
  :setq-default
  (tab-always-indent . t))
#+end_src

**** mouse
:PROPERTIES:
:ID:       d0d6de11-50fa-4ae2-ad4b-69712f3e2c54
:END:

#+begin_src emacs-lisp
(use-feature! mouse
  :setq-default
  (mouse-yank-at-point . t))
#+end_src

**** calendar
:PROPERTIES:
:ID:       4ad7e704-f490-40e4-b2bc-8a30a10a7bb7
:END:

#+begin_src emacs-lisp
(use-feature! calendar
  :setq (diary-file . (concat VOID:DATA-DIR "diary")))
#+end_src

**** mule-cmds
:PROPERTIES:
:ID:       e48e925e-1f1e-4c79-8652-c92aafe06290
:END:

#+begin_src emacs-lisp
(use-feature! mule-cmds
  :init (prefer-coding-system VOID:DEFAULT-CODING-SYSTEM))
#+end_src

**** gv
:PROPERTIES:
:ID:       84cc5883-a303-453e-af91-644d4544e3f9
:END:

=gv= is what contains the code for the =setf= macro.
https://emacs.stackexchange.com/questions/59314/how-can-i-make-setf-work-with-plist-get

#+begin_src emacs-lisp
(use-feature! gv
  :defer-config
  (gv-define-simple-setter plist-get plist-put))
#+end_src

**** nsm
:PROPERTIES:
:ID:       0ca7fc66-5312-4c69-a87d-7607292c7a2a
:END:

#+begin_src emacs-lisp
(use-feature! nsm
  :setq (nsm-settings-file . (concat VOID:DATA-DIR "network-settings.data")))
#+end_src

*** external libraries
:PROPERTIES:
:ID: 6e4be80e-8149-424d-a801-d7871bfe8fc8
:END:

**** dash-functional
:PROPERTIES:
:ID:       4be107b5-b756-4372-9f74-655bda941b75
:END:

#+begin_src emacs-lisp
(use-package! dash-functional :require t)
#+end_src

**** dash

Dash is an excellent functional list manipulation library. If I did not use it
as a dependency, I'd end up rewriting many of its functions.
:PROPERTIES:
:ID:       7d37ae8b-d319-4077-ae7a-aa463d8ec68d
:END:

#+begin_src emacs-lisp
(use-package! dash :require t)
#+end_src

**** general
:PROPERTIES:
:ID: 706f35fc-f840-4a51-998f-abcd54c5d314
:END:

Keybindings are a key part of emacs (pun intended).

***** general
:PROPERTIES:
:ID: f1ad5258-17cb-4424-a161-b856ee6dc5ab
:END:

There are numerous keybinding functions in Emacs; and they all look a little
different: there's [[helpfn:global-set-key][global-set-key]], [[helpfn:local-set-key][local-set-key]], [[helpfn:define-key][define-key]] and the list goes
on. And with [[][evil]] which [[id:73366b3e-7438-4abf-a661-ed1553b1b8df][I use]] , there's also [[helpfn:evil-global-set-key][evil-global-set-key]] and
[[helpfn:evil-define-key][evil-define-key]]. It would be nice to have one keybinding function that can
handle all bindings. [[][general]] provides such a function ([[helpfn:general-define-key][general-define-key]]).

#+begin_src emacs-lisp
(use-package! general
  :require t
  :config
  (general-auto-unbind-keys))
#+end_src

***** prefix bindings
:PROPERTIES:
:ID: b0b5b51c-155e-46fc-a80a-0d45a32440ba
:END:

A popular strategy to mitigate the mental load of remembering many keybindings
is to bind them in a tree-like fashion. [[][spacemacs]].

****** leader Keys
:PROPERTIES:
:ID: 143211d6-b868-4ffb-a5d0-25a77dee401f
:END:

#+begin_src emacs-lisp
(defvar void:leader-key "SPC"
  "The evil leader prefix key.")

(defvar void:leader-alt-key "M-SPC"
  "The leader prefix key used for Insert and Emacs states.")
#+end_src

****** localleader keys
:PROPERTIES:
:ID: 45941bcb-209f-4aa3-829a-dee4e3ef2464
:END:

#+begin_src emacs-lisp
(defvar void:localleader-key "SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defvar void:localleader-alt-key "C-SPC m"
  "The localleader prefix key for major-mode specific commands.")

(defvar void:localleader-short-key ","
  "A shorter alternative `void:localleader-key'.")

(defvar void:localleader-short-alt-key "M-,"
  "A short non-normal  `void:localleader-key'.")
#+end_src

****** definers
:PROPERTIES:
:ID: 6444d218-1627-48bd-9b5c-7bfffb17d912
:END:

As I've mentioned =general= uses the function =general-define-key= as a generic
do-all key binder. Sometimes though we have keys that we want to bind with
specific arguments to =general-define-key= pretty often. A typical example of
this is binding =leader= or =localleader= keys like [[https://github.com/syl20bnr/spacemacs][spacemacs]].

#+begin_src emacs-lisp
(general-create-definer define-leader-key!
  :prefix void:leader-key
  :non-normal-prefix void:leader-alt-key
  :keymaps 'override
  :states '(normal motion insert emacs))
#+end_src

****** localleader
:PROPERTIES:
:ID:       e4770eae-adf5-4216-9016-5ec4bc465e03
:END:

There's pros and cons to the =SPC m= binding. The main pro is that it's
consistent with =SPC=. With the leader and the localleader, this means that you
can reach any binding from just =SPC=. This means that you can discover all
bindings from just one root binding. This is a nice property to have. On the
other hand, bindings can get a bit long. That one extra character can really
make a difference. That's why.

#+begin_src emacs-lisp
(defmacro define-localleader-key! (&rest args)
  (declare (indent defun))
  (let ((shared-args '(:keymaps 'override :states '(normal motion insert emacs))))
    `(progn (general-def
              ,@args
              ,@shared-args
              :prefix void:localleader-key
              :non-normal-prefix void:localleader-alt-key)
            (general-def
              ,@args
              ,@shared-args
              :prefix void:localleader-short-key
              :non-normal-prefix void:localleader-short-alt-key))))
#+end_src

**** s
:PROPERTIES:
:ID: 4b82deb0-bbe1-452c-8b60-ef734efb86d8
:END:

#+begin_src emacs-lisp
(use-package! s :require t)
#+end_src

**** gc
:PROPERTIES:
:ID: 4f1477b7-7b28-4a20-9a31-cc34a10f5878
:END:

Wait until idle time to garbage collect while staving off garbage collector
while the user is working.

#+begin_src emacs-lisp
(use-package! gcmh
  :hook emacs-startup-hook
  :setq
  (gcmh-idle-delay . 10)
  (gcmh-verbose . void:debug-p)
  (gcmh-high-cons-threshold . (* 16 1024 1024)))
#+end_src

**** shut-up
:PROPERTIES:
:ID:       65590d3e-ef24-4214-a602-2f4728b2f8c1
:END:

#+begin_src emacs-lisp
(use-package! shut-up
  :commands shut-up
  :init
  (defalias 'shut-up! 'shut-up)
  (defalias 'quiet! 'shut-up))
#+end_src

**** keyfreq
:PROPERTIES:
:ID:       626b35f7-eef1-4a75-b2dc-8600c1ac47b7
:END:

#+begin_src emacs-lisp
(use-package! keyfreq :hook emacs-startup-hook)
#+end_src

**** defhook
:PROPERTIES:
:ID:       f77b8dff-6ee8-4e2e-a442-b133bbac770c
:END:

=defhook!= provide a declarative way of setting hooks built on top of =defhook=.
It's built on top of =defhook=.

***** defhook
:PROPERTIES:
:ID:       0526239e-2790-4ee5-bd9b-15393c5536c6
:END:

[[https://github.com/emacsmirror/defhook][defhook]] provides an alternative, declarative mechanism for defining hooks.
Additionally, it provides variables to customize percisely how the hooks are
named, a useful "cl-esque" keyword arguments to further configure =defhook='s
behavior, and a basic way of logging information about when a hook is created
and when it is called. It would be a waste not to use such good and well
thought-out code, so I use it as the backend for my =defhook!= macro.

#+begin_src emacs-lisp
(use-package! defhook
  :require t
  :setq
  (defhook-user-prefix . "")
  (defhook-user-separator . "")
  (defhook-sym-desc-separator . "&")
  (defhook-use-font-lock-mode . nil)
  (defhook-display-informational-messages . (if void:debug-p t nil)))
#+end_src

***** wrapper around defhook
:PROPERTIES:
:ID:       4daf2baf-ea7f-41f5-9f86-63168089149a
:END:

Sometimes, particularly when we want to add multiple keyword arguments, the
argument list of =defhook= becomes so long that you have to split it up into a
newline. I hate how this looks and have a strong preference for keeping argument
lists on one line. To avoid this situation, I've added option for adding keyword
arguments before the body of the macro is useful.

Note the use of the argument name =ACTION=. I have diverged from =NAME= as used
in =defun= because the corresponding =defhook!= argument will *not* be the name
of the hook. It will be used in combination with the hook name to generate a
name as specified in Void naming conventions.

#+begin_src emacs-lisp
(defmacro defhook! (action args &rest body)
  "Drop-in replacement for `defhook'.
ACTION should be a symbol that denotes what the created hook does.
Unlike `defhook', this macro allows for multiple hooks to be passed in and it
also allows keyword arguments to be passed in before the body (and after the
docstring if there is one) of the function."
  (declare (doc-string 3))
  (let ((hook (car args))
        (hooks (-take-while (-not #'keywordp) (cdr args)))
        (specs (-drop-while (-not #'keywordp) args))
        (docstring (if (stringp (car body)) (pop body) nil))
        (keyword-args (->> body
                           (--unfold (when (keywordp (car it))
                                       (cons (-take 2 it) (cddr it))))
                           (-flatten-n 2)))
        (other-args body))
    `(progn
       ,(when hooks
          `(defhook! ,action ,(append hooks specs keyword-args)
             ,docstring
             ,@body))
       (defhook ,action ,(cons hook (append specs keyword-args))
         ,docstring
         ,@body))))
#+end_src

***** customize informational messages
:PROPERTIES:
:ID:       26783153-3517-4079-89d8-4bd862c52909
:END:

The messages =defhook= provides are informational but long and in complete
sentences. I customize this message so that it is concise and to the point.

#+begin_src emacs-lisp
(defadvice! replace-hook-done-message (fn hook &rest _)
  "Set `defhook-done' message to \"add FN to HOOK\"."
  :override defhook-done
  (void:log "add %s to %s" fn hook))
#+end_src

***** fix defhook-executed
:PROPERTIES:
:ID:       79b17411-b0d7-40c2-be6e-37d0e916baf9
:END:

Using my naming conventions for user-defined hooks, the hook function name will always
include the name of the hook variable it's attached to. For that reason, it's
redundant for me the full hook name. I'd prefer just the hook action and the
hook variable.

#+begin_src emacs-lisp
(defadvice! replace-hook-executed-message (fn hook &rest _)
  "Set `defhook-executed' message to \"HOOK -> FN-action\"."
  :override defhook-executed
  (alet (->> fn
             (symbol-name)
             (s-match (rx-to-string `(seq ,defhook-sym-desc-separator (group (1+ anything)))))
             (nth 1))
    (void:log "%s -> %s" hook it)))
#+end_src

***** font-lock
:PROPERTIES:
:ID:       2837b042-d93b-492e-8dd4-0e2c74f9a966
:END:

=defhook= was designed to resemble =defun= in syntax. To make the resemblance
complete I add the same type of syntax coloring to =defhook!=.

#+begin_src emacs-lisp
(defconst VOID:DEFHOOK-FONT-LOCK-KEYWORDS
  `((,(rx (group "defhook!") (1+ white) (group (1+ (not white))))
     (1 font-lock-keyword-face)
     (2 font-lock-function-name-face)))
  "Font lock keywords for `defhook!'.")

(defhook! add-defhook-keywords (emacs-lisp-mode-hook)
  "Add `defhook!' keywords to `emacs-lisp-mode'."
  (font-lock-add-keywords nil VOID:DEFHOOK-FONT-LOCK-KEYWORDS))
#+end_src

** Initialize
:PROPERTIES:
:ID:       6e1d0ef3-5a9b-4db4-b8f7-110e96f2d23e
:END:

*** defined in c source code
:PROPERTIES:
:ID:       873e6820-52f0-4b70-9992-ccb1610eb266
:END:

**** default settings
:PROPERTIES:
:ID: 8d578668-9b0b-4117-bf93-f556e970527b
:END:

#+begin_src emacs-lisp
(setq-default fringe-indicator-alist
              (delq (assq 'continuation fringe-indicator-alist)
                    fringe-indicator-alist))
(setq-default highlight-nonselected-windows nil)
(setq-default indicate-buffer-boundaries nil)
(setq-default inhibit-compacting-font-caches t)
(setq-default max-mini-window-height 0.3)
(setq-default mode-line-default-help-echo nil)
(setq-default mouse-yank-at-point t)
(setq-default resize-mini-windows 'grow-only)
(setq-default show-help-function nil)
(setq-default use-dialog-box nil)
(setq-default visible-cursor t)
(setq-default x-stretch-cursor nil)
(setq-default ring-bell-function #'ignore)
(setq-default visible-bell nil)
(setq-default window-resize-pixelwise t)
(setq-default frame-resize-pixelwise t)
#+end_src

**** compilation
:PROPERTIES:
:ID: 65c83b28-9bee-48fe-856a-f9c38f28c817
:END:

#+begin_src emacs-lisp
;; Non-nil means load prefers the newest version of a file.
(setq-default load-prefer-newer t)
#+end_src

**** all
:PROPERTIES:
:ID:       276d0193-5a46-4034-b145-f235178678d6
:END:

#+begin_src emacs-lisp
;; File name in which to write a list of all auto save file names.
(setq auto-save-list-file-name (concat VOID:DATA-DIR "autosave"))
;; Directory of score files for games which come with GNU Emacs.
(setq shared-game-score-directory (concat VOID:DATA-DIR "shared-game-score/"))

(setq-default cursor-in-non-selected-windows nil)

(setq highlight-nonselected-windows nil)

;; When non-nil, accelerate scrolling operations.
(setq fast-but-imprecise-scrolling t)

(setq-default frame-inhibit-implied-resize t)

;; Non-nil means use lockfiles to avoid editing collisions.
(setq-default create-lockfiles nil)
;; Non-nil says by default do auto-saving of every file-visiting buffer.
(setq-default history-length 500)
;; Specifies whether to use the system's trash can.
(setq-default delete-by-moving-to-trash t)

;; Disabling bidirectional text provides a small performance boost. Bidirectional
;; text is useful for languages that read right to left.
(setq-default bidi-display-reordering 'left-to-right)
(setq-default bidi-paragraph-direction 'left-to-right)

;; Non-nil means echo keystrokes after this many seconds. A value of zero means
;; don't echo at all.
(setq-default echo-keystrokes 0)

;; Template for displaying mode line for current buffer.
(setq-default mode-line-format nil)

(setq-default locale-coding-system VOID:DEFAULT-CODING-SYSTEM)
(setq-default buffer-file-coding-system VOID:DEFAULT-CODING-SYSTEM)
#+end_src

**** scrolling
:PROPERTIES:
:ID: 21e56e37-5ff8-40d8-9f27-c3a3ab37dfb8
:END:

#+begin_src emacs-lisp
(setq-default hscroll-margin 2)
(setq-default hscroll-step 1)
(setq-default scroll-conservatively 1001)
(setq-default scroll-margin 0)
(setq-default scroll-preserve-screen-position t)
#+end_src

***** spacing
:PROPERTIES:
:ID: 8b3f38f9-b789-43e3-b2c5-5152a67d2803
:END:

#+begin_src emacs-lisp
(setq-default fill-column 80)
(setq-default sentence-end-double-space nil)
(setq-default tab-width 4)
#+end_src

***** line wrapping
:PROPERTIES:
:ID: e1564e28-d2ab-4649-b18b-24c27b897256
:END:

#+begin_src emacs-lisp
(setq-default word-wrap t)
(setq-default indicate-empty-lines nil)
(setq-default indent-tabs-mode nil)
(setq-default truncate-lines t)
(setq-default truncate-partial-width-windows 50)
#+end_src

***** other
:PROPERTIES:
:ID: cd0aa7ad-97bc-48ec-9a09-8af56cbf6157
:END:

#+begin_src emacs-lisp
;; Non-nil means reorder bidirectional text for display in the visual order.
;; Disabling this gives Emacs a tiny performance boost.
(setq-default bidi-display-reordering nil)
(setq-default cursor-in-non-selected-windows nil)
(setq-default display-line-numbers-width 3)
(setq-default enable-recursive-minibuffers t)
(setq-default frame-inhibit-implied-resize t)
#+end_src

**** printing
:PROPERTIES:
:ID: 2dfce297-0f01-4576-ae5d-bb5856591ecb
:END:

When eval and replacing expressions, I want the printed result to express all
newlines in strings as =\n= as opposed to an actual newline. In fact, in general I
want any character to be expressed in =backslash + number or character= form. It
makes the strings more readable and easier to deal with.

Furthermore, I'd like printed lisp expressions to express quoted forms the way I
write them, with a ='= as opposed to the literal =(quote ...)=.

There comes a point when output is too long, or too nested to be usable. It's ok
to abbreviate it at this point.

#+begin_src emacs-lisp
(setq-default print-escape-newlines t)
(setq-default print-escape-multibyte t)
(setq-default print-escape-control-characters t)
(setq-default print-escape-nonascii t)
(setq-default print-length nil)
(setq-default print-level nil)
(setq-default print-quoted t)
(setq-default print-escape-newlines t)
#+end_src

*** OS
:PROPERTIES:
:ID: e3d140d2-77c3-46bd-b94d-ab7196190a67
:END:

**** =abbreviated-home-dir=
:PROPERTIES:
:ID: 345958e8-fb62-4b27-b30e-c4e8b69804cd
:END:

Emacs on windows often confuses =HOME= (=C:\Users\<NAME>=) and =APPDATA=, causing
[[hvar:abbreviate-home-dir][abbreviate-home-dir]] to produce incorrect paths.

#+begin_src emacs-lisp
(with-os! windows
  (setq abbreviated-home-dir "\\`'"))
#+end_src

**** font caches
:PROPERTIES:
:ID: 339f6b4b-424c-4057-b7ea-d44c69b0f9fb
:END:

Font compacting can be terribly expensive, especially for rendering icon
fonts on Windows. Whether it has a noteable affect on Linux and Mac hasn't
been determined.

#+begin_src emacs-lisp
(with-os! windows
  (setq inhibit-compacting-font-caches t))
#+end_src

**** windows performance
:PROPERTIES:
:ID: eda95bfe-8033-42f0-9038-11da6f9bd8fb
:END:

Reduce the workload when doing file IO.

#+begin_src emacs-lisp
(with-os! windows
  (setq w32-get-true-file-attributes nil))
#+end_src

**** unnecessary command line options
:PROPERTIES:
:ID: 0bfbc8e5-88f3-4e19-a9d5-bc610ce09bb2
:END:

Some command line options aren't necessary.

#+begin_src emacs-lisp
(with-os! (not linux)
  (setq command-line-x-option-alist nil))

(with-os! (not mac)
  (setq command-line-ns-option-alist nil))
#+end_src

**** windows
:PROPERTIES:
:ID: 8bd7f515-0e56-4195-a04a-5003625b2dae
:END:

#+begin_src emacs-lisp
(with-os! windows
  (setq w32-get-true-file-attributes nil)
  (when (display-graphic-p)
    (setenv "GIT_ASKPASS" "git-gui--askpass")))
#+end_src

**** mac                                                              :disabled:
:PROPERTIES:
:ID: e502d7e6-8b19-4300-a4fd-9a797df98402
:END:

***** defaults                                                        :disabled:
:PROPERTIES:
:ID: 8e4e5a73-5616-4aca-b939-5bad62e6c657
:END:

#+begin_src emacs-lisp
(with-os! mac
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier  'alt)
  ;; sane trackpad/mouse scroll settings
  (setq mac-redisplay-dont-reset-vscroll t)
  (setq mac-mouse-wheel-smooth-scroll nil)
  ;;  one line at a time
  (setq mouse-wheel-scroll-amount '(5 ((shift) . 2)))
  ;; don't accelerate scrolling
  (setq mouse-wheel-progressive-speed nil)
  (setq ns-use-native-fullscreen nil)
  ;; Don't open files from the workspace in a new frame
  (setq ns-pop-up-frames nil))
#+end_src

***** exec path from shell                                            :disabled:
:PROPERTIES:
:ID: 0cc48982-6a3e-40ee-9e95-3e21dae157b5
:END:


A known problem with GUI Emacs on MacOS (or daemons started via
launchctl or brew services): it runs in an isolated
environment, so envvars will be wrong. That includes the path
Emacs picks up. [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] fixes this.

#+begin_src emacs-lisp
(leaf exec-path-from-shell
  :os mac
  :when (or (daemonp) (display-graphic-p))
  :require t
  :setq
  (exec-path-from-shell-check-startup-files . nil)
  (exec-path-from-shell-arguments . (delete "-i" exec-path-from-shell-arguments))
  (exec-path-from-shell-debug . void:debug-p)
  :init
  (nconc! exec-path-from-shell-variables
    '("LC_CTYPE" "LC_ALL" "LANG"))
  (exec-path-from-shell-initialize))
#+end_src

***** ns-auto-titlebar
:PROPERTIES:
:ID: 751ae26b-d0ae-4af1-80a5-c2b0ae360367
:END:

[[https://github.com/purcell/ns-auto-titlebar][ns-auto-titlebar]] syncs ns frame parameters with theme and fixes mismatching text
color in the frame title.

#+begin_src emacs-lisp
(use-package! ns-auto-titlebar
  :os mac
  :when (or (daemonp) (display-graphic-p))
  :require t)
#+end_src

***** osx-clipboard
:PROPERTIES:
:ID: 6eb19c02-ce40-4aec-9124-a58a4389855f
:END:

#+begin_src emacs-lisp
(use-package! osx-clipboard
  :os mac
  :when (or (daemonp) (not (display-graphic-p)))
  :hook emacs-startup-hook)
#+end_src

**** linux
:PROPERTIES:
:ID: 122381a6-784b-4f56-a97e-8c1a2d18dcc0
:END:

#+begin_src emacs-lisp
(with-os! linux
  (setq x-underline-at-descent-line t)
  (setq x-gtk-use-system-tooltips nil))
#+end_src

*** void specific funtions
:PROPERTIES:
:ID: 1b49e07a-466f-41da-8b31-18c28421cf62
:END:

**** windows
:PROPERTIES:
:ID: 039a9070-2ba3-4e01-abd4-7bdb49cc5a3d
:END:

***** split-right-and-focus
:PROPERTIES:
:ID: 6cb60d94-723b-48e5-850a-3483e78f6647
:END:

#+begin_src emacs-lisp
(defun void/window-split-right-and-focus ()
  "Split window right and select the window created with the split."
  (interactive)
  (select-window (split-window-right)))
#+end_src

***** split-below-and-focus
:PROPERTIES:
:ID: d6a4a81f-007d-4b7e-97a3-e0bba3ff97a4
:END:

#+begin_src emacs-lisp
(defun void/window-split-below-and-focus ()
  "Split window below and select the window created with the split."
  (interactive)
  (select-window (split-window-below)))
#+end_src

**** all
:PROPERTIES:
:ID: e97267e8-fca8-4bf2-9899-7ec694e8a767
:END:

***** quit emacs without hook
:PROPERTIES:
:ID: b82f721c-39f5-4d41-bb0f-d4c391238eb4
:END:

Sometimes something goes wrong with [[helpvar:kill-emacs-hook][kill-emacs-hook]] and because of that I can't
close emacs. For that reason, I have this function.

#+begin_src emacs-lisp
(defun void/kill-emacs-no-hook ()
  "Kill emacs, ignoring `kill-emacs-hook'."
  (interactive)
  (when (yes-or-no-p "Quit without `kill-emacs-hook'?")
    (let (kill-emacs-hook) (kill-emacs))))
#+end_src

***** quit emacs brutally
:PROPERTIES:
:ID: 8753217c-4722-4183-bbb3-049707a37e54
:END:

I've never had to use this. But better be safe than sorry.

#+begin_src emacs-lisp
(defun void/kill-emacs-brutally ()
  "Tell an external process to kill emacs."
  (interactive)
  (when (yes-or-no-p "Do you want to BRUTALLY kill emacs?")
    (call-process "kill" nil nil nil "-9" (number-to-string (emacs-pid)))))
#+end_src

***** new emacs instance
:PROPERTIES:
:ID: eaf80ec3-2bd4-4f05-8a9c-fa525894a6fe
:END:

#+begin_src emacs-lisp
(defun void/open-emacs-instance ()
  "Open a new emacs instance in debug-mode."
  (interactive)
  (cond ((eq system-type 'darwin)
         (start-process-shell-command
          "emacs"
          nil "open -n /Applications/Emacs.app --args --debug-init"))
        ((eq system-type 'gnu/linux)
         (start-process "emacs" nil "emacs" "--debug-init"))))
#+end_src

***** kill all process of program
:PROPERTIES:
:ID: 913952e2-3727-4b38-aefc-4618c2771730
:END:

#+begin_src emacs-lisp
(defun void/kill-emacs-processes ()
  (interactive)
  (let ((count 1) (process "emacs"))
    (kill-process process)
    (while (ignore-errors (kill-process process))
      (setq process (format "emacs<%d>" count))
      (cl-incf count))
    (message "killed %d processes" count)))
#+end_src

***** qutebrowser
:PROPERTIES:
:ID: 77bace13-5af8-4974-981a-e07bf271182f
:END:

#+begin_src emacs-lisp
(defun void/open-qutebrowser ()
  "Open qutebrowser."
  (interactive)
  (start-process "qutebrowser" nil "qutebrowser"))
#+end_src

**** messages buffer
:PROPERTIES:
:ID: 7064ea0e-20e0-481c-9d07-18e4506ee3e8
:END:

In Emacs, messages. The messages buffer is where messages displayed at the bottom
of the Emacs frame are recorded after they expire.

#+begin_src emacs-lisp
(defun void/switch-to-messages ()
  (interactive)
  (select-window (display-buffer (get-buffer "*Messages*"))))
#+end_src

**** main org file
:PROPERTIES:
:ID: fb605553-f234-410a-b27e-697dc667831b
:END:

#+begin_src emacs-lisp
(defun void/switch-to-main-org-file ()
  (interactive)
  (find-file (concat VOID:EMACS-DIR "README.org")))
#+end_src

**** main todo file
:PROPERTIES:
:ID: 2accd21d-7316-4fa5-bd8f-8f40935ed621
:END:

#+begin_src emacs-lisp
(defun void/switch-to-todo-file ()
  (interactive)
  (switch-to-buffer (find-file VOID:TODO-FILE)))
#+end_src

**** turn on debug-mode
:PROPERTIES:
:ID: c1ac481a-6ebd-49ce-a930-3b0593283aee
:END:

#+begin_src emacs-lisp
(defun void/enable-debug-mode ()
  (interactive)
  (setq void:debug-p t))
#+end_src

**** switch to init file
:PROPERTIES:
:ID: 50c5e173-d737-4264-bac5-f13190d468dc
:END:

#+begin_src emacs-lisp
(defun void/switch-to-init-org-file ()
  "Switch to Void's init.el file."
  (interactive)
  (switch-to-buffer VOID:INIT-FILE))
#+end_src

**** quit emacs no prompt
:PROPERTIES:
:ID: d530718a-2b42-4e9b-8d7d-7813e0ae6381
:END:

#+begin_src emacs-lisp
(defun void/quit-emacs-no-prompt ()
  "Quit emacs without prompting."
  (interactive)
  (let (confirm-kill-emacs)
    (kill-emacs)))
#+end_src

*** post init
:PROPERTIES:
:ID: 0f1da89a-2278-4493-ba62-e2a334204be6
:END:

**** idle require
:PROPERTIES:
:ID:       c550f82a-9608-47e6-972b-eca460015e3c
:END:

This package.

#+begin_src emacs-lisp
(use-package! idle-require
  :require t
  :hook emacs-startup-hook
  :setq
  (idle-require-idle-delay . 7)
  (idle-require-load-break . 2))
#+end_src

**** =tty=
:PROPERTIES:
:ID: 63e351ad-9ef6-4034-9fca-861881c74d6a
:END:

When running emacs in terminal tty is *tremendously* slow.

#+begin_src emacs-lisp
(unless (display-graphic-p)
  (advice-add #'tty-run-terminal-initialization :override #'ignore)
  (defhook! init-tty (window-setup-hook)
    (advice-remove #'tty-run-terminal-initialization #'ignore)
    (tty-run-terminal-initialization (selected-frame) nil t)))
#+end_src

**** minibuffer
:PROPERTIES:
:ID: 83f47b4d-a0e2-4275-9c1a-7e317fdc4e41
:END:

[[helpvar:minibuffer-setup-hook][minibuffer-setup-hook]] and [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]] are the hooks run just before
entering and exiting the minibuffer (respectively). In the minibuffer I'll be
primarily doing searches for variables and functions. There are alot of
variables and functions so this can certainly get computationally expensive. To
keep things snappy I increase boost the [[helpvar:gc-cons-threshold][gc-cons-threshold]] just before I enter
the minibuffer, and restore it to it's original value a few seconds after it's closed.

It would take me forever to guess the name =minibuffer-setup-hook= from the
variable [[helpvar:minibuffer-exit-hook][minibuffer-exit-hook]]. If I knew the name =minibuffer-exit-hook= but did not
know what the hook to enter the minibuffer was, I'd probably
=minibuffer-enter-hook= because [[https://www.wordhippo.com/what-is/the-opposite-of/exit.html]["enter" is one of the main antonyms of "exit"]].
It'd take me forever to guess =startup=. Note that the only tricky thing about
this example.

At first I thought of =entry= but after more thought I realized
hook variables use action verbs in their names not nouns. So the =exit= in
=minibuffer-exit-hook= is actually the verb =exit= not the noun.

#+begin_src emacs-lisp
(defvaralias 'minibuffer-enter-hook 'minibuffer-setup-hook)

(defhook! boost-garbage-collection (minibuffer-enter-hook)
  "Boost garbage collection settings to `VOID:GC-CONS-THRESHOLD-MAX'."
  (setq gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX))

(defhook! defer-garbage-collection (minibuffer-exit-hook :append t)
  "Reset garbage collection settings to `void:gc-cons-threshold' after delay."
  (run-with-idle-timer 3 nil (lambda () (setq gc-cons-threshold VOID:GC-CONS-THRESHOLD))))
#+end_src

**** tangling
:PROPERTIES:
:ID: 3288c787-4b5c-4f0c-9d18-6f18afaf2b99
:END:

***** tangle hook
:PROPERTIES:
:ID: 549999d7-901b-4ab4-bdbe-81514b756ced
:END:

Void tangles itself just before quitting if [[helpfn:void-needs-tangling-p][void:needs-tangling-p]] returns true.
I tangle before quitting so I don't have to do it before startup. It's
preferable for quitting emacs to be slightly slower than for emacs startup to
be.

#+begin_src emacs-lisp
(defhook! tangle-on-quit-maybe (kill-emacs-hook :append t)
  "Tangle if `void:needs-tangling-p' returns t."
  (when (void:needs-tangling-p)
    (void/tangle-org-file)))
#+end_src

***** tangle asynchronously upon saving
:PROPERTIES:
:ID: 00298d4e-6b18-4203-874f-f5a877a5cabf
:END:

This is another attempt to keep my =main.el= file in sync as much as possible with
[[helpvar:VOID-README-FILE][void:main-org-file]]. ~void:tangle-on-save-h~ is called whenever a buffer is being
saved to a file. The reason why I use ~cl-letf~ to temporarily override [[helpfn:load][load]] is
because ~VOID:INIT-FILE~ already contains all the code I need so I don't want it
to waste time loading ~void:main-elisp-file~.

#+begin_src emacs-lisp
(defhook! tangle-maybe (after-save-hook)
  "Tangle `VOID:README-FILE' asynchronously when it is saved."
  (when (and (require 'async nil t)
             (string= (file-truename VOID:README-FILE)
                      (or (buffer-file-name (current-buffer)) ""))
             (void:needs-tangling-p))
    (async-start
     (lambda ()
       (let ((old-fn (symbol-function 'load))
             (user-init-file (concat user-emacs-directory "init.el")))
         (require 'cl)
         (cl-letf (((symbol-function 'load)
                    (lambda (file &rest args)
                      (when (string= user-init-file file)
                        (apply old-fn file args)))))
           (load user-init-file))))
     (lambda (_)
       (void:log
        (concat (if (void:needs-tangling-p) "✕ failed" "✓ succeeded")
                " tangling `VOID:README-FILE'."))))))
#+end_src

** UI
:PROPERTIES:
:ID: c21a5946-38b1-40dd-b6c3-da41fb5c4a5c
:END:

*** maybe get rid of UI elements
:PROPERTIES:
:ID: 3f466dd8-13f1-4160-a2a5-da1acd4f3d3e
:END:

Emacs 27 and above allows the user to customize the UI in =early-init.el=. For
easy backwards usage previous version of emacs (25 and 26) I include.

#+begin_src emacs-lisp
(when (version< emacs-version "27")
  (ignore-errors
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (menu-bar-mode -1)))
#+end_src

*** fullscreen
:PROPERTIES:
:ID: f0aad350-7da3-4350-8041-45bc5372ef7e
:END:

By default start emacs as fullscreen.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

*** hooks
:PROPERTIES:
:ID: ede94ae4-1c73-4435-81ba-e28070225b99
:END:

**** switching buffers
:PROPERTIES:
:ID: 55b1e136-2271-42e8-bad6-9c13fff33c31
:END:

***** switch buffer hook
:PROPERTIES:
:ID: 3be5191d-8525-4d03-90db-fc61c628ff57
:END:

#+begin_src emacs-lisp
(defvar void:after-switch-buffer-hook nil
  "A list of hooks run after changing the current buffer.")
#+end_src

***** inhibit switch buffer hook
:PROPERTIES:
:ID: d21029d7-31ca-49ff-b4c6-07e4a4678901
:END:

#+begin_src emacs-lisp
(defvar void:inhibit-switch-buffer-hooks nil
  "When non-nil, switch buffer hooks are inhibited.")
#+end_src

***** switching
:PROPERTIES:
:ID: ae5ad47f-9efe-4609-85fb-009d8685edc7
:END:

#+begin_src emacs-lisp
(defadvice! void:run-switch-buffer-hooks-a (orig-fn buffer-or-name &rest args)
  "Run `void:after-switch-buffer-hook'."
  :around (switch-to-buffer display-buffer)
  (let ((gc-cons-threshold most-positive-fixnum))
    (if (or void:inhibit-switch-buffer-hooks
            (eq (current-buffer) (get-buffer buffer-or-name))
            (and (eq orig-fn #'switch-to-buffer) (car args)))
        (apply orig-fn buffer-or-name args)
      (let ((void:inhibit-switch-buffer-hooks t))
        (when-let (buffer (apply orig-fn buffer-or-name args))
          (with-current-buffer (if (windowp buffer)
                                   (window-buffer buffer)
                                 buffer)
            (run-hooks 'void:after-switch-buffer-hook))
          buffer)))))
#+end_src

***** next previous
:PROPERTIES:
:ID: f69fe190-f134-46dc-baff-dcf42f1ab331
:END:

#+begin_src emacs-lisp
(defadvice! void:run-prev-or-next-buffer-hooks-a (orig-fn &rest args)
  :around (switch-to-next-buffer switch-to-previous-buffer)
  (let ((gc-cons-threshold most-positive-fixnum))
    (if void:inhibit-switch-buffer-hooks
        (apply orig-fn args)
      (let ((void:inhibit-switch-buffer-hooks t))
        (when-let (buffer (apply orig-fn args))
          (with-current-buffer buffer
            (run-hooks 'void:after-switch-buffer-hook)))))))
#+end_src

*** font
:PROPERTIES:
:ID: 893a1c9b-985b-4da8-9d9b-73028be5a2db
:END:

**** determine which font to use
:PROPERTIES:
:ID: 86cc1277-91ef-4a47-800b-8ec58cd8c6c6
:END:

I want Void to be flexible when choosing a font. I create a list of my preferred
fonts in =void:backup-fonts=. They are in order of most preferred to least
preferred. To compute the value of =void:font=, Void checks each of these fonts
in turn for the first available font. If none is availabe it just uses the
system font.

This process is time consuming (at least relative to the total emacs startup
time). But it benefits from byte-compilation.

#+begin_src emacs-lisp
(defvar void:backup-fonts
  '("Inconsolata-18" "Fira Code-18" "DejaVu Sans Mono-18"))

(defvar void:font "Courier 10 Pitch-18"
  "Default font for Void Emacs.
The font for Void is the first font in `void:backup-fonts' that's found in the
computer. If no font in `void:backup-fonts' is found then it uses the default
system font.")
#+end_src

**** specify =void:font= as default
:PROPERTIES:
:ID: 911e25ba-0893-487f-9f6b-8a574faf6f7d
:END:

The =default-frame-alist= is an alist of the default values for creating a
frame. So here I'm making the default font for all Emacs frames =void:font=.

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist (cons 'font void:font))
#+end_src

**** catch undefined fonts
:PROPERTIES:
:ID: e7c8fa94-5efa-462e-9302-57a6935a1c89
:END:

#+begin_src emacs-lisp
(defadvice! void:frame-notice-user-settings-a (orig-fn &rest args)
  "Try `void:font' followed each of `void:backup-fonts' until success.
If none of the fonts work, just use the default system font."
  :around frame-notice-user-settings
  (condition-case nil
      (progn (apply orig-fn args)
             (void:log "Font is: %s" (face-attribute 'default :font)))
    (error
     (if void:backup-fonts
         (progn
           ;; (push (cons err nil) void:init-errors)
           (void:log "Setting %s failed. Trying %s..." void:font (car void:backup-fonts))
           (setq void:font (pop void:backup-fonts))
           (add-to-list 'default-frame-alist (cons 'font void:font))
           ;; I want to call the function with advice in it.
           (apply #'frame-notice-user-settings args))
       (setq void:font (face-attribute 'default :font))
       (void:log "None of the backup-fonts worked, defaulting to: %s"
                 void:font)
       (add-to-list 'default-frame-alist (cons 'font void:font))
       (apply #'frame-notice-user-settings args)))))
#+end_src

**** size
:PROPERTIES:
:ID: 4bf24b65-6f23-4e42-930e-4d43f766545c
:END:

Face attribute height is a magnitude of 10 greater than what we typically
use as font sizes (eg. font-size 14 corresponds to a face-height of 140).
I want to make sure I don't input 14 thinking about font size (it's
happened before and it's a huge pain resetting the font-size when the
font is super small). Therefore, I check the code.

#+begin_src emacs-lisp
(defun void/set-font-size ()
  "Set the font size interactively."
  (interactive)
  (let* ((old-font-size (face-attribute 'default :height))
         (prompt "The font size is %d. What do you want to change it to? ")
         (font-size (string-to-number (read-string (format prompt old-font-size))))
         (digits (+ 1 (floor (log font-size 10)))))

    ;; Make the font-size be 3 digits (Do what I mean not what I say).
    (when (< digits 3)
      (setq font-size (* font-size (expt 10 (- 3 digits)))))
    (when (> digits 3)
      (setq font-size (/ font-size (expt 10 (- digits 3)))))

    ;; If font size is still doesn't make sense, ask me to make sure it's what I want.
    (if (or (< font-size 280)
            (y-or-n-p
             (format "You're choosing a pretty large font size: %d. Is this what you intended?)"
                     font-size)))
        (progn
          (set-face-attribute 'default nil :height font-size)
          (message "Your Font Size was %s. Font size is now: %s"
                   old-font-size
                   font-size))
      (message "Font Size has been cancelled."))))
#+end_src

*** theme
:PROPERTIES:
:ID: 2ac7c2fe-a2ba-4e55-a467-ff4af8850331
:END:

**** theme to load
:PROPERTIES:
:ID: cd085611-9e56-4df4-97dd-f087899562c0
:END:

#+begin_src emacs-lisp
(defvar void:theme 'one-light
  "The theme to load on startup.
The value of this variable is updated to the current theme whenever `load-theme'
is called.")

(setq custom-safe-themes t)
#+end_src

**** initialize at startup
:PROPERTIES:
:ID: 06b1f381-9066-4062-88d5-f376ad5d6df0
:END:

#+begin_src emacs-lisp
(defhook! set-theme (window-setup-hook)
  "Set the theme and load the font, in that order."
  (when (and void:theme (not (memq void:theme custom-enabled-themes)))
    (condition-case nil
        (load-theme void:theme t)
      (error (void:log "Could not load %s" void:theme)))))
#+end_src

**** loading theme
:PROPERTIES:
:ID: 7ae02d32-4652-494c-9e14-05f60ca60395
:END:

Sometimes there are things that need tidying up after loading a theme. For
example, if I'm using evil I need to update the cursor color.

#+begin_src emacs-lisp
(defvar void:after-load-theme-hook nil
  "Hook run after the theme is loaded with `load-theme'.")

(defadvice! void:run-after-load-theme-hook-a (theme &rest _)
  "Set up `void:load-theme-hook' to run after `load-theme' is called."
  :after load-theme
  (setq void:theme theme)
  (run-hooks 'void:after-load-theme-hook))
#+end_src

**** disable old themes first
:PROPERTIES:
:ID: 9d2f985b-8b0f-497f-982b-6f69c62179a9
:END:

Sometimes we end up with remants of the faces of old themes when we load a new
one. For this reason, I make sure to disable any enabled themes before applying
a new theme.

#+begin_src emacs-lisp
(defadvice! void:disable-old-themes-first-a (orig-fn &rest args)
  "Disable old themes before loading new ones."
  :around load-theme
  (mapc #'disable-theme custom-enabled-themes)
  (apply orig-fn args))
#+end_src

* Window Management
:PROPERTIES:
:ID: 29dbf899-17cd-4b00-aacb-090ccd20e133
:END:

Window management is one of the most important things to get right if you're
going to be efficient in emacs (that is unless you're using primarily frames
instead of windows).

** ace-window
:PROPERTIES:
:ID: b7cb25b4-ede8-4350-846c-d5c243a4a937
:END:

[[https://github.com/abo-abo/ace-window][ace-window]] uses avy to navigate windows in cases when there are many. There is
an alternative package for this, [[https://github.com/dimitri/switch-window][switch-window]]. The advantage of =switch-window=
is that the characters used for switching to a window are *really* easy to see,
but you can't see the buffer contents. That's a no-go for me I need to see them.

#+begin_src emacs-lisp
(use-package! ace-window
  :commands ace-window ace-swap-window
  :bind ([remap other-window] . ace-window)
  :setq
  (aw-keys . '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (aw-background . t))
#+end_src

** eyebrowse
:PROPERTIES:
:ID: 4ad6f8e6-0465-4d84-aa71-8848e69ccc5c
:END:

[[https://github.com/wasamasa/eyebrowse][eyebrowse]] is for managing workspaces. A workspace in Emacs a specific window
setup. It's for when you are doing some task let's say researching some
eyebrowse code and then you want to take a break and do something else but you
don't want to close all the nice windows you have up (and have to set them up
again later). You can create a new workspace with [[helpfn:eyebrowse-create-window-config][eyebrowse-create-window-config]]
and switch to it with [[helpfn:eyebrowse-next-window-config][eyebrowse-next-window-config]]. You can always go back to
your previous workspace now with [[helpfn:eyebrowse-prev-window-config][eyebrowse-prev-window-config]] or
[[helpfn:eyebrowse-switch-to-window-config][eyebrowse-switch-to-window-config]].

#+begin_src emacs-lisp
(use-package! eyebrowse
  :commands eyebrowse-create-window-config
  :setq (eyebrowse-wrap-around . t))
#+end_src

** window divider
:PROPERTIES:
:ID: 0bcebb71-f730-427f-9919-1538bd63456c
:END:

Emacs can add border to windows using a mode called [[helpfn:window-divider-mode][window-divider-mode]].
Often in emacs you have multiple windows displaying different buffers on the
screen. By default the border between these windows is very thin, so it can be
hard to distinguish windows sometimes. The point of adding borders to windows is
to distinguish them easily from one another.

*** window dividers
:PROPERTIES:
:ID: 849718ae-9d4a-43ab-b113-584aefa87c5b
:END:

Window dividers are useful in general so I don't get confused about when one
window ends and another begins (see [[helpfn:window-divider-mode][window-divider-mode]]). When using [[I like emacs][exwm]] it
makes emacs feel like a window manager with gaps.

#+begin_src emacs-lisp
(use-feature! frame
  :hook (window-setup-hook . window-divider-mode)
  :custom
  (window-divider-default-places       . t)
  (window-divider-default-bottom-width . 10)
  (window-divider-default-right-width  . 10)
  :config
  (set-face-foreground 'window-divider "black")
  (blink-cursor-mode -1))
#+end_src

*** update on theme change
:PROPERTIES:
:ID: 342bd557-889b-4dbd-8e76-5cd9da3b0f74
:END:

#+begin_src emacs-lisp
(defhook! update-window-divider (void:after-load-theme-hook)
  "Ensure window divider persists after theme change."
  (unless (bound-and-true-p window-divider-mode)
    (window-divider-mode 1)))
#+end_src

*** adjust window divider gap size
:PROPERTIES:
:ID:       5485c926-fac0-4e87-ae97-f7bf25d0a55c
:END:

**** TODO increase gap size
:PROPERTIES:
:ID:       867fad5c-b4d4-4cba-929e-0dc23f007c5b
:END:

Somtimes I might want to adjust this.

#+begin_src emacs-lisp
(defun frame:adjust-window-divider-size (amount)
  "Adjust the gap size of window-divider by AMOUNT."
  (general-setq window-divider-default-bottom-width
                (+ amount window-divider-default-bottom-width))
  (general-setq window-divider-default-right-width
                (+ amount window-divider-default-right-width)))
#+end_src

**** increase
:PROPERTIES:
:ID:       ebd6b013-6213-42a1-9e95-fefc7e7da991
:END:

#+begin_src emacs-lisp
(defun frame/increment-window-divider-size ()
  "Increase window divider size."
  (interactive)
  (frame:adjust-window-divider-size 1))
#+end_src

**** decrease
:PROPERTIES:
:ID:       6b1eb1cd-1cfd-4b82-a413-cb61fa13e0a4
:END:

#+begin_src emacs-lisp
(defun frame/decrement-window-divider-size ()
  "Decrease window divider size."
  (interactive)
  (frame:adjust-window-divider-size -1))
#+end_src

** transpose-frame
:PROPERTIES:
:ID: 5487535d-2534-4857-b1e0-c63b40917710
:END:

https://www.emacswiki.org/emacs/TransposeFrame

#+begin_src emacs-lisp
(use-package! transpose-frame
  :commands (transpose-frame
             flip-frame
             flop-frame
             rotate-frame
             rotate-frame-clockwise))
#+end_src

** exwm
:PROPERTIES:
:ID: dbb69880-2180-4ecc-897d-78ff72a6358b
:END:

[[https://github.com/ch11ng/exwm][EXWM]] (Emacs X-Window Manager) is a full-featured window manager in Emacs.
There are benefits and drawbacks to making emacs your window manager. One
benefit is that you get a super consistent window management experience. If you
use a typical window manager, you have to.

*** exwm
:PROPERTIES:
:ID: 18ee4dd8-445b-4101-adfb-ba8e18a71bb4
:END:

In fact, EXWM does not need to be loaded on startup. It is only needed when you
actually want to open another application such as a separate Emacs instance or
the web browser. This is great because EXWM actually does consume significant
startup time. Instead of loading =EXWM= immediately, I add advises to the
functions which open external linux applications.

#+begin_src emacs-lisp
(use-package! exwm
  :hook (exwm-mode-hook . hide-mode-line-mode)
  :before-call (void/open-qutebrowser counsel-linux-app void/open-emacs-instance)
  :setq (exwm-replace . nil)
  :defer-config
  (exwm-init)
  ;; Enable the clipboard.
  (require 'exwm-systemtray)
  (exwm-systemtray-enable))

(defhook! setup-hide-mode-line (exwm-mode-hook)
  (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
  (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line))
#+end_src

*** appropriate name for exwm buffers
:PROPERTIES:
:ID: b9712cdc-2cf9-482f-8f62-b2e4f56b9c97
:END:

#+begin_src emacs-lisp
(defhook! rename-buffer-to-title (exwm-update-title-hook)
  "Rename buffer to title."
  (exwm-workspace-rename-buffer exwm-title))
#+end_src

*** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

=EXWM= has two modes, =line-mode= and =char-mode=. It's best for Emacs and Next to
start with =char-mode= because they both have keys that are important for their
use (like =M-x=) which conflict with Emacs (the instance that's managing the
windows).

**** list of applications
:PROPERTIES:
:ID:       d1bf0601-a995-48f7-ab80-86755ba9269a
:END:

#+begin_src emacs-lisp
(defvar exwm:char-mode-apps (list "emacs" "next" "nyxt")
  "List of applications to exwm should start in char-mode.")
#+end_src

**** to start in char mode
:PROPERTIES:
:ID: 790c7f6e-6f66-4074-b51a-56b491bcde99
:END:

#+begin_src emacs-lisp
(defhook! start-in-char-mode (exwm-manage-finish-hook)
  "Start a program in char-mode if it's in `exwm:char-mode-apps'."
  (when (--any-p (string-prefix-p it exwm-instance-name) exwm:char-mode-apps)
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
#+end_src

*** keybindings
:PROPERTIES:
:ID: 293bc7c5-1320-4f3f-af2b-198d56694f71
:END:

#+begin_src emacs-lisp
(after! exwm
  (funcall (get 'exwm-input-global-keys 'custom-set)
           'exwm-input-global-keys
           `((,(kbd "s-R") . exwm-reset)
             (,(kbd "s-x") . exwm-input-toggle-keyboard)
             (,(kbd "s-h") . windmove-left)
             (,(kbd "s-j") . windmove-down)
             (,(kbd "s-k") . windmove-up)
             (,(kbd "s-l") . windmove-right)
             (,(kbd "s-t") . transpose-frame)
             (,(kbd "s-D") . kill-this-buffer)
             (,(kbd "s-b") . switch-to-buffer)
             (,(kbd "s-f") . find-file)
             (,(kbd "s-O") . exwm-layout-toggle-fullscreen)
             (,(kbd "s-p") . previous-buffer)
             (,(kbd "s-n") . next-buffer)
             (,(kbd "s-q") . void/open-qutebrowser)
             (,(kbd "s-e") . void/open-emacs-instance))))

(general-def
  "s-R" #'exwm-reset
  "s-x" #'exwm-input-toggle-keyboard
  "s-h" #'windmove-left
  "s-j" #'windmove-down
  "s-k" #'windmove-up
  "s-l" #'windmove-right
  "s-t" #'transpose-frame
  "s-D" #'kill-this-buffer
  "s-b" #'switch-to-buffer
  "s-f" #'find-file
  "s-O" #'exwm-layout-toggle-fullscreen
  "s-p" #'previous-buffer
  "s-n" #'next-buffer
  "s-q" #'void/open-qutebrowser
  "s-e" #'void/open-emacs-instance)
#+end_src

*** exwm-edit
:PROPERTIES:
:ID: 1a167827-b791-4a69-a90e-c2d30bd83abb
:END:

The dream is to do all text editing in Emacs. This package is a big step towards
achieving that dream. =exwm-edit= allows the user to edit text fields in
external packages with an emacs buffer. It acts a lot like =org-edit-src-code=:
it copies any text in the text field to a buffer, you edit the buffer, then
press a binding to insert the buffer text into the text field. It goes without
saying that when the text is in an emacs buffer, you can use the full-force of
Emacs's text editing capabilities on it.

#+begin_src emacs-lisp
(use-package! exwm-edit :after exwm)
#+end_src

*** exwm firefox
:PROPERTIES:
:ID:       a78eec54-687f-4a40-8c68-db096112ef52
:END:

#+begin_src emacs-lisp
(use-package! exwm-firefox-evil
  :disabled t
  :after exwm
  :hook (exwm-manage-finish-hook . exwm-firefox-evil-activate-if-firefox)
  :config
  (dolist (k `(escape))
    (cl-pushnew k exwm-input-prefix-keys)))
#+end_src

** buffer expose
:PROPERTIES:
:ID: df46e75c-0613-41e4-a4e4-a477f112adcb
:END:

#+begin_src emacs-lisp
(use-package! buffer-expose
  :commands (buffer-expose
             buffer-expose-no-stars
             buffer-expose-major-mode
             buffer-expose-dired-buffers
             buffer-expose-stars
             buffer-expose-current-mode)
  :setq
  (buffer-expose-show-current-buffer . t)
  (buffer-expose-rescale-factor      . 0.5)
  (buffer-expose-highlight-selected  . nil)
  (buffer-expose-max-num-windows     . 8)
  (buffer-expose-auto-init-aw        . t)
  (buffer-expose-hide-modelines      . nil)
  (buffer-expose-key-hint            . "")
  :bind
  (:buffer-expose-grid-map
   ("l" . buffer-expose-next-window)
   ("h" . buffer-expose-prev-window)
   ("L" . buffer-expose-next-page)
   ("H" . buffer-expose-prev-page)
   ("j" . buffer-expose-down-window)
   ("k" . buffer-expose-up-window)))
#+end_src

* Completion
:PROPERTIES:
:ID: 056384d1-a95a-4dcb-bc9d-ffe95bbb52a8
:END:

Completion has certainly become an integral part of any efficient workflow. One
commonality among things like searching emails, code-completing a word, surfing
the web is that in one way or another all of these things involve the suggestion
of likely candidates from a population that is too time consuming to look
through on our own. It's not much different in Emacs. We're constantly sifting
though files, buffers, commands, words--all to try to get through to the subset
of things that we actually want at this moment.

** snippets
:PROPERTIES:
:ID:       02dd54d0-f545-447e-89cf-c0cfcd941c76
:END:

*** defsnippet
:PROPERTIES:
:ID:       bfaa2631-a300-4f38-b31d-ec7457b18491
:END:

I find it painful to write and edit long one-liner snippets with lots of inner
elisp code. Additionally, I dislike having many different files for snippets. To
me it's a potential source of errors and it makes it so I have to go looking for
a snippet whenever I want to edit it.

These grievances have inspired me to write an API for writing snippet templates
in a declarative syntax as opposed to via a snippet file.

**** defsnippet

This is the user-facing function to define yasnippets.

#+begin_src emacs-lisp
(defun defsnippet:new-snippet (&rest plist)
  "Define a snippet."
  (-let (((&plist :name :mode :body :placeholders) plist)
         (keys '(:key :name :contributor :group :expand-env :binding :type :uuid)))
    (cl-assert (-none-p #'null (list name mode body)))

    (alet (append
           (list "# -*- mode: snippet -*-\n")
           (->> keys
                (--filter (plist-get plist it))
                (--map (format "# %s: %s\n" (void:keyword-name it) (plist-get plist it))))
           (list "# --\n")
           (list (defsnippet:compute-body body placeholders)))
      (with-temp-buffer
        (insert (string-join it "\n"))
        (yas-load-snippet-buffer mode)))))
#+end_src

**** compute body
:PROPERTIES:
:ID:       e6bbca2d-ee83-4cab-b115-9098bb0962c6
:END:

#+begin_src emacs-lisp
(defun defsnippet:compute-body (body placeholders)
  "Return the result of PLACEHOLDERS applied to BODY."
  (alet (-map (-lambda ((number name form))
                (if (eq '_  name)
                    (format "${%d:$$%S}" number form)
                  (format "${%d:%s$%S}" number name form)))
              placeholders)
    (apply #'format body it)))
#+end_src

**** list symbols
:PROPERTIES:
:ID:       56de420c-0cb7-47fb-ad34-c562047cd4fd
:END:

#+begin_src emacs-lisp
(defun defsnippet:list-symbols (&optional pred)
  "List interned symbols."
  (setq pred (or pred #'identity))
  (let (acc)
    (mapatoms (lambda (it)
                (when (and (symbolp it)
                           (not (eq 'nil it))
                           (funcall pred it))
                  (push it acc))))
    (nreverse acc)))
#+end_src

**** defsnippet!
:PROPERTIES:
:ID:       36e73e8a-86bb-4ab0-adc6-e6ff3e263237
:END:

This macro helps me define snippets declaratively without worrying about whether
yasnippet is loaded or not.

#+begin_src emacs-lisp
(defmacro defsnippet! (snippet &rest properties)
  "Syntactic sugar for defining a snippet on time."
  (declare (indent defun))
  `(after! yasnippet
     (defsnippet:new-snippet
       :name ,(void:to-string snippet)
       ,@properties)))
#+end_src

**** snippets
:PROPERTIES:
:ID:       a2fd6032-4c48-43c6-9afa-350dc74f47ac
:END:

It's really nice being able to re-evaluate a snippet with an elisp form as
opposed to going to the snippet buffer, editing it and reloading it.

***** org links
:PROPERTIES:
:ID:       df615fc9-cfac-4bed-b8ef-c5fcf57dffca
:END:

****** helpfn
:PROPERTIES:
:ID:       ca5d380a-05a9-4d74-8440-8e972d86661c
:END:

For extremely good documentation.

#+begin_src emacs-lisp
(defsnippet! help-function
  :key "hfn"
  :mode 'org-mode
  :body "[[helpfn:%s][$1]%s"
  :placeholders '((1 function (yas-auto-next (yas-choose-value (defsnippet:list-symbols))))
                  (0 _ (insert "]"))))
#+end_src

****** helpvar
:PROPERTIES:
:ID:       c1b65fb3-1d6f-4ec4-81b2-23d92e713332
:END:

#+begin_src emacs-lisp
(defsnippet! help-variable
  :mode 'org-mode
  :key "hvar"
  :body "[[helpvar:$1][%s]%s"
  :placeholders '((1 variable (->> (defsnippet:list-symbols #'helpful--variable-p)
                               (yas-choose-value)
                               (yas-auto-next)))
                  (0 _ (insert "]"))))
#+end_src

****** id
:PROPERTIES:
:ID:       84b143bb-cd83-4dd4-b0e1-264b7e2d4aaa
:END:

#+begin_src emacs-lisp
(defsnippet! org-id
  :mode 'org-mode
  :key "oid"
  :body "[[id:%s][#%s]$0"
  :placeholders '((1 _ (->> (hash-table-keys org-id-locations)
                        (yas-choose-value)
                        (yas-auto-next)))
                  (2 _ (substring (yas-field-value 1) 0 5))
                  (0 _ (insert "]"))))
#+end_src

***** elisp
:PROPERTIES:
:ID:       996f1990-991a-4cce-bfc9-629e52286ad6
:END:

****** defun
:PROPERTIES:
:ID:       ae185254-d541-42a8-acc9-c2907236a945
:END:

#+begin_src emacs-lisp
(defsnippet! defun
  :mode 'emacs-lisp-mode
  :key "dfn"
  :body "(defun %s (%s)\n  \"%s\"\n  %s)"
  :placeholders '((1 name)
                  (2 args)
                  (3 docstring (thread-first (rx-to-string `(or ,@(s-split "\s" (yas-field-value 2) t)))
                                (replace-regexp-in-string #'upcase yas-text)
                                (ignore-errors)))
                  (4 body)))
#+end_src

*** yasnippet
:PROPERTIES:
:ID: 1f362298-2b47-4929-9484-ce7f26f80adf
:END:

[[https://github.com/joaotavora/yasnippet][yasnippet]] is a template completion package. You can define templates which can
be inserted and interactively completed.

#+begin_src emacs-lisp
(use-package! yasnippet
  :hook (prog-mode-hook . yas-minor-mode-on)
  :setq
  (yas-snippet-dirs . (list (concat VOID:DATA-DIR "snippets/")))
  (yas-verbosity . (if void:debug-p 3 0))
  (yas-indent-line . 'auto)
  (yas-prompt-functions . '(yas-completing-prompt yas-ido-prompt))
  (yas-use-menu . nil)
  (yas-triggers-in-field . t)
  :defer-config
  (--each yas-snippet-dirs (mkdir it t))
  (delq #'yas-dropdown-prompt yas-prompt-functions)
  (after! smartparens
    ;; tell smartparens overlays not to interfere with yasnippet keybinds
    (advice-add #'yas-expand :before #'sp-remove-active-pair-overlay)))
#+end_src

*** snippet collection
:PROPERTIES:
:ID:       ceb066ac-2242-492d-9609-9e3b879b10b7
:END:

=yasnippet-snippets= is a collection of snippets.

#+begin_src emacs-lisp
(use-package! yasnippet-snippets
  :after yasnippet
  :init
  (awhen (-first (-partial #'s-contains-p "yasnippet-snippets") load-path)
    (push it yas-snippet-dirs)))
#+end_src

** selectrum
:PROPERTIES:
:ID:       4c384110-96fe-4d7a-8bcf-6592f4c9ad67
:END:

Selectrum is an investement. It doesn't have the support that completing
frameworks like ivy and helm has. However, it is coded more sanely and it is
more predictable. Additionally, it is minimal and lightweight meaning that you
won't have to worry about snappiness and performance.

*** selectrum
:PROPERTIES:
:ID:       eaf04d8c-0004-4ab1-8f85-b9520999eeb1
:END:

#+begin_src emacs-lisp
(use-package! selectrum
  :hook emacs-startup-hook
  :setq
  (selectrum-fix-minibuffer-height . t)
  (selectrum-should-sort-p . t)
  (selectrum-count-style . nil)
  (selectrum-num-candidates-displayed . 15))

(general-def '(insert emacs) selectrum-minibuffer-map
  "TAB" #'selectrum-next-candidate
  "C-k" #'selectrum-previous-candidate
  "C-j" #'selectrum-next-candidate
  "C-l" #'selectrum/mark-candidate
  [backtab] #'selectrum-previous-candidate)
#+end_src

*** selectrum prescient
:PROPERTIES:
:ID:       0aaa7e9f-4b78-43f8-91c3-168ea25ece63
:END:

This package manages remembering recently selected candidates.

#+begin_src emacs-lisp
(use-package! prescient
  :hook (selectrum-mode-hook . prescient-persist-mode)
  :setq
  (prescient-save-file . (concat VOID:DATA-DIR "prescient-save-file")))

(use-package! selectrum-prescient
  :hook selectrum-mode-hook
  :setq
  (selectrum-preprocess-candidates-function . #'selectrum-prescient--preprocess))
#+end_src

*** orderless
:PROPERTIES:
:ID:       8cb7b1af-3786-48b7-92ec-b21759bbabc3
:END:

This package provides an "orderless" completion style.

#+begin_src emacs-lisp
(use-package! orderless
  :init
  (defadvice! orderless:inhibit-filtering-and-highlighting (orig-fn &rest args)
    "Don't let `selectrum-prescient' filter or highlight.
Orderless will do this."
    :around selectrum-prescient-mode
    (let ((selectrum-refine-candidates-function selectrum-refine-candidates-function)
          (selectrum-highlight-candidates-function selectrum-highlight-candidates-function))
      (apply orig-fn args)))
  :setq
  (selectrum-refine-candidates-function . #'orderless-filter)
  (selectrum-highlight-candidates-function . #'orderless-highlight-matches))
#+end_src

*** utilities
:PROPERTIES:
:ID:       7fe34b0d-ad94-42ee-b206-e7b6af3dc17d
:END:

Many of these utilities come from the [[https://github.com/raxod502/selectrum/wiki/Useful-Commands#switching-buffers--files][selectrum wiki]].

**** select x-font function for ivy and selectrum
:PROPERTIES:
:ID: B32AD25F-FBBC-47B1-8BFE-701B31462405
:CREATED: [2020-09-03 Thu 10:29]
:END:

This version lets you choose different variants.

#+begin_src emacs-lisp
(defun void/set-font ()
  "Select xfont."
  (interactive)
  (set-frame-font (completing-read "Choose font: " (x-list-fonts "*"))))
#+end_src

**** TODO swiper
:PROPERTIES:
:ID:       7254902a-0caa-4f93-ba8e-13d3feae95b3
:END:

#+begin_src emacs-lisp
(defvar selectrum:swiper-history nil "Submission history for `selectrum-swiper'.")

(defun selectrum/swiper ()
  "Search for a matching line and jump to the beginning of its text.  Obeys narrowing."
  (interactive)
  (let* ((selectrum-should-sort-p nil)
         (gc-cons-threshold VOID:GC-CONS-THRESHOLD-MAX)
         (minimum-line-number (line-number-at-pos (point-min) t))
         (current-line-number (line-number-at-pos (point) t))
         (line-choices (->> (split-string (buffer-string) "\n")
                            (--map-indexed (unless (string-empty-p it)
                                             (format "L%d: %s" (+ it-index minimum-line-number) it)))
                            (-non-nil)))
         (chosen-line (completing-read "Jump to matching line: " line-choices
                                       nil t nil 'selectrum:swiper-history))
         (chosen-line-num (--> chosen-line
                               (s-match (rx "L" (group (+ digit)) ":") it)
                               (elt it 1)
                               (string-to-number it))))
    (push-mark (point) t)
    (forward-line (- chosen-line-num current-line-number))
    (beginning-of-line-text 1)))
#+end_src

**** TODO switch to buffer and recentf
:PROPERTIES:
:ID:       6f3e2870-d2f7-40d2-8fb7-d3709f3088c2
:END:

#+begin_src emacs-lisp
(defun selectrum/switch-buffer ()
  (interactive)
  (require 'f)
  (let* ((selectrum-should-sort-p nil)
         (other-buffers (->> (buffer-list)
                             (-remove-item (current-buffer))
                             (-map #'buffer-name)
                             (--remove (s-prefix-p " " it))))
         (buffer-file-paths (->> other-buffers
                                 (--map (buffer-file-name (get-buffer it)))
                                 (-non-nil)))
         (recentf-paths (--remove (-any-p (-partial #'string= (f-full it))
                                          buffer-file-paths)
                                  recentf-list)))
    (alet (completing-read "Select buffer: " (append other-buffers recentf-paths))
      (funcall (if (-contains-p recentf-list it)
                   #'find-file
                 #'switch-to-buffer)
               it))))

(general-def [remap switch-to-buffer] #'selectrum/switch-buffer)
#+end_src

**** mark candidate for completing-read-mutiple
:PROPERTIES:
:ID:       3b24f70f-3d35-478b-9657-fae5a8a67661
:END:

This saves us some time over tab completing and then adding the separator
ourselves.

#+begin_src emacs-lisp
(defun selectrum/mark-candidate ()
  "Mark candidate for completing-read-multiple."
  (interactive)
  (selectrum-insert-current-candidate)
  (insert crm-default-separator))
#+end_src

**** open app
:PROPERTIES:
:ID:       9a589a83-4898-4e19-b394-bf7e3d0a2f2a
:END:

#+begin_src emacs-lisp
(defun selectrum/open-app ()
  "Open an application I have installed."
  (interactive)
  (alet (completing-read-multiple "Open app: " ())
    (start-process)))
#+end_src

**** org
:PROPERTIES:
:ID:       efd47856-d461-4be7-b4a3-325d2a39c957
:END:

***** outline headlines
:PROPERTIES:
:ID:       cf57f0cb-a9f9-44e4-99ea-aab11a8a2097
:END:

#+begin_src emacs-lisp
(defun selectrum/org-outline-headings ()
  "Jump to an org heading using selectrum."
  (interactive)
  (let ((selectrum-should-sort-p nil)
        (org-outline-path-complete-in-steps)
        (org-goto-interface 'outline-path-completion))
    (org-goto)))
#+end_src

***** org select tags
:PROPERTIES:
:ID:       0b73aa11-f1a6-4d88-b7cd-35eef34b7f38
:END:

#+begin_src emacs-lisp
(defun selectrum/org-select-tags ()
  "Select tags to add to headline."
  (interactive)
  (let* ((current (org-get-tags (point)))
         (selected (completing-read-multiple "Select org tag(s): " (org-get-buffer-tags))))
    (alet (-uniq (append (-difference current selected)
                         (-difference selected current)))
      (org-set-tags it))))

(general-def [remap org-set-tags-command] #'selectrum/org-select-tags)
#+end_src

***** TODO select capture templates
:PROPERTIES:
:ID:       75aae139-a6b2-4517-b1f8-88cb2a1ac5fb
:END:

This is based on [[][counsel-org-capture]].

#+begin_src emacs-lisp
(defun selectrum/select-capture-template ()
  "Select capture template."
  (interactive)
  (let (prefixes)
    (alet (mapcan (lambda (x)
                    (let ((x-keys (car x)))
                      ;; Remove prefixed keys until we get one that matches the current item.
                      (while (and prefixes
                                  (let ((p1-keys (caar prefixes)))
                                    (or
                                     (<= (length x-keys) (length p1-keys))
                                     (not (string-prefix-p p1-keys x-keys)))))
                        (pop prefixes))
                      (if (> (length x) 2)
                          (let ((desc (mapconcat #'cadr (reverse (cons x prefixes)) " | ")))
                            (list (format "%-5s %s" x-keys desc)))
                        (push x prefixes)
                        nil)))
                  (-> org-capture-templates
                      (org-capture-upgrade-templates)
                      (org-contextualize-keys org-capture-templates-contexts)))
      (funcall #'org-capture nil (car (split-string (completing-read "Capture template: " it nil t)))) )))

(general-def org-mode-map [remap org-capture] #'selectrum/select-capture-template)
#+end_src

*** TODO embark
:PROPERTIES:
:ID:       e8cc7b06-19b4-4ade-a950-4bd2caf63dc1
:END:

Embark allows for using actions on candidates.

#+begin_src emacs-lisp
(use-package! embark
  :ensure (:host github :repo "oantolin/embark"))

(general-def '(insert emacs) selectrum-minibuffer-map "C-a" #'embark-act)

(defun refresh-selectrum ()
  (setq selectrum--previous-input-string nil))

(add-hook 'embark-pre-action-hook #'refresh-selectrum)

(setq embark-action-indicator
      (defun embark-which-key-setup ()
        (let ((help-char nil)
              (which-key-show-transient-maps t)
              (which-key-replacement-alist
               (cons '(("^[0-9-]\\|kp-[0-9]\\|kp-subtract\\|C-u$" . nil) . ignore)
                     which-key-replacement-alist)))
          (setq-local which-key-show-prefix nil)
          (setq-local which-key-persistent-popup t)
          (which-key--update)))
      embark-become-indicator embark-action-indicator)

(add-hook 'embark-pre-action-hook
          (defun embark-which-key-tear-down ()
            (kill-local-variable 'which-key-persistent-popup)
            (kill-local-variable 'which-key-show-prefix)
            (unless which-key-persistent-popup
              (which-key--hide-popup-ignore-command))))
#+end_src

** company
:PROPERTIES:
:ID: 436d68f7-09f1-470a-a730-fd79d9c183ee
:END:

*** company
:PROPERTIES:
:ID: 89fcd613-f7ea-461b-a91c-0d9a0ae28093
:END:

[[https://github.com/company-mode/company-mode][company]] offers code completion.

#+begin_src emacs-lisp
(use-package! company
  :hook prog-mode-hook
  :bind (:company-active-map
         ([tab] . company-select-next)
         ([backtab] . company-select-previous)
         ("C-k"     . company-select-previous)
         ("C-j"     . company-select-next))
  :setq
  (company-frontends . '(company-pseudo-tooltip-frontend))
  (company-tooltip-align-annotations . t)
  (company-show-numbers . t)
  (company-dabbrev-downcase . nil)
  (company-idle-delay . 0.15)
  (company-tooltip-limit . 14)
  (company-minimum-prefix-length . 1)
  (company-minimum-prefix-length . 1)
  (company-require-match . 'never))
#+end_src

*** backends
:PROPERTIES:
:ID: 976f3260-992a-44ee-af91-5eff0b398b20
:END:

[[helpvar:company-backends][company-backends]] is what you have to keep in mind when you're using
company. According to its documentation, =company-backends= contain
individual backends or groups of backends. This is important so it's
worth quoting here:

**** backends-alist
:PROPERTIES:
:ID: 1ca376a2-e92f-4b77-8a91-3c2d00c0c5b7
:END:

#+begin_src emacs-lisp
(defvar company:backend-alist
  '((text-mode :derived (company-dabbrev company-yasnippet company-ispell))
    (prog-mode :derived ((:separate company-capf company-yasnippet)))
    (conf-mode :derived (company-capf company-dabbrev-code company-yasnippet))
    (org-mode  :only (company-yasnippet)))
  "An alist matching modes to company backends.")
#+end_src

**** initialize a backend
:PROPERTIES:
:ID: 24288386-3600-4a23-90d1-d38f9862aca0
:END:

#+begin_src emacs-lisp
(defhook! setup-backends (after-change-major-mode-hook :eval-after company :local t)
  "Set `company-backends' for the current buffer."
  (when (and (bound-and-true-p company-mode)
             (not (eq major-mode 'fundamental-mode)))
    (set (make-local-variable 'company-backends) (company--backends+))))
#+end_src

**** get backends
:PROPERTIES:
:ID: 985f9898-2608-4aa2-8ee9-98a178a4d5e5
:END:

#+begin_src emacs-lisp
(defun company--backends+ ()
  "Compute company backends."
  (or
   (-when-let (((mode type backends) (assoc major-mode company:backend-alist)))
     (when (eq type :only) backends))
   (-mapcat (-lambda ((mode type backends))
              (when (or (and (eq type :derived) (derived-mode-p mode))
                        (and (eq type :exact)
                             (or (eq major-mode mode)
                                 (and (boundp mode) (symbol-value mode)))))
                backends))
            company:backend-alist)))
#+end_src

**** local hook
:PROPERTIES:
:ID: 49a1e8e6-c557-4a9c-9a3a-a1aa60f90924
:END:

#+begin_src emacs-lisp
(after! company
  (put 'company:init-backends-h 'permanent-local-hook t))
#+end_src

*** close company on escape
:PROPERTIES:
:ID: 750cc608-865e-4f69-a7b2-826fc66a7b71
:END:

#+begin_src emacs-lisp
(defhook! close-tooltip (void:escape-hook)
  "Close company tooltip."
  (when (and (boundp 'company-mode)
             (eq company-mode t))
    (company-abort)
    t))
#+end_src

*** company prescient
:PROPERTIES:
:ID: df21548a-c262-4802-8e76-71a3135789cb
:END:

[[https://github.com/raxod502/prescient.el][company-prescient]] is the same as =prescient= but for =company= instead of =ivy=.

#+begin_src emacs-lisp
(use-package! company-prescient :hook company-mode-hook)
#+end_src

* Email
:PROPERTIES:
:ID: b31fc41c-135d-45d9-9c05-5889d21d1cd4
:END:

In today's world communication is largely done via emails. Whether at work or at
school it's common to receive emails every day. In fact, you hear of people that
have 20,000+ emails in a particular account. Unsurprisingly, when we're getting
so many emails, it's easy to become overwhelmed. Fortunately, there are numerous
ways to read and send emails in Emacs.

** sendmail
:PROPERTIES:
:ID:       48c3332f-975d-4f22-94a8-4ccd394ca82a
:END:

#+begin_src emacs-lisp
(use-feature! sendmail
  :setq
  (send-mail-function . #'sendmail-send-it)
  (sendmail-program . (executable-find "msmtp"))
  (mail-specify-envelope-from . t))
#+end_src

** smtpmail
:PROPERTIES:
:ID: 4dc1e0a6-5441-4b3e-8b75-ed3626a59154
:END:

#+begin_src emacs-lisp
(use-feature! smtpmail
  :disabled t
  :setq
  (smtp-default-mail-server . "mail.example.com")
  (smtp-smtp-server . "mail.example.com")
  (smtpmail-smtp-service . 587)
  (smtpmail-debug-info . t))
#+end_src

** message
:PROPERTIES:
:ID:       4cf38804-18d6-470c-a9c3-e3327f2bebf9
:END:

#+begin_src emacs-lisp
(use-feature! message
  :setq
  (message-signature . user-full-name)
  (message-sendmail-envelope-from . 'header)
  (message-send-mail-function . #'sendmail-send-it)
  (message-kill-buffer-on-exit . t))
#+end_src

** mu4e
:PROPERTIES:
:ID: 1ec73e33-5b94-4199-976d-1d72f8fb5a8e
:END:

The most popular emacs mail client is =mu4e=. And, there is good reason why. =mu4e=
has many juicy features. Overall, =mu4e= is definitely a great mail client.
However, it's not all roses and rainbows; it does have a few annoying quicks.
One is that unlike virtually all other emacs packages it does not come decoupled
from =mu=. Another is that it is hard to set up multiple accounts properly despite
it's [[explicit support]] for multiple accounts. =mu4e= comes bundled with =mu=. A
significant advantage of using it is it's the most popular option and,
therefore, has the most support (in the form of setup blogs and packages).

*** mu4e
:PROPERTIES:
:ID: 565eff90-8626-4ec8-a576-4ff3dfb307ae
:END:

#+begin_src emacs-lisp
(use-package! mu4e
  :ensure nil
  :load-path "/usr/share/emacs/site-lisp/mu4e/"
  :commands mu4e
  :setq
  (mu4e-completing-read-function . #'completing-read)
  (mu4e-view-show-addresses . t)
  (mu4e-view-show-images . t)
  (mu4e-view-image-max-width . 800)
  (mu4e-compose-signature-auto-include . t)
  (mu4e-compose-format-flowed . t)
  (mu4e-get-mail-command . "mbsync -a")
  (mu4e-index-cleanup . t)
  (mu4e-index-lazy-check . nil)
  (mu4e-update-interval . 180)
  (mu4e-headers-auto-update . t)
  (mu4e-context-policy . 'pick-first)
  (mu4e-compose-context-policy . 'ask-if-none)
  (mu4e-confirm-quit . nil)
  (mu4e-header-fields . '((:human-date . 12)
                          (:flags . 4)
                          (:from . 25)
                          (:subject)))
  (mu4e-html2text-command . (if (executable-find "w3m") "w3m -dump -T text/html" #'mu4e-shr2text)))
#+end_src

*** TODO setup mu4e
:PROPERTIES:
:ID:       8ed2fe81-eda9-4343-a6e1-0a6a725866a4
:END:

#+begin_src emacs-lisp
(defun mu4e/init ()
  "Initialize mu4e."
  (interactive)
  (require 'password-store)
  (let ((email-dirs (--map (concat VOID:EMAIL-DIR it) (pass:email-list))))
    (when (or (not (-all-p #'f-exists-p email-dirs))
              (-some-p #'f-empty-p email-dirs))
      (message "creating directories that don't exist.")
      (--each email-dirs (mkdir it t))
      (shell-command (format "mu init -m %s" VOID:EMAIL-DIR))
      (message "Updating mail...")
      (mu4e-update-mail-and-index t))))
#+end_src

*** mu4e headers
:PROPERTIES:
:ID: 8b59c5bb-180c-461e-9b1a-4a0c95cb7671
:END:

#+begin_src emacs-lisp
(use-package! mu4e-headers
  :ensure nil
  :after mu4e
  :setq
  (mu4e-use-fancy-chars . t)
  (mu4e-headers-draft-mark     . (cons "D" (all-the-icons-faicon "pencil")))
  (mu4e-headers-flagged-mark   . (cons "F" (all-the-icons-faicon "flag")))
  (mu4e-headers-new-mark       . (cons "N" (all-the-icons-material "fiber_new")))
  (mu4e-headers-passed-mark    . (cons "P" (all-the-icons-faicon "arrow-right")))
  (mu4e-headers-seen-mark      . (cons "S" (all-the-icons-faicon "eye")))
  (mu4e-headers-attach-mark    . (cons "a" (all-the-icons-material "attach_file")))
  (mu4e-headers-replied-mark   . (cons "R" (all-the-icons-faicon "reply")))
  (mu4e-headers-unread-mark    . (cons "u" (all-the-icons-faicon "eye-slash")))
  (mu4e-headers-encrypted-mark . (cons "x" (all-the-icons-octicon "lock")))
  (mu4e-headers-signed-mark    . (cons "s" (all-the-icons-faicon "certificate")))
  (mu4e-headers-trash-mark     . (cons "T" (all-the-icons-faicon "trash"))))
#+end_src

*** org mu4e
:PROPERTIES:
:ID: 9045b0f5-af8c-481e-914e-a19c4bbf2941
:END:

Mu4e's org integration lets you write emails in org mode and convert it to html
before sending--very interesting indeed. I have yet to explore this feature but
it is definitely on my list of things to try out.

#+begin_src emacs-lisp
(use-package! org-mu4e
  :disabled t
  :hook (mu4e-compose-mode-hook . org-mu4e-compose-org-mode)
  :setq
  (org-mu4e-link-query-in-headers-mode . nil)
  (org-mu4e-convert-to-html . t)
  :defer-config
  ;; Only render to html once. If the first send fails for whatever reason,
  ;; org-mu4e would do so each time you try again.
  (defhook! org-mu4e-render-html-only-once (message-send-hook)
    (setq-local org-mu4e-convert-to-html nil)))
#+end_src

*** multiple accounts
:PROPERTIES:
:ID: ad6de3a4-674c-490f-841e-19b8f891cd65
:END:

Mu4e certainly gave me some trouble setting up multiple accounts despite [its
attempt] to make this easy. I have one directory =~/.mail= where which stores all
my mail. The subdirectories of =~/.mail= correspond to my individual email
accounts. Until I set multiple accounts correctly it keeps prompting me to
create folders (such as =sent/=) in the =~/.mail= directory. I think part of the
reason I spent so much time setting this up is because.

**** return the list of emails with credentials
:PROPERTIES:
:ID:       3f7b1728-b855-447f-9f15-43bd79a94c14
:END:

#+begin_src emacs-lisp
(defun pass:email-list ()
  "Return a list of emails."
  (->> (password-store-list)
       (--map (elt (s-match "email/\\(.*\\)" it) 1))
       (-non-nil)))
#+end_src

**** return the stuff as a plist
:PROPERTIES:
:ID:       8129ca16-8641-4f2f-a4b6-03477d5b78f3
:END:

#+begin_src emacs-lisp
(defun pass:email-account-plist (email)
  "Return a plist of the relevant values of an email."
  (shut-up!
    (->> (cdr (password-store-parse-entry email))
         (mapcar #'car)
         (--mapcat (list (intern it)
                         (password-store-get-field (concat "email/" email) it))))))
#+end_src

**** mu4e folder name alist
:PROPERTIES:
:ID:       2ef07842-e321-4fff-ae73-f19c41d263a4
:END:

Mu4e keeps prompting you for the sent, trash, and drafts directory if you do not
assign the corresponding mu4e variables. The way certain email servers name
their directories varies. For example, outlook names its sent directory as =Sent
Items=.

#+begin_src emacs-lisp
(defun mu4e:guess-folder (base-dir possible-name &rest other-possible-names)
  "Return the first file in BASE-DIR that matches POSSIBLE-NAME or any POSSIBLE-NAMES.
If there is no match, return POSSIBLE-NAME."
  (alet (or (--first (-some-p (-cut s-contains-p <> it t)
                              (cons possible-name other-possible-names))
                     (cddr (directory-files base-dir)))
            possible-name)
    (format "/%s/%s" (f-filename base-dir) it)))
#+end_src

**** set up contexts for single account
:PROPERTIES:
:ID:       66d460d7-9647-4c29-8348-eb7b3d571630
:END:

#+begin_src emacs-lisp
(defun mu4e::account-context (email)
  "Return an mu4e account context for specified EMAIL."
  (let* ((base-dir (concat VOID:EMAIL-DIR email "/"))
         (name (cl-second (s-match ".*@\\([^.]*\\)" email)))
         (account (pass:email-account-plist email))
         (out-host (plist-get 'out-host account))
         (out-port (plist-get 'out-port account)))
    (alet `((mu4e-sent-folder      . ,(mu4e:guess-folder base-dir "sent"))
            (mu4e-drafts-folder    . ,(mu4e:guess-folder base-dir "draft"))
            (mu4e-trash-folder     . ,(mu4e:guess-folder base-dir "trash" "delete" "junk"))
            (user-email-address    . ,email)
            (smtpmail-smtp-server  . ,out-host)
            (smtpmail-smtp-user    . ,base-dir)
            (smtpmail-smtp-service . ,out-port))
      (make-mu4e-context :name name :vars it))))
#+end_src

**** multiple contexts
:PROPERTIES:
:ID: e56b64ac-ed36-4689-b8f4-8711c1f4f79f
:END:

#+begin_src emacs-lisp
(defadvice! mu4e:initialize-all-contexts (&rest _)
  "Initiaize context for each email account."
  :before mu4e
  (require 'password-store)
  (--each (-map #'mu4e::account-context (pass:email-list))
    (cl-pushnew it mu4e-contexts)))
#+end_src

*** shortcuts
:PROPERTIES:
:ID: 565ce4bc-2cdb-4e1a-b871-e2d7d34137de
:END:

#+begin_src emacs-lisp
(defun mu4e/view-today-emails ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "date:today..now"))

(defun mu4e/view-shnu-account ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "to:luis.henriquez@snhu.edu"))

(defun mu4e/view-luishp-account ()
  (interactive)
  (mu4e t)
  (mu4e-headers-search "to:luis@luishp.xyz"))

(defun mu4e/view-gmail-account ()
  (interactive)
  (mu4e-headers-search "to:luishenriquezperez@gmail.com"))
#+end_src

*** bindings
:PROPERTIES:
:ID: 6b7e8206-24aa-485f-87e0-98a997936205
:END:

#+begin_src emacs-lisp
(general-def 'normal mu4e-headers-mode-map
  "q" #'kill-buffer-and-window
  "i" #'ignore
  "I" #'ignore
  "D" #'mu4e-headers-mark-for-delete
  "F" #'mu4e-headers-mark-for-flag
  "u" #'mu4e-headers-mark-for-unmark
  "x" #'mu4e-mark-execute-all
  "t" #'mu4e-headers-mark-for-trash
  "c" #'mu4e-compose
  "o" #'org-mu4e-compose-org-mode
  "s" #'mu4e-headers-search
  "r" #'mu4e-compose-reply
  "RET" #'mu4e-headers-view-message)

(general-def 'normal mu4e-view-mode-map
  "q" #'kill-buffer-and-window)

(define-localleader-key! mu4e-compose-mode-map
  "s" (list :def #'message-send-and-exit :which-key "send and exit")
  "d" (list :def #'message-kill-buffer :which-key "kill buffer")
  "S" (list :def #'message-dont-send :which-key "save draft")
  "a" (list #'mail-add-attachment :which-key "attach"))
#+end_src

*** truncate lines in messages
:PROPERTIES:
:ID: e6addd49-6aa4-4b9e-8e50-4f0ea43aedb7
:END:

#+begin_src emacs-lisp
(defhook! wrap-text-in-message (mu4e-view-mode-hook :eval-after mu4e)
  (setq-local truncate-lines nil))
#+end_src

** notmuch
:PROPERTIES:
:ID: 9bc1dad1-e2ec-4699-b471-a25b28aaaf26
:END:

Notmuch is probably the most elegant email solution of the three. It operates
purely on tags. Mu4e uses tags in the background but =notmuch= goes all out.
There's no concept of folders. A great thing about this is you avoid the
headache of Mu4e contexts because there is no such thing as a context to
=notmuch=. =notmuch= couldn't care less about how your emails are organized. Also,
=notmuch= is even faster than Mu4e when it comes to indexing email. Though this
probably won't be a significant practical difference unless you have *many*
emails.

*** bootstrap
:PROPERTIES:
:ID: e0cbf1d5-6e48-4a11-8f68-1151d2fc3e28
:END:

#+begin_src emacs-lisp
(use-package! notmuch
  :commands notmuch
  :setq
  (notmuch-search-oldest-first . nil)
  ;; Don't show notmuch logo.
  (notmuch-show-logo . nil)
  (notmuch-show-mark-read-tags . '("-unread")))
#+end_src

*** accounts
:PROPERTIES:
:ID: 5db186cb-8650-4be9-9b9a-9b001a951d35
:END:

I want this command to be a replacement to `notmuch'. Calling `notmuch'
displays an (ugly) intro screen. I find that most of the time I just want to
see my inbox, no questions asked.

#+begin_src emacs-lisp
(defun notmuch/display-inbox ()
  "Display the inbox."
  (interactive)
  (notmuch-search "tag:inbox" notmuch-search-oldest-first))

(defun notmuch/luishp-account ()
  (interactive)
  (notmuch-search "to:luis@luishp.xyz" notmuch-search-oldest-first))

(defun notmuch/luishenriquezperez-account ()
  (interactive)
  (notmuch-search "to:luishenriquezperez@gmail.com NOT tag:spam" notmuch-search-oldest-first))

(defun notmuch/snhu-account ()
  (interactive)
  (notmuch-search "to:luis.henriquez@snhu.edu"))
#+end_src

*** update mail
:PROPERTIES:
:ID: e98aae10-ae2f-479b-97b5-2a84a202e5fe
:END:

#+begin_src emacs-lisp
(defun notmuch/update ()
  (interactive)
  (start-process-shell-command
   "notmuch update" nil
   "mbsync -a && notmuch new")
  ;; (notmuch-tag "tag:new and folder:luishenriquezperez@gmail.com/spam" '("+spam" "-new" "-unread"))
  ;; tag new spam email as spam.
  ;; mark new email as new.
  )
#+end_src


** gnus                                                               :disabled:
:PROPERTIES:
:ID: d9ce252d-5f33-469b-a88c-84131f6f0eaa
:END:

Perhaps the least popular way of using emails is using gnus. It is actually how
[[][John Wiegley]], one of Emacs's maintainers, has managed his email for over
20 years. Gnus is really a mixed bag. One the one hand, I absolutely love the
fact that it's written in pure elisp (making it extremely customizable) and that
it's built-in to emacs. You can be on a completely different computer and set up
have a working client with just Emacs--that's pretty incredible. On the other
hand, the abstraction it is based on is extremely outdated making many of it's
variables and functions more difficult to understand (just by reading their
name) than normal; and it's pretty slow when dealing with many emails (by many I
mean 2000 which is not a lot by today's standard).

*** bootstrap
:PROPERTIES:
:ID: 80d3161d-0d0d-4c34-abf7-5ca12501f16c
:END:

#+begin_src emacs-lisp
(use-feature! gnus
  :commands gnus
  :setq
  (gnus-summary-line-format "%U%R%z %-16,16&user-date; %-30,30f  %B%S\n")
  (gnus-select-method . '(nnnil))
  (gnus-agent . t)
  (gnus-agent-article-alist-save-format . 1)
  (gnus-agent-cache . t)
  (gnus-agent-confirmation-function . 'y-or-n-p)
  (gnus-agent-consider-all-articles .  nil)
  (gnus-agent-directory . "~/News/agent/")
  (gnus-agent-enable-expiration . 'ENABLE)
  (gnus-agent-expire-all . nil)
  (gnus-agent-expire-days . 30)
  (gnus-agent-mark-unread-after-downloaded . t)
  (gnus-agent-queue-mail . t)
  (gnus-agent-synchronize-flags . nil))
#+end_src

*** gnus start
:PROPERTIES:
:ID: fe201237-301d-4b52-b24e-b16eb37aa31d
:END:

#+begin_src emacs-lisp
(use-feature! gnus-start
  :after gnus
  :setq
  (gnus-use-dribble-file . nil)
  (gnus-always-read-dribble-file . nil))
#+end_src

*** gnus sum
:PROPERTIES:
:ID: e16c4665-d404-49df-9cee-fec2a159e1c1
:END:

#+begin_src emacs-lisp
(use-package! gnus-sum
  :setq
  (gnus-user-date-format-alist . '(((gnus-seconds-today) . "Today at %R")
                                   ((+ 86400 (gnus-seconds-today)) . "Yest. at %R")
                                   (t . "%m-%d %R")))
  (gnus-sum-thread-tree-false-root . "")
  (gnus-sum-thread-tree-indent . " ")
  (gnus-sum-thread-tree-leaf-with-other . "├─➤ ")
  (gnus-sum-thread-tree-root . "")
  (gnus-sum-thread-tree-single-leaf . "└─➤ ")
  (gnus-sum-thread-tree-vertical . "│"))
#+end_src

*** accounts
:PROPERTIES:
:ID: 87d48ed6-cf36-4aa0-8d6d-1615ebb6a4cf
:END:

**** luis
:PROPERTIES:
:ID: fd91766f-36ec-4a13-ae90-44eaa930f58a
:END:

#+begin_src emacs-lisp
(ignore!
 (append! gnus-secondary-select-methods
   '(nnimap "luis"
     (nnimap-address "mail.luishp.xyz")
     (nnimap-stream ssl)
     (nnimap-authenticator 'login)
     (nnimap-log-command "pass"))))

(append! gnus-secondary-select-methods
  '(nnmaildir "luis"
    (directory "~/.mail/luis@luishp.xyz")))
#+end_src

**** snhu
:PROPERTIES:
:ID: 620f1fcd-e5c8-42b9-a117-87e704b188af
:END:

#+begin_src emacs-lisp
(ignore!
 (append! gnus-secondary-select-methods
   '(nnimap "school"
     (nnimap-address "outlook.office365.com")
     (nnimap-stream ssl)
     (nnimap-log-command "pass"))))

(append! gnus-secondary-select-methods
  '((nnmaildir "snhu"
     (directory "~/.mail/luis.henriquez@snhu.edu/"))))
#+end_src

**** gmail
:PROPERTIES:
:ID: a76bea4c-7922-4b63-9e74-d377eb943e88
:END:

#+begin_src emacs-lisp
(append! gnus-secondary-select-methods
  '(nnimap "gmail"
    (nnimap-address "imap.gmail.com")
    (nnimap-stream ssl)
    (nnimap-log-command "pass")))
#+end_src

*** gnus group
:PROPERTIES:
:ID: 1f022c0d-6157-4ba3-9676-860ef8c00258
:END:

#+begin_src emacs-lisp
(use-feature! gnus-group
  :setq
  (gnus-group-line-format . "%M\ %S\ %p\ %P\ %5y:%B%(%g%)\n"))
#+end_src

*** gnus art
:PROPERTIES:
:ID: 1642c04a-5332-484b-81e5-36bd16ca69a0
:END:

#+begin_src emacs-lisp
(use-package! gnus-art
  :after gnus
  :setq
  (gnus-article-browse-delete-temp . 'ask)
  (gnus-article-over-scroll . nil)
  (gnus-article-show-cursor . t)
  (gnus-article-sort-functions
   '(gnus-article-sort-by-most-recent-number
     gnus-article-sort-by-most-recent-date))
  (gnus-article-truncate-lines . nil)
  ;; (gnus-html-frame-width 80)
  ;; (gnus-html-image-automatic-caching t)
  (gnus-inhibit-images . t)
  (gnus-max-image-proportion . 0.3)
  (gnus-treat-display-smileys . nil)
  ;; (gnus-article-mode-line-format "%G %S %m")
  (gnus-visible-headers
   '("^From:" "^To:" "^Cc:" "^Newsgroups:" "^Subject:" "^Date:"
     "Followup-To:" "Reply-To:" "^Organization:" "^X-Newsreader:"
     "^X-Mailer:"))
  (gnus-sorted-header-list . gnus-visible-headers))
#+end_src

* Web Browsing
:PROPERTIES:
:ID: f0960e47-5dbb-4cca-a17a-f8eb0da445d3
:END:

In current times we are fortunate enough to have a wealth of information
available to us only a web search away.

** w3m
:PROPERTIES:
:ID: e5e13423-bc70-49b0-969e-94897c798d54
:END:

[[http://w3m.sourceforge.net/][w3m]] is a text-based web browser. There are many other text-based browsers out
there, but =w3m= has the benefit of having comprehensive [[https://github.com/emacs-w3m/emacs-w3m][emacs interface]]. Why
use this when you can use the GUI browser? Well, using the Emacs interface I can
view an Emacs webpage as plain text, which means I can perform searches on it
with [[][swiper]], or any other Emacs operation on it. Another advantage is that
because the w3m interface's backend is a terminal application, it will (I'm
guessing; no benchmarks made) typically be faster than browsers at rendering
plain text webpages. Of course, the main limitation is that w3m will typically
only display text based web pages well--not ones with lots of interactive
javascript code.

*** w3m
:PROPERTIES:
:ID: 10ddb49f-9280-49f4-8ca4-c46310d8a1dd
:END:

#+begin_src emacs-lisp
(use-package! w3m
  :commands w3m
  :setq (w3m-search-default-engine . "google"))
#+end_src

*** traversing
:PROPERTIES:
:ID: aded77d8-8088-4aad-b0b9-bb5a45d343f2
:END:

#+begin_src emacs-lisp
(general-def 'normal w3m-mode-map
  "o" #'w3m-search
  "O" #'w3m-search-new-session
  ;; Jump to a link with avy in the current session.
  "f" #'ace-link-w3m
  "F" #'ace-link-open-new-session
  ;; Delete the current emacs-w3m buffer and switch to the previous one.
  "D" #'w3m-delete-buffer
  ;; Move through tabs.
  "J" #'w3m-tab-move-right
  "K" #'w3m-tab-move-left
  ;; Move back COUNT pages in the history.
  "H" #'w3m-view-previous-page
  ;; Move forward COUNT pages in history.
  "L" #'w3m-view-next-page)
#+end_src

** browse-url
:PROPERTIES:
:ID: c705a76a-26a9-4956-915a-d6d2561fe923
:END:

Emacs's go-to function for browsing the web is stored in the variable
[[helpvar:browse-url-browser-function][browse-url-browser-function]].

#+begin_src emacs-lisp
(setq browse-url-browser-function #'browse-url-firefox)

(defun browse-url-firefox (url &optional _new-window)
  "Ask the Qutebrowser WWW browser to load URL.
Default to the URL around or before point.  The strings in
variable `browse-url-qutebrowser-arguments' are also passed to
Qutebrowser.
The optional argument NEW-WINDOW is not used."
  (interactive (browse-url-interactive-arg "URL: "))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply 'start-process
           (concat "firefox " url) nil
           (executable-find "qutebrowser")
           (append nil (list url)))))
#+end_src

** xwebkit                                                            :disabled:
:PROPERTIES:
:ID: b33151c3-e980-41d3-8656-350d514f9925
:END:

*** going to url                                                      :disabled:
:PROPERTIES:
:ID: 1079a7c8-e596-40d4-b86e-e916944e9030
:END:

#+begin_src emacs-lisp
(use-package! xwwp-follow-link
  :straight (:host github :repo "canatella/xwwp")
  :bind (:xwidget-webkit-mode-map
         ("v" . #'xwwp-follow-link))
  :setq (xwwp-follow-link-completion-system . 'ivy))
#+end_src

* Multimedia
:PROPERTIES:
:ID: 20a915a0-8525-413c-bd68-f1d5c14ce3da
:END:

I'm using "multimedia" here as an umbrella term for non-text sources of
information such as music, videos, images, and gifs.

** youtube
:PROPERTIES:
:ID: 10642631-365c-46b4-ad29-e28e509aa1ae
:END:

Youtube contains a *huge* library of videos.

*** ytdl
:PROPERTIES:
:ID:       27739f6e-9104-4e2f-b8e5-c8f56e5bb69b
:END:

=ytdl= is an emacs interface to youtube-dl.

#+begin_src emacs-lisp
(use-package! ytdl
  :setq
  (ytdl-downloads-folder . VOID:DOWNLOAD-DIR)
  (ytdl-music-folder . VOID:MUSIC-DIR)
  (ytdl-video-folder . (expand-file-name VOID:VIDEO-DIR))
  (ytdl-always-query-default-filename . nil)
  (ytdl-always-ask-delete-confirmation . t)
  (ytdl-always-query-default-filename . nil)  ;; :defer-config
  (ytdl-media-player . "mpv")
  (ytdl-max-mini-buffer-download-type-entries . 0)
  ;; (ytdl-add-field-in-download-type-list "Music" "p" (expand-file-name "~/podcasts") nil)
  )
#+end_src

*** ytel
:PROPERTIES:
:ID:       167bc712-5552-4cfe-83ce-d0bb9927fa6a
:END:

=ytel= is a YouTube search front-end. It is designed to let the user collect
YouTube search results into a buffer and manipulate them with emacs lisp.

#+begin_src emacs-lisp
(use-package! ytel
  ;; depends on curl (executable-find "curl")
  :commands ytel
  :defer-config
  (defun ytel/watch ()
    "Stream video at point in mpv."
    (interactive)
    (let* ((video (ytel-get-current-video))
     	   (id    (ytel-video-id video)))
      (start-process "ytel mpv" nil
		             "mpv"
		             (concat "https://www.youtube.com/watch?v=" id))
	  "--ytdl-format=bestvideo[height<=?720]+bestaudio/best")
    (message "Starting streaming...")))
#+end_src

** emms
:PROPERTIES:
:ID: 5d1abf3e-d0e5-4074-8d06-2b6eba47c6e4
:END:

[[https://www.gnu.org/software/emms/][emms]] is a very complete music player. https://github.com/daedreth/UncleDavesEmacs

*** emms
:PROPERTIES:
:ID: 5d28b703-a87f-47ca-b320-785e7589fea6
:END:

#+begin_src emacs-lisp
(use-package! emms
  :setq
  (emms-directory . (concat VOID:DATA-DIR "emms/"))
  (emms-seek-seconds . 5)
  (emms-player-list . '(emms-player-mpv))
  (emms-source-file-default-directory . VOID:MUSIC-DIR)
  (emms-source-file-directory-tree-function . 'emms-source-file-directory-tree-find)
  (emms-playlist-buffer-name . "*EMMS-PLAYLIST*")
  (mpc-host . "127.0.0.1:6600"))
#+end_src

*** quitting                                                          :disabled:
:PROPERTIES:
:ID: 545e6534-f289-4a89-838a-2a65ac74fe72
:END:

#+begin_src emacs-lisp
(defhook! quit-emms (kill-emacs-hook)
  "Shut down EMMS."
  (when emms-player-playing-p (emms-pause))
  (emms-stop)
  ;; kill any existing mpd processes
  (when (member 'emms-player-mpd emms-player-list)
    (call-process "killall" nil nil nil "mpd")))
#+end_src

** screenshot
:PROPERTIES:
:ID: 0038e1ed-ac6a-4529-9ecd-dfa8a44d40c9
:END:

Pictures or GIFs of behaviors can relate emacs behaviors in away descriptions
cannot. From my experience looking at posts on [[https://emacs.stackexchange.com/][emacs stackexchange]] or [[https://www.reddit.com/r/emacs/][emacs-reddit]] or
even other [[https://github.com/caisah/emacs.dz][emacs configs]], screenshots are underutilized (or often not
utilized at all). In Void, where documentation is *very* important, I supplement
my description of problems with pictures.

*** screenshot
:PROPERTIES:
:ID: c0975eae-c03b-4d2a-a546-06c05197eded
:END:

[[][]] is another emacs screenshot package that.

#+begin_src emacs-lisp
(use-package! screenshot :commands screenshot)
#+end_src

*** escr                                                              :disabled:
:PROPERTIES:
:ID:       06f23fc2-7f6b-4812-a14d-185b42a42976
:END:

#+begin_src emacs-lisp
(use-package! escr :disabled t)
#+end_src

*** scrot
:PROPERTIES:
:ID: 325935aa-b0f1-49b6-8c67-1173c5a1d42b
:END:

Like [[][screenshot]], [[https://github.com/dakra/scrot.el][scrot]] is screenshot taking utility. Interestingly, scrot
has a function that can capture a screenshot of a particular emacs window.

#+begin_src emacs-lisp
(use-package! scrot :ensure (:host github :repo "dakra/scrot.el"))
#+end_src

** gifs
:PROPERTIES:
:ID: 28387a67-7037-47ce-97c9-c35d77f7cb22
:END:

This package allows for the creation of gifs from within emacs.

#+begin_src emacs-lisp
(use-package! gif-screencast)
#+end_src

** keypression
:PROPERTIES:
:ID: 1943c432-4d47-43a5-ba92-2f17205bbae0
:END:

[[https://github.com/chuntaro/emacs-keypression][keypression]] is displays keypresses from within Emacs--no external tools
necessary! It [[https://raw.githubusercontent.com/wiki/chuntaro/emacs-keypression/images/screencast.gif][looks]] pretty professional!

#+begin_src emacs-lisp
(use-package! keypression
  :ensure (:host github :repo "chuntaro/emacs-keypression")
  :setq (keypression-frame-justify . 'keypression-right-justified))
#+end_src

* Text Editing
:PROPERTIES:
:ID: 42e0838f-f72a-43f3-8db2-a406d2d89adb
:END:

** highlight-numbers
:PROPERTIES:
:ID: d6e3227c-7678-47f0-95a8-3a6fda1638d6
:END:

What [[https://github.com/Fanael/highlight-numbers][highlight-numbers]] does is pretty self explanatory: it highlights numbers.

#+begin_src emacs-lisp
(use-package! highlight-numbers
  :hook (prog-mode-hook conf-mode-hook)
  :setq (highlight-numbers-generic-regexp . "\\_<[[:digit:]]+\\(?:\\.[0-9]*\\)?\\_>"))
#+end_src

** highlight-escape-sequences                                         :disabled:
:PROPERTIES:
:ID: 608d94c5-806f-4303-bb81-0b95a3dfcacc
:END:

Also pretty self explanatory is [[https://github.com/dgutov/highlight-escape-sequences][highlight-escape-sequences]].

#+begin_src emacs-lisp
(use-package! highlight-escape-sequences
  :ensure (:host github :repo "hlissner/highlight-escape-sequences")
  :hook (prog-mode-hook conf-mode-hook))
#+end_src

** hideshow
:PROPERTIES:
:ID: 915f65c3-8121-4480-b246-f190fe117950
:END:

Hiding text can be extremely useful. It is something that's used extensively in
Org Mode. The feature responsible for doing this is [[][hideshow]].

#+begin_src emacs-lisp
(use-package! hideshow
  :hook (prog-mode-hook . hs-minor-mode)
  :commands hs-minor-mode hs-toggle-hiding hs-already-hidden-p
  :setq (hs-hide-comments-when-hiding-all . nil))
#+end_src

** rainbow-delimiters
:PROPERTIES:
:ID: c771a943-593f-4119-8754-9d7e5da4466b
:END:

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] colors parentheses different colors based on level. This is a
great idea! It makes it really easy to see which parentheses go together.

#+begin_src emacs-lisp
(use-package! rainbow-delimiters
  :hook (prog-mode-hook reb-mode-hook)
  :setq (rainbow-delimiters-max-face-count . 9))
#+end_src

** edit-indirect
:PROPERTIES:
:ID: 82e6a83b-f238-46e1-bcc2-a23bddf412be
:END:

Edit indirect is a package that allows me to edit a region from one buffer in a
different buffer. If know about [[info:org#Summary][org-mode]] and [[info:org#Working with Source Code][source blocks]], this should
sound familiar. There are two major reasons for me why doing this kind of
editing has advantages over just editing the original buffer as is. One is that
it eases cognitive effort by allowing you to focus on one bite-sized region of a
buffer instead the whole thing. The second is that it allows you apply
specialized modes to a region that may not be appropriate for the buffer as a
whole. I use this package for editing source blocks instead of [[helpfn:org-edit-src-code][org-edit-src-code]]
mainly for consistency.

*** edit-indirect
:PROPERTIES:
:ID: 4da94b9a-9e3b-4e3b-8f56-d574969cb812
:END:

#+begin_src emacs-lisp
(use-package! edit-indirect
  :before-call (org/edit:description-at-point org/dwim-edit-source-block)
  :popup ("\\*edit-indirect"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (slot . 10)))
#+end_src

*** list of headline elements
:PROPERTIES:
:ID: 3d77c526-1061-4a91-998b-06b4c3d5b48b
:END:

Striving to edit org buffers as functionally as possible as opposed to using
side-effects is very important. It makes code easier and less error prone to
write because you deal with actual lisp object as opposed to less tangible
buffer text. It also makes code easier to debug because you can test for the
correctness of values returned as opposed to the state change of the buffer.

#+begin_src emacs-lisp
(cl-defun org:element-headline-elements ()
  "Return the list of org elements from the current headline to the next."
  (save-excursion
    (unless (org-at-heading-p) (org-back-to-heading))
    (unless (org-at-heading-p) (cl-return))
    (cons (org-element-at-point)
          (ignore-errors
            (org-down-element)
            (--unfold (when (ignore-errors (org-forward-element))
                        (cons it (org-element-at-point)))
                      (org-element-at-point))))))
#+end_src

*** editing headline descriptions
:PROPERTIES:
:ID: 84867fc3-0808-437a-8037-5ab8e2e2b24e
:END:

As I've [[][mentioned]], Org mode provides syntax to systematically delineate
different languages from one another. Editing the contents of these languages is
typically done through the use of [[helpfn:org-edit-src-code][org-edit-src-code]] (although I do it via
[[helpfn:edit-indirect-region][edit-indirect-region]]). =org-edit-src-code= provides a convenient and elegant way
to edit these languages. It pop open a buffer with the contents of the source block.

However, as I will argue there's one "language" which does not require source
block syntax separation in org mode and that is plain text. In org mode, plain
prose is typically utilized to describe the contents of a headline just as I'm
doing right now. While (I think at least) it is technically not differentiated
from org mode syntax.

However, org mode does not go far enough. If you think about it descriptions
under headlines are also in a "different language"--they're in plain prose. And
this is different from org-mode syntax. They utilize a different editing style
and require different modes from org-mode.

**** whether an element is a paragraph
:PROPERTIES:
:ID: 8f23f8e6-cd9e-4da2-872d-8413fbe2773b
:END:

This function isn't necessary. However, it's very convenient to abbreviate ~(eq
(org-element-type elt) 'paragraph)~--more so because it's a check I perform all
the time.

#+begin_src emacs-lisp
(defun org:element-paragraph-p (element)
  "Return non-nil if the current element is a paragraph."
  (eq (org-element-type element) 'paragraph))
#+end_src

**** point in org element
:PROPERTIES:
:ID: 73a096e6-93d2-4c68-b02f-c31e66cfece5
:END:

#+begin_src emacs-lisp
(defun org:element-contains-point-p (point element)
  "Return t if POINT is inside ELEMENT."
  (and (>= point (org-element-property :begin element))
       (>= (org-element-property :end element) point)))
#+end_src

**** paragraph bounds
:PROPERTIES:
:ID: a049f3ec-8936-499b-af03-e6f4be22163b
:END:

#+begin_src emacs-lisp
(defun org:edit-desc-bounds (point elements)
  "Return the bounds of the description at point.
ELEMENTS is a list of headline elements (see `org:element-headline-elements')."
  (awhen (-find (-some-p (-partial #'org:element-contains-point-p point) it)
                (->> (cdr elements)
                     (-group-by #'org:element-paragraph-p)
                     (-filter (-compose #'org:element-paragraph-p #'car))))
    (cons (org-element-property :contents-begin (-first-item it))
          (org-element-property :contents-end (-last-item it)))))
#+end_src

**** org edit description at point
:PROPERTIES:
:ID: d37dd016-d5ec-4524-974d-d157bba231fc
:END:

#+begin_src emacs-lisp
(defun org/edit:description-at-point ()
  "Edit the description at point."
  (interactive)
  (-when-let ((beg . end) (org:edit-desc-bounds (point) (org:element-headline-elements)))
    (edit-indirect-region beg end t)))
#+end_src

**** dwim paragraph bounds
:PROPERTIES:
:ID: 8c321bbc-d6ee-42d6-90f5-ff8b9106c51b
:END:

I don't want to have to travel to a description to edit it. Ideally, I'd like to
travel to anywhere I need within a heading from the headline itself.

#+begin_src emacs-lisp
(defun org:dwim-description-bounds (point elements)
  "Return bounds description under headline as a cons cell.
If there is no description element, return a cons cell containing the the point
where the point should go."
  ;; There are no paragraph elements.
  (acond ((-any-p #'org:element-paragraph-p elements)
          (alet (->> elements
                     (-partition-by #'org:element-paragraph-p)
                     (-filter (-compose #'org:element-paragraph-p #'-first-item))
                     (-first-item))
            (cons (org-element-property :contents-begin (-first-item it))
                  (org-element-property :contents-end (-last-item it)))))
         ;; Is there a source block?
         ((--first (eq (org-element-type it) 'src-block) elements)
          (cons (org-element-property :begin it)
                (org-element-property :begin it)))
         ;; Insert it after the last headline element.
         ((org-element-property :end (-last-item elements))
          (cons it it))))
#+end_src

**** maybe add newlines
:PROPERTIES:
:ID: 476da722-8530-4652-821d-77cdd4869680
:END:

Edit indirect has two hooks (four if you include == ==). This is great! The
problem is that you will likely use =edit-indirect= for various different
things. And for these different things, you might want to use different hooks
(i.e. a hook for editing a comment in an =edit-indirect= buffer might not be
appropriate for editing a source block.) You don't want the hooks stepping over
eachother.

The best way I could think of achieving this is through temporary or transient
hooks.

#+begin_src emacs-lisp
(defun edit:indirect-add-newlines-maybe-h ()
  "Add newlines to edit-indirect buffer before commiting."
  (when (aand edit-indirect--overlay
              (= (overlay-start it) (overlay-end it)))
    (add-hook 'edit-indirect-before-commit-hook
              (lambda ()
                ;; (not (string-match-p "\\(?:[[:space:]]\\|\n\\)+" (buffer-string)))
                (goto-char (point-max)) (insert "\n\n"))
              0
              :local)))
#+end_src

**** dwim edit description
:PROPERTIES:
:ID: b409f0d6-c681-4554-9ee5-2a303bd613b3
:END:

#+begin_src emacs-lisp
(defun org/dwim-edit-description ()
  "Edit a description the way I want to."
  (interactive)
  (-let* ((elements (org:element-headline-elements))
          ((beg . end) (org:dwim-description-bounds (point) elements))
          (edit-indirect-guess-mode-function (lambda (&rest _) (text-mode)))
          (edit-indirect-after-creation-hook edit-indirect-after-creation-hook))
    (edit-indirect:add-before-commit-hook #'edit-indirect:ensure-newline)
    (general-add-hook 'edit-indirect-after-creation-hook
                      ;; Move point to last non-whitespace character.
                      (list (lambda ()
                              (end-of-buffer)
                              (ignore-errors (re-search-backward (rx (or white "\n")))))
                            #'evil-insert-state))
    (edit-indirect-region beg end t)))
#+end_src

**** org link minor mode
:PROPERTIES:
:ID: 7af9c8bb-f3ad-43a1-8c9b-aeac6a4fdb36
:END:

#+begin_src emacs-lisp
(use-package! org-link-minor-mode
  :commands org-link-minor-mode)
#+end_src

*** editing source blocks
:PROPERTIES:
:ID: c6269fa0-936c-4daf-8803-a4caea3955ef
:END:

Why use this package to edit source blocks when there's already an org function
which does it? One reason is consistently. Eventually, I want all separate
editing buffers to be from =edit-indirect=. That why I don't have to configure
both =edit-indirect= and org source block function to work the way I want; I can
deal with just one source.

**** add before commit hook
:PROPERTIES:
:ID:       ab108485-1978-4bfd-9329-cc29035399d2
:END:

#+begin_src emacs-lisp
(defun edit-indirect:add-before-commit-hook (fn)
  "Add FN."
  (add-hook 'edit-indirect-after-creation-hook
            `(lambda ()
               (add-hook 'edit-indirect-before-commit-hook #',fn nil t))))
#+end_src

**** prevent ending with no newline
:PROPERTIES:
:ID: 9ac56ec5-5fbd-4b5c-bd24-eac81b3b196b
:END:

=edit-indirect= buffers with source block contents must end in a newline
otherwise the =#+end_src= code block delimiter will not end up in its own line
(see this for example).

#+begin_src emacs-lisp
(defun edit-indirect:ensure-newline (&optional block-was-empty-p)
  "Ensure that source block ends with a newline.
If the source block was initially empty and no content was added, don't add a newline.
Otherwise, add a newline if there isn't one."
  (save-excursion
    (when (and (not (string-match-p (rx (* anything) "\n" eos) (buffer-string)))
               (not block-was-empty-p))
      (goto-char (point-max))
      (insert "\n"))))
#+end_src

**** edit source block at point
:PROPERTIES:
:ID: 786a9971-d0de-4a1a-81e8-82617bdfe88e
:END:

#+begin_src emacs-lisp
(defun org/edit-source-block-at-point ()
  "Edit the source block at point."
  (interactive)
  (alet (org-element-context)
    (when (or (null it) (not (eq 'src-block (org-element-type it))))
      (user-error "No element at point."))
    (-let* (((beg end) (org-src--contents-area it))
            (lang (plist-get (-second-item it) :language))
            (edit-indirect-guess-mode-function `(lambda (&rest _) (funcall (org-src-get-lang-mode ,lang))))
            (edit-indirect-after-creation-hook edit-indirect-after-creation-hook))
      (add-hook 'edit-indirect-after-creation-hook #'edit-indirect:ensure-newline)
      (add-hook 'edit-indirect-after-creation-hook #'beginning-of-buffer)
      (edit-indirect-region beg end t))))
#+end_src

**** dwim edit source block
:PROPERTIES:
:ID: 195b3fdf-4bea-40e7-9ad2-3621e4de3ddb
:END:

I want to be able to edit a source block without actually going to the source
block.

#+begin_src emacs-lisp
(defun org/dwim-edit-source-block ()
  "Edit the source block."
  (interactive)
  (unless (org-in-src-block-p)
    (aif (--first (eq (org-element-type it) 'src-block)
                  (org:element-headline-elements))
        (goto-char (org-element-property :begin it))
      (user-error "No source at headline.")))
  (org/edit-source-block-at-point))
#+end_src

*** bindings inside edit-indirect
:PROPERTIES:
:ID: 42992d1e-5d65-4570-ba96-02b3be31b97b
:END:

I want quick, convenient bindings I can use to abort or commit (which is
=edit-indirect= lingo for writing the contents of the buffer back into its source
file, see [[helpfn:edit-indirect-commit][edit-indirect-commit]].

#+begin_src emacs-lisp
(define-localleader-key! edit-indirect-mode-map
  "," #'edit-indirect-commit
  "c" #'edit-indirect-commit
  "a" #'edit-indirect-abort)
#+end_src

*** org bindings
:PROPERTIES:
:ID: cc9b15f0-3abe-4189-b43b-a70b1f4b215f
:END:

#+begin_src emacs-lisp
(after! (evil edit-indirect)
  (evil-make-overriding-map edit-indirect-mode-map 'normal))

(define-localleader-key! org-mode-map
  "d" #'org/dwim-edit-description
  "e" #'org/dwim-edit-source-block)
#+end_src


** spacing and indentation
:PROPERTIES:
:ID: 4f5e0d70-fe6d-4dda-8949-8154464160e1
:END:

*** aggressive-indent
:PROPERTIES:
:ID: f1b9a36e-26e4-4305-99ae-cbcf6a90013d
:END:

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] indents portions of the text your working on as your typing
it. It's pretty smart and very convenient.

#+begin_src emacs-lisp
(use-package! aggressive-indent :hook emacs-lisp-mode-hook)
#+end_src

*** electric indent
:PROPERTIES:
:ID: 4f7e6aa4-be34-4cdd-a2a8-63df24da44a1
:END:

#+begin_src emacs-lisp
(use-package! electric
  :config
  (electric-indent-mode -1))
#+end_src

*** ws-bulter
:PROPERTIES:
:ID: 7e0c30ea-a109-4176-a92b-4a1de4922032
:END:

[[https://github.com/lewang/ws-butler][ws-butler]] cleans up whitespace.

#+begin_src emacs-lisp
(use-package! ws-butler
  :hook (prog-mode-hook org-mode-hook)
  :defer-config
  (append! ws-butler-global-exempt-modes
    '(special-mode comint-mode term-mode eshell-mode)))
#+end_src

*** ialign
:PROPERTIES:
:ID: 55570266-36e8-426e-aef6-5005bce6d73b
:END:

Package [[https://github.com/mkcms/interactive-align][ialign]] lets me use regular expressions to align text.

#+begin_src emacs-lisp
(use-package! ialign :commands ialign)
#+end_src

** lisp editing
:PROPERTIES:
:ID: f616348a-ba44-44f6-aeb6-3dc0a312143e
:END:

*** smartparens
:PROPERTIES:
:ID: 17257f23-c45e-4b7b-a3b4-7fd2333edf4d
:END:

**** bootstrap
:PROPERTIES:
:ID: f1c64411-ad51-4c24-8dad-b4aa7b8fc3b5
:END:

#+begin_src emacs-lisp
(use-package! smartparens
  :hook (prog-mode-hook eshell-mode-hook ielm-mode-hook)
  :setq
  (sp-highlight-pair-overlay . nil)
  (sp-highlight-wrap-overlay . nil)
  (sp-highlight-wrap-tag-overlay . nil)
  (sp-show-pair-from-inside . t)
  (sp-cancel-autoskip-on-backward-movement . nil)
  (sp-show-pair-delay . 0.1)
  (sp-max-pair-length . 4)
  (sp-max-prefix-length . 50)
  (sp-escape-quotes-after-insert . nil)
  :defer-config
  (sp-local-pair 'emacs-lisp-mode "<" ">")
  (require 'smartparens-config)
  (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+end_src

**** disable =smartparens-navigate-skip-match=
:PROPERTIES:
:ID: fda1875b-b3f7-4f43-83b1-873f3db3ae77
:END:

#+begin_src emacs-lisp
(defhook! disable-smartparens-navigate-skip-match (after-change-major-mode-hook)
  "Disable smartparents skip match feature."
  (setq sp-navigate-skip-match nil)
  (setq sp-navigate-consider-sgml-tags nil))
#+end_src

**** autopairing
:PROPERTIES:
:ID: e860ce7e-aaac-477b-a373-a8b01957481d
:END:

#+begin_src emacs-lisp
(defhook! enable-smartparens-maybe (minibuffer-setup-hook)
  "Enable `smartparens-mode' in the minibuffer, during `eval-expression' or
`evil-ex'."
  (when (memq this-command '(eval-expression evil-ex))
    (smartparens-mode 1)))
#+end_src

*** lispyville
:PROPERTIES:
:ID: 9d22714a-086d-49a1-9f8b-66da3b646110
:END:

[[https://github.com/noctuid/lispyville][lispyville]] helps vim commands work better with lisp by providing
commands (like [[helpfn:lispyville-delete][lispyville-delete]]) which preserve parentheses.

**** initialize
:PROPERTIES:
:ID: 5567b70d-60f2-4161-9a19-d6098f45cd95
:END:

#+begin_src emacs-lisp
(use-package! lispyville
  :commands lispyville-comment-or-uncomment-line
  :hook emacs-lisp-mode-hook
  :bind
  (:emacs-lisp-mode-map
   ([remap evil-yank]                 . lispyville-yank)
   ([remap evil-delete]               . lispyville-delete)
   ([remap evil-change]               . lispyville-change)
   ([remap evil-yank-line]            . lispyville-yank-line)
   ([remap evil-delete-line]          . lispyville-delete-line)
   ([remap evil-change-line]          . lispyville-change-line)
   ([remap evil-delete-char]          . lispyville-delete-char-or-splice)
   ([remap evil-delete-backward-char] . lispyville-delete-char-or-splice-backwards)
   ([remap evil-substitute]           . lispyville-substitute)
   ([remap evil-change-whole-line]    . lispyville-change-whole-line)
   ([remap evil-join]                 . lispyville-join)))
#+end_src

**** text objects
:PROPERTIES:
:ID: d553eee0-9b35-4a7d-a048-0f4a550b2471
:END:

#+begin_src emacs-lisp
(general-def evil-inner-text-objects-map
  "a" #'lispyville-inner-atom
  "l" #'lispyville-inner-list
  "x" #'lispyville-inner-sexp
  "c" #'lispyville-inner-comment
  ;; "f" #'lispyville-inner-function
  ;; "c" #'evilnc-inner-comment
  ;; overriding inner-sentence.
  "s" #'lispyville-inner-string)

(general-def evil-outer-text-objects-map
  "a" #'lispyville-a-atom
  "l" #'lispyville-a-list
  "x" #'lispyville-a-sexp
  "c" #'lispyville-a-comment
  ;; "f" #'lispyville-a-function
  ;; "c" #'evilnc-outer-commenter
  ;; "c" #'evilnc-outer-commenter
  "s" #'lispyville-a-string)
#+end_src

**** slurp/barf
:PROPERTIES:
:ID: 21626641-98e3-4134-958d-03227e4da6b5
:END:

#+begin_src emacs-lisp
(general-def 'normal lispyville-mode-map
  ">" #'lispyville-slurp
  "<" #'lispyville-barf)
#+end_src

**** escape
:PROPERTIES:
:ID: b355e1a1-6242-47f5-b357-5c3f5adbd200
:END:

=lispyville= binds escape to [[helpfn:lipyville-normal-state][lispyville-normal-state]]. So for =void:escape-hook=
to still happen on escape, I need to add [[helpfn:evil:escape-a][evil:escape-a]] as advice to
=lispyville-normal-state=.

Sometimes =evil-normal-state= enters visual state.

#+begin_src emacs-lisp
(general-def '(emacs insert) lispyville-mode-map [escape] #'lispyville-normal-state)
(advice-add #'lispyville-normal-state :after #'evil:dwim-abort-after-escape-a)
#+end_src

**** additional
:PROPERTIES:
:ID: 1fbafa78-87a0-45ee-9c7c-0c703df2ac66
:END:

#+begin_src emacs-lisp
(general-def '(emacs insert) lispyville-mode-map
  "SPC" #'lispy-space
  ";"   #'lispy-comment)

(general-def '(normal visual) lispyville-mode-map
  "M-j" #'lispyville-drag-forward
  "M-k" #'lispyville-drag-backward
  "M-R" #'lispyville-raise-list
  "M-v" #'lispy-convolute-sexp)
#+end_src

*** lispy
:PROPERTIES:
:ID: 4b4bfc73-e4e3-44f0-9553-61ac5182c946
:END:

For learning how to use lispy. [[https://github.com/abo-abo/lispy][the README]] and the [[http://oremacs.com/lispy/#lispy-different][lispy function reference]] were
very useful to me.

#+begin_src emacs-lisp
(use-package! lispy
  :hook emacs-lisp-mode-hook
  :setq
  (lispy-avy-style-paren . 'at-full)
  (lispy-eval-display-style . 'overlay)
  (lispy-safe-delete . t)
  (lispy-safe-copy . t)
  (lispy-safe-paste . t)
  (lispy-safe-actions-no-pull-delimiters-into-comments . t)
  (lispy-delete-sexp-from-within . t)
  (lispy-parens-only-left-in-string-or-comment . nil)
  ;; TODO see how performant is at larger thresholds and optimize
  (lispy-safe-threshold . 5000)
  (lispy-use-sly . t)
  ;; allow space before asterisk for headings (e.g. ";; *")
  (lispy-outline . "^;;\\(?:;[^#]\\|[[:space:]]*\\*+\\)")
  (lispy-key-theme . nil)
  :defer-config
  ;; You'll get void variable if you don't do this.
  (after! avy (setq lispy-avy-keys avy-keys)))
#+end_src

** writing
:PROPERTIES:
:ID: 27e382d7-5735-4f33-87c8-3dec2d2ca082
:END:

*** spell-number
:PROPERTIES:
:ID: 9cc794c5-dc10-4fb5-8af1-dd555c749071
:END:

#+begin_src emacs-lisp
(use-package! spell-number
  :setq
  (spelln-language . 'english-us)
  (spelln-country . 'united-states)
  (spelln-period-character . ?,)
  (spelln-decimal-character . ?.))
#+end_src

*** fill paragraph
:PROPERTIES:
:ID: 4f57fd49-b466-4eea-b91a-2cc8f0b07297
:END:

#+begin_src emacs-lisp
(use-package! aggressive-fill-paragraph)
#+end_src

*** spell check                                                       :disabled:
:PROPERTIES:
:ID: fc68d949-246f-43bf-85c2-7fbb947af7e9
:END:

#+begin_src emacs-lisp
(use-package! spell-fu
  :ensure (:host gitlab :repo "ideasman42/emacs-spell-fu")
  :commands spell-fu-mode
  :setq (spell-fu-directory . (concat VOID:DATA-DIR "spell-fu/")))
#+end_src

*** autocapitalize
:PROPERTIES:
:ID: 35c7c4c0-5009-43d6-8c34-43d6111ceb28
:END:

[[https://github.com/emacsmirror/auto-capitalize][auto-capitalize]] automatically capitalizes the first word of a sentence for me.
It will also upcase any word I add to [[helpvar:auto-capitalize-words][auto-capitalize-words]].

#+begin_src emacs-lisp
(use-package! auto-capitalize
  :setq (auto-capitalize-words . '("I" "English")))
#+end_src

*** thesaurus                                                         :disabled:
:PROPERTIES:
:ID: 5578aaf2-796f-4006-af60-de87b215120a
:END:

#+begin_src emacs-lisp
(use-package! powerthesaurus
  :commands (powerthesaurus-lookup-word-at-point power-thesaurus-lookup-word-dwim))
#+end_src

*** dictionary
:PROPERTIES:
:ID: 9ddc66c9-87be-43d1-8366-1bdb40718892
:END:

#+begin_src emacs-lisp
(use-package! define-it
  :commands define-it define-it-at-point
  :setq
  (define-it-output-choice . 'view)
  (define-it-show-google-translate . nil))
#+end_src

** evil
:PROPERTIES:
:ID: 73366b3e-7438-4abf-a661-ed1553b1b8df
:END:

*** evil
:PROPERTIES:
:ID: 3b9aaf0c-a69c-474a-b1a3-f0e748e83558
:END:

[[https://github.com/emacs-evil/evil][evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim,
and provides facilities for writing custom extensions. Also see our page on
[[emacswiki:Evil][EmacsWiki]]. See a brief [[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][manual]]. See the [[https://github.com/noctuid/evil-guide][evil-guide]] by noctuid.

**** evil
:PROPERTIES:
:ID: 7dba80e1-58d6-46d2-a0e3-64c535e556e2
:END:

#+begin_src emacs-lisp
(use-package! evil
  :require t
  :hook window-setup-hook
  :custom
  (evil-want-C-u-scroll    . t)
  (evil-want-C-d-scroll    . t)
  (evil-want-C-w-delete    . t)
  (evil-want-Y-yank-to-eol . t)
  (evil-overriding-maps    . nil)
  (evil-want-minibuffer    . t)
  :pre-setq
  (evil-want-keybinding                 . nil)
  :setq
  (evil-want-C-w-in-emacs-state         . nil)
  (evil-want-visual-char-semi-exclusive . t)
  ;; Whether the cursor can move past the end of the line.
  (evil-move-beyond-eol                 . nil)
  (evil-magic                           . t)
  (evil-echo-state                      . nil)
  (evil-indent-convert-tabs             . t)
  (evil-ex-search-vim-style-regexp      . t)
  (evil-ex-substitute-global            . t)
  (evil-ex-visual-char-range            . t)
  (evil-insert-skip-empty-lines         . t)
  (evil-mode-line-format                . nil)
  (evil-respect-visual-line-mode        . t)
  (evil-symbol-word-search              . t)
  (shift-select-mode                    . nil))
#+end_src

**** cursors
:PROPERTIES:
:ID: a5f558fb-221c-4b33-a7cd-29308ef74b0d
:END:

It's nice to have cursors change colors (and sometimes shape) depending on the
current evil state. It makes it easy to tell which state you're in. I define
some colors here. Evil has a cursor variable for each state. The cursor variable
for insert state, for example, is [[helpvar:evil-insert-state-cursor][evil-insert-state-cursor]]. Its value is of the
form: ~((CURSOR-SHAPE . CURSOR-WIDTH) COLOR)~.

***** colors and shapes
:PROPERTIES:
:ID: 3f3cd5c9-1f6d-4c3b-b73f-82c9ee00395e
:END:

Evil differentiates what state you're in based on the cursor color.

#+begin_src emacs-lisp
(defhook! setup-cursor (evil-mode-hook)
  "Initialize the default cursor shape and size."
  (setq evil-insert-state-cursor   '((bar . 3)   "chartreuse3"))
  (setq evil-emacs-state-cursor    '((bar . 3)   "SkyBlue2"))
  (setq evil-normal-state-cursor   '( box        "DarkGoldenrod2"))
  (setq evil-visual-state-cursor   '((hollow)    "dark gray"))
  (setq evil-operator-state-cursor '((hbar . 10) "hot pink"))
  (setq evil-replace-state-cursor  '( box        "chocolate"))
  (setq evil-motion-state-cursor   '( box        "plum3")))
#+end_src

***** updating cursors
:PROPERTIES:
:ID: ea4da6d4-4a2c-42cf-b397-cea1555781ce
:END:

After a theme is loaded, the cursor color won't automatically update. Therefore,
I add a hook in [[helpvar:void-after-load-theme-hook][void:after-load-theme-hook]]. Now after a new theme is loaded, the
cursor color will update.

#+begin_src emacs-lisp
(defhook! refresh-evil-cursor (void:after-load-theme-hook)
  "Enable cursor refreshing after theme change."
  (when (bound-and-true-p evil-mode)
    (evil-refresh-cursor)))
#+end_src

**** normal state everywhere
:PROPERTIES:
:ID:       e6126bd7-94b8-4ce0-b547-0536b59437ea
:END:

#+begin_src emacs-lisp
(defhook! make-normal-state-default (evil-mode-hook)
  "Make normal state the default `evil-mode' state."
  (setq evil-normal-state-modes (append evil-emacs-state-modes evil-normal-state-modes))
  (setq evil-emacs-state-modes nil)
  (setq evil-motion-state-modes nil))

(defadvice! evil:treat-motion-as-normal-state (orig-fn &rest args)
  "Advice for `evil-make-overriding-map' that inhibits motion state."
  :around evil-make-overriding-map
  (-let (((keymap state copy) args))
    (funcall orig-fn keymap (if (eq state 'motion) 'normal state) copy)))

(defadvice! evil:set-initial-state (orig-fn &rest args)
  :around evil-set-initial-state
  (-let (((mode state) args))
    (funcall orig-fn mode (if (eq state 'motion) 'normal state))))

(advice-add #'evil-motion-state :override #'evil-normal-state)
#+end_src

**** insert state in minibuffer
:PROPERTIES:
:ID: a23137c5-62a0-4e77-9e51-6a7372dac703
:END:

Before I just used ~(evil-change-state evil-previous-state)~ to revert the
state back to what it last was. But this fails with ~evil-force-normal-state~
which is what I'm currently using to exit the minibuffer because then the
last state is normal state if the minibuffer is aborted. Using a
=evil:state-before-minibuffer= ensures that the state will be reverted to
the correct one.

#+begin_src emacs-lisp
(defhook! preserve-prior-evil-state (minibuffer-enter-hook :eval-after evil)
  "Save state before entering the minibuffer and enter insert state."
  (when (bound-and-true-p evil-mode)
    (setq evil:state-before-minibuffer evil-state)
    (evil-insert-state)))

(defhook! restore-prior-evil-state (minibuffer-exit-hook :eval-after evil)
  "Restore state after minibuffer."
  (when (bound-and-true-p evil-mode)
    (evil-change-state evil:state-before-minibuffer)
    (setq evil:state-before-minibuffer nil)))
#+end_src

**** escape
:PROPERTIES:
:ID:       e4b9d33d-c64d-47ef-9bff-baa80d1b34b2
:END:

***** escape
:PROPERTIES:
:ID: ea9378de-e5c5-482c-b53b-743a81e3bc8e
:END:

We want escape to be a general "quit everything".

#+begin_src emacs-lisp
(general-def :states '(emacs insert) [escape] #'evil-force-normal-state)

(defadvice! evil:dwim-abort-after-escape-a ()
  "Exits out of whatever is happening after escape."
  :after evil-force-normal-state
  (cond ((minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ((run-hook-with-args-until-success 'void:escape-hook))
        ((or defining-kbd-macro executing-kbd-macro) nil)
        (t (keyboard-quit))))
#+end_src

***** TODO keychord integration
:PROPERTIES:
:ID:       33fa6402-f56e-4bea-a9b5-bd5a6f44792f
:END:

Sometimes we don't have access to a convenient escape key--I mean that caps-lock
is not bound to escape. Or, perhaps, we might find it faster or preferable to
press =jk= really quickly to invoke escape.

This is better than evil escape as it only binds in insert.

#+begin_src emacs-lisp
(use-package! key-chord
  :after-call (evil-insert-state evil-emacs-state)
  :defer-config
  (quiet! (key-chord-mode 1))
  (general-def :states '(visual insert)
    (general-chord "jk") 'evil-force-normal-state
    (general-chord "kj") 'evil-force-normal-state))
#+end_src

**** saving
:PROPERTIES:
:ID: 8181807e-9811-427c-beec-f380d91040f9
:END:

#+begin_src emacs-lisp
(setq save-silently t)

(defun evil:save-message ()
  (message "\"%s\" %dL, %dC written"
           (buffer-name)
           (count-lines (point-min) (point-max))
           (buffer-size)))
#+end_src

**** text objects
:PROPERTIES:
:ID: 07366548-2960-49c6-9ab7-cb177b06ad70
:END:

To edit text efficiently Vim has the concept of [[https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/][text objects]]. Text objects are
structures that are seen in text. For example, a set of words followed by a
period is a sentence. A words between two closing parentheses is a sexp.

***** general delimiter text object
:PROPERTIES:
:ID: f551956d-440c-431b-8fb0-8e71c9714f11
:END:

I discovered this the =form= text object from using [[https://github.com/luxbock/evil-cleverparens][evil-cleverparens]] in the past.
The package =evil-cleverparens= was too slow for my taste; noctuid's [[https://github.com/sp3ctum/evil-lispy][evil-lispy]] is
much faster and gave me the functionality that I needed most from
=evil-cleverparens=: deleting and copying text with parentheses intelligently.
However, many of the ideas of =evil-cleverparens= were excellent. One particular
idea was to have a general =form= text object. Instead of specifying the
particular surrounding bounds when doing an evil operator command you just use a
single key for them. It's kind of like a =Do-What-I-Mean= surround operator. This
is suprisingly useful because it takes significant time to specify whether you
want =[]= or ={=}= or =()= or =""=. The main drawback you cannot distinguish between
surround characters at multiple levels--it just takes the closest one. In
practice, this is rarely an issue.

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-inner-form (count &rest _)
    "Inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range (1+ beg) (1- end) 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (evil-define-text-object evil:textobj-outer-form (count &rest _)
    "Smartparens inner sexp object."
    (-if-let ((beg . end)
              (->> (list (lispy--bounds-list) (lispy--bounds-string))
                   (-non-nil)
                   (--sort (< (- (cdr it) (car it)) (- (cdr other) (car other))))
                   (car)))
        (evil-range beg end 'inclusive :expanded t)
      (error "No surrounding form found.")))

  (general-def evil-inner-text-objects-map
    "f" #'evil:textobj-inner-form)
  (general-def evil-outer-text-objects-map
    "f" #'evil:textobj-outer-form))
#+end_src

***** fix vim/evil around =""=
:PROPERTIES:
:ID: b57bf245-3d63-4078-8bcb-2ec0b9952ab9
:END:

=Vim= and =Evil= both have the interesting (inconsistent?) behavior that doing an
outer text object operator on a comment grabs some whitespace on the left side.
Try doing =va"= to ~(progn "hello world")~ and you'll see that =\s"hello world"= is
selected instead of just "hello world".

Why not just go to the end of the ="= like any other around operator?

#+begin_src emacs-lisp
(after! evil
  (evil-define-text-object evil:textobj-a-string (count &rest _)
    "An outer comment text object as defined by `lispy--bounds-string'."
    (-if-let ((beg . end) (lispy--bounds-string))
        (evil-range beg end 'exclusive :expanded t)
      (error "Not inside a comment.")))

  (general-def evil-outer-text-objects-map
    "\"" #'evil:textobj-a-string))
#+end_src

**** package specific setup                                           :disabled:
:PROPERTIES:
:ID: 5f9025e0-156c-4270-96ab-49011df83632
:END:

***** helpful
:PROPERTIES:
:ID: 81552b9b-46aa-46c8-8541-500059dda695
:END:

#+begin_src emacs-lisp
(after! (evil helpful)
  (evil-set-initial-state 'helpful-mode 'normal))
#+end_src

***** magit
:PROPERTIES:
:ID: a27830b2-b60a-4aca-b65a-4042392d7105
:END:

#+begin_src emacs-lisp
(after! (evil magit)
  (add-hook 'git-commit-mode-hook #'evil-insert-state))
#+end_src

***** org
:PROPERTIES:
:ID: 62d87b9a-6219-4feb-b46c-a6e2e4155a90
:END:

****** insert state
:PROPERTIES:
:ID: b9cde044-5190-4789-97c4-a124c6701cd4
:END:

#+begin_src emacs-lisp
(after! (evil org)
  (add-hook 'org-insert-heading-hook #'evil-insert-state)
  (after! org-capture
    (add-hook 'org-capture-mode-hook #'evil-insert-state)))
#+end_src

***** Info                                                            :disabled:
:PROPERTIES:
:ID: c6c401dc-a7cf-460d-9188-1ee8bb2dad24
:END:

#+begin_src emacs-lisp
(general-def
  (:map Info-mode-map)
  (:m "h"   #'Info-backward-node)
  (:m "l"   #'Info-forward-node)
  (:m "H"   #'Info-history-back)
  (:m "L"   #'Info-history-forward)
  (:m "r"   #'Info-history)
  (:m "J"   #'evil-scroll-page-down)
  (:m "K"   #'evil-scroll-page-up)
  (:m "f"   #'ace-link-info)
  (:m "u"   #'Info-up)
  (:m "U"   #'Info-top-node)
  (:m "m"   #'Info-menu)
  (:m "s"   #'Info-search)
  (:m "RET" #'Info-follow-nearest-node)
  (:m "q"   #'quit-window))
#+end_src

***** eshell
:PROPERTIES:
:ID: 0a974596-2004-4ed2-9053-8bc6db1acd84
:END:

****** evil operators
:PROPERTIES:
:ID: 142162a1-0495-427e-bac6-f2e8e63dd184
:END:

******* evil-change
:PROPERTIES:
:ID: 1a47ff34-8f3b-4845-b3e9-0ae0937c5c84
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-change (beg end type register yank-handler delete-func)
    "Like `evil-change' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-change (max beg (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler delete-func))))
#+end_src

******* evil-change-line
:PROPERTIES:
:ID: 296c4f58-261f-4f1b-a333-7807ebef331b
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-change-line (beg end type register yank-handler)
    "Change to end of line."
    :motion evil-end-of-line
    (interactive "<R><x><y>")
    (eshell/evil-change beg end type register yank-handler #'evil-delete-line)))
#+end_src

******* evil-delete
:PROPERTIES:
:ID: 63b0c253-a59e-409a-b593-36ddd84d8777
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-delete (beg end type register yank-handler)
    "Like `evil-delete' but will not delete/copy the prompt."
    (interactive "<R><x><y>")
    (save-restriction
      (narrow-to-region eshell-last-output-end (point-max))
      (evil-delete (if beg (max beg (point-min)) (point-min))
                   (if (eq type 'line) (point-max) (min (or end (point-max)) (point-max)))
                   type register yank-handler))))
#+end_src

******* evil-delete-line
:PROPERTIES:
:ID: 017b5fe8-a27e-4bab-a014-8bf53258b92a
:END:

#+begin_src emacs-lisp
(after! eshell
  (evil-define-operator eshell/evil-delete-line (_beg end type register yank-handler)
    "Change to end of line."
    :motion nil
    :keep-visual t
    (interactive "<R><x>")
    (eshell/evil-delete (point) end type register yank-handler)))
#+end_src

****** update cursors after entering eshell
:PROPERTIES:
:ID: 5384f57c-9eba-4f00-953a-92814a253ce9
:END:

#+begin_src emacs-lisp
(after! evil
  (evil-set-initial-state 'eshell-mode 'insert))
#+end_src

***** smartparens
:PROPERTIES:
:ID: 4977e770-2c5b-4819-8c6d-ed2c794737fe
:END:

#+begin_src emacs-lisp
;; smartparens breaks evil-mode's replace state
(after! (evil smartparens)
  (add-hook 'evil-replace-state-entry-hook #'turn-off-smartparens-mode)
  (add-hook 'evil-replace-state-exit-hook  #'turn-on-smartparens-mode))
#+end_src

***** debugger-mode
:PROPERTIES:
:ID: 614215d3-33b1-482e-bf0e-c9d66cdb1c24
:END:

#+begin_src emacs-lisp
(after! evil (evil-set-initial-state 'debugger-mode 'emacs))
#+end_src

***** autoyasnippet
:PROPERTIES:
:ID: 851aaa47-5220-43a2-9861-b36d4cb9b803
:END:

#+begin_src emacs-lisp
(use-package! auto-yasnippet
  :defer-config (advice-add #'aya-expand :after #'evil-insert-state)
  :setq (aya-persist-snippets-dir . (concat VOID:LOCAL-DIR "auto-snippets/")))
#+end_src

***** yasnippet
:PROPERTIES:
:ID: d3b2a618-d008-427e-9947-44741bb0bbf9
:END:

#+begin_src emacs-lisp
(after! (evil lispy)
  (general-def
    (:map evil-lispy-state-map)
    ("l" #'lispy-right)
    ("h" #'lispy-left)
    ("f" #'lispy-flow)
    ("j" #'lispy-down)
    ("k" #'lispy-up)
    ("d" #'lispy-different)
    ("o" #'lispy-other-mode)
    ("p" #'lispy-eval-other-window)
    ("P" #'lispy-paste)
    ("y" #'lispy-occur)
    ("z" #'lh-knight/body)))
#+end_src

*** evil-surround
:PROPERTIES:
:ID: ef933441-4891-48d8-a4aa-016702e55b48
:END:

#+begin_src emacs-lisp
(use-package! evil-surround :hook prog-mode-hook text-mode-hook)
#+end_src

*** evil-matchit
:PROPERTIES:
:ID: 30ff273a-253b-4cdc-8e86-22e5705f44c1
:END:

#+begin_src emacs-lisp
(use-package! evil-matchit :hook prog-mode)
#+end_src

*** evil-exchange
:PROPERTIES:
:ID: d1c40ac0-d143-4e27-847b-d3d8e72a552a
:END:

Package [[https://github.com/Dewdrops/evil-exchange][evil-exchange]] lets me swap two regions of text.

#+begin_src emacs-lisp
(use-package! evil-exchange
  :commands evil-exchange
  :init
  (general-def 'normal
    :prefix "g"
    "X" (list :def #'evil-exchange-cancel :wk "cancel")
    "x" (list :def #'evil-exchange :wk "exchange")))
#+end_src

*** evil-visualstar
:PROPERTIES:
:ID: 6ebca72d-f90a-4423-9ecd-706f9d426002
:END:

[[https://github.com/bling/evil-visualstar][evil-visualstar]]

#+begin_src emacs-lisp
(use-package! evil-visualstar
  :commands (evil-visualstar/begin-search-backward evil-visualstar/begin-search-forward)
  :bind (:evil-visual-state-map
         ("#" . evil-visualstar/begin-search-backward)
         ("*" . evil-visualstar/begin-search-forward)))
#+end_src

** expand-region
:PROPERTIES:
:ID: 417c9c53-a776-4779-9afc-1eaa35a145c6
:END:

[[https://github.com/magnars/expand-region.el][expand-region]] allows me to toggle a key ("v" in my case) to select progressively
larger text objects. It's saves me keystrokes.

#+begin_src emacs-lisp
(use-package! expand-region
  :commands (er/expand-region er/contract-region er/mark-symbol er/mark-word)
  :init
  (general-def 'visual
    "V" #'er/contract-region
    "v" #'er/expand-region)
  :defer-config
  (defadvice! void:quit-expand-region-a ()
    "Properly abort an expand-region region."
    :before evil-escape evil:escape-a
    (when (memq last-command '(er/expand-region er/contract-region))
      (er/contract-region 0))))
#+end_src

** avy
:PROPERTIES:
:ID: 71d016e2-a118-4468-8a01-fe86863bc030
:END:

[[https://github.com/abo-abo/avy][Avy]]

*** bootstrap
:PROPERTIES:
:ID: eff03171-05b3-4a70-93ee-0a0f2b2c64f4
:END:

#+begin_src emacs-lisp
(use-package! avy
  :commands avy-jump
  :setq
  (avy-background . t)
  ;; Jump only on current window.
  (avy-all-windows . nil)
  ;; Use avy keys.
  (avy-keys-alist . nil)
  (avy-keys . (list
               ;; homerow keys in alternating order.
               ?a ?j ?s ?k ?d ?l ?f ?\;
               ;; middle homerow keys
               ?g ?h
               ;; keys above homerow in alternating order
               ?t ?y ?r ?u ?e ?i ?w ?o ?q ?p
               ;; keys below homerow
               ?b ?n ?v ?m ?c ?, ?x ?. ?z ?/))
  (avy-style . 'at))
#+end_src

*** avy-command-helper
:PROPERTIES:
:ID:       814e98f9-5823-4e8f-9f89-49cdecf3d809
:END:

#+begin_src emacs-lisp
(defun avy:jump-to-regexp (regexp)
  (avy-jump regexp
            :beg (window-start)
            :end (window-end)
            :pred `(lambda () (/= (1+ ,(point)) (point)))))
#+end_src

*** avy commands
:PROPERTIES:
:ID: 01ee387f-f153-497e-b9fb-d62d5df9ebe1
:END:

#+begin_src emacs-lisp
(defun void/evil-beginning-of-word ()
  (interactive)
  (avy:jump-to-regexp (rx word-start nonl)))

(defun void/evil-beginning-of-WORD ()
  (interactive)
  (avy:jump-to-regexp (rx symbol-start nonl)))

(defun void/evil-end-of-word ()
  (interactive)
  (avy:jump-to-regexp (rx nonl word-end)))

(defun void/evil-end-of-WORD ()
  (interactive)
  (avy:jump-to-regexp (rx nonl symbol-end)))
#+end_src

*** bindings
:PROPERTIES:
:ID: a8febb0e-768b-412d-9d86-1f1439eced0e
:END:

#+begin_src emacs-lisp
(general-def 'normal
  "f" #'avy-goto-char
  "w" #'void/evil-beginning-of-word
  "W" #'void/evil-beginning-of-WORD
  "e" #'void/evil-end-of-word
  "E" #'void/evil-end-of-WORD)
#+end_src

** undo                                                               :disabled:
:PROPERTIES:
:ID: 87fde0b2-5db6-4b5f-8945-d469449f1207
:END:

*** undo-fu
:PROPERTIES:
:ID: 2cb27d5e-e26c-4805-9ee7-f93222d75220
:END:

#+begin_src emacs-lisp
(use-package! undo-fu
  :after-hook void:after-switch-buffer-hook
  :before-call after-find-file
  :setq
  (undo-limit . 400000)
  (undo-strong-limit . 3000000)
  (undo-outer-limit . 3000000)
  :bind
  ([remap undo] . undo-fu-only-undo)
  ([remap redo] . undo-fu-only-redo)
  :defer-config
  (global-undo-tree-mode -1))
#+end_src

* Utility
:PROPERTIES:
:ID: 15266577-fc6e-4ec7-8277-3a94b6f4f926
:END:

** eshell
:PROPERTIES:
:ID: 5f04a252-2985-46b4-ab0b-eb4567de5dd9
:END:

[[info:eshell#Top][eshell]] is a built-in shell written entirely in elisp. This means that it's as
portable and customizable as emacs itself. It can run elisp functions as
commands. There's a good article about it in [[https://masteringemacs.org/article/complete-guide-mastering-eshell][mastering-emacs]]. Other articles I
have like about eshell: [[https://ambrevar.xyz/emacs-eshell/][ambrevar's eshell post]], [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Howard Abram's Post]].

*** bootstrap
:PROPERTIES:
:ID: 8ed5b69c-be1f-4181-bd01-88fc33b148d6
:END:

#+begin_src emacs-lisp
(use-feature! eshell
  :commands eshell
  :idle-require
  em-alias em-banner em-basic em-cmpl
  em-dirs em-glob em-hist em-ls em-prompt
  em-script em-term em-unix
  :popup ("\\*eshell"
          (display-buffer-at-bottom)
          (window-height . 0.5)
          (side . bottom)
          (slot . 2))
  :setq
  (eshell-directory-name . (concat VOID:DATA-DIR "eshell/"))
  (eshell-history-file-name . (concat eshell-directory-name "history"))
  (eshell-prefer-lisp-functions . nil)
  (eshell-scroll-to-bottom-on-input . 'all)
  (eshell-scroll-to-bottom-on-output . 'all)
  (eshell-buffer-shorthand . t)
  (eshell-kill-processes-on-exit . t)
  (eshell-hist-ignoredups . t)
  (eshell-input-filter . #'eshell-input-filter-initial-space)
  (eshell-glob-case-insensitive . t)
  (eshell-error-if-no-glob . t)
  (eshell-banner-message . '(format "%s %s\n\n"
                             (propertize (format " %s " (string-trim (buffer-name)))
                              'face 'mode-line-highlight)
                             (propertize (current-time-string)
                              'face 'font-lock-keyword-face)))
  :defer-config
  (remove-hook 'eshell-output-filter-functions
               'eshell-postoutput-scroll-to-bottom))
#+end_src

*** visual commands
:PROPERTIES:
:ID: fedfa200-7d17-408d-ba42-da401cba6419
:END:

#+begin_src emacs-lisp
(after! em-term
  (--each '("tmux" "htop" "bash" "zsh" "fish" "vim" "nvim" "ncmpcpp")
    (add-to-list 'eshell-visual-commands it)))
#+end_src

*** improvements
:PROPERTIES:
:ID: b3da5d39-1591-4a19-ae96-45a117a13f24
:END:

Eshell uses pcomplete as its completion engine.

**** pcomplete
:PROPERTIES:
:ID: 63de7a7f-431c-4652-aa55-45973b5a4c2a
:END:

This replaces the default popup window at the bottom of eshell. By using the
=completion-in-region= backend, it triggers ivy/helm for completion.

#+begin_src emacs-lisp
(defun eshell/pcomplete ()
  "Use pcomplete with completion-in-region backend."
  (interactive)
  (require 'pcomplete)
  (ignore-errors (pcomplete-std-complete)))
#+end_src

**** go to prompt on insert
:PROPERTIES:
:ID: 76bd909c-901c-4bc6-8848-d84b121a06c3
:END:

#+begin_src emacs-lisp
(defun eshell:goto-prompt-on-insert-h ()
  "Move cursor to the prompt when switching to insert mode."
  (when (< (point) eshell-last-output-end)
    (goto-char
     (if (memq this-command '(evil-append evil-append-line))
         (point-max)
       eshell-last-output-end))))
#+end_src

*** eshell commands
:PROPERTIES:
:ID: 4a7074f6-7f53-4950-9c92-be39b23e1d70
:END:

**** eshell-z
:PROPERTIES:
:ID: 497798a0-7b62-4779-bf15-f67500528f03
:END:

#+begin_src emacs-lisp
(use-package! eshell-z
  :after eshell
  :commands eshell/z
  :setq (eshell:z-file . (expand-file-name "z" eshell-directory-name))
  :defer-config
  (defalias 'eshell:z-file 'eshell-z-freq-dir-hash-table-file-name))
#+end_src

**** eshell-up
:PROPERTIES:
:ID: 478219b9-1c6f-4907-b428-a2dfe0f45e5c
:END:

This is an Emacs package for quickly navigating to a specific parent directory
in ~eshell~ without having to repeatedly typing ~cd ..~.

#+begin_src emacs-lisp
(use-package! eshell-up
  :after eshell
  :commands eshell-up eshell-up-peek
  :init
  (defalias 'eshell/up 'eshell-up)
  (defalias 'eshell/pk 'eshell-up-peek)
  (defalias 'eshell/peek 'eshell-up-peek))
#+end_src

**** eshell-clear
:PROPERTIES:
:ID: 6ae332e7-f2e8-4a78-9bb8-c9b4f271a6a2
:END:

The shell often gets cluttered with many commands. It's often useful to clear it
and indeed there are many suggestions on how to do so online. However, many of
them involve erasing the eshell buffer or making it's previous contents
inaccessable. I don't like getting rid of information that could be important.
All I really wanted is to just scroll up to the top of the window so that the
previous contents weren't visible. Note that it is important that this command
returns nil. Eshell shell ignores output returns nil. However, when it returns
non-nil it prints it to the eshell buffer, which results in a residue
line--that's not what we want.

https://emacs.stackexchange.com/questions/28819/eshell-goes-to-the-bottom-of-the-page-after-executing-a-command

#+begin_src emacs-lisp
(defadvice! eshell:scroll-buffer-to-top (&rest _)
  "Scroll eshell buffer to top.
The effect of this is to clear the contents of the eshell buffer."
  :override eshell/clear
  (progn (call-interactively #'evil-scroll-line-to-top) nil))
#+end_src

*** display
:PROPERTIES:
:ID: 66d647e3-b83b-4469-bb62-75546c2fee64
:END:

**** prompt
:PROPERTIES:
:ID: c21591c9-43a2-4c6b-aac8-b46b41f4dc63
:END:

I got a lot of inspiration from the [[http://www.modernemacs.com/post/custom-eshell/][modern emacs blog]]. I think the
author's code is in general a good example of how to use macros to abstract a
task and make it much simpler than it would be otherwise.

***** with-face
:PROPERTIES:
:ID: ae757b22-27e1-4243-8da0-35c3a8e6ff65
:END:

#+begin_src emacs-lisp
(defmacro with-face! (string &rest props)
  "Return STR propertized with PROPS."
  `(propertize ,string 'face '(,@props)))
#+end_src

***** helpers
:PROPERTIES:
:ID: c29bac50-32e4-4128-8446-6f4153d3a7a0
:END:

Eshell prompt function finds eshell section functions specified by
[[helpvar:eshell:enabled-sections][+eshell-enabled-sections]] and concatenates their results in order to
generate the body of the eshell prompt.

#+begin_src emacs-lisp
(defun eshell:acc (acc x)
  "Accumulator for evaluating and concatenating `eshell:enabled-sections'."
  (--if-let (funcall x)
      (if (s-blank? acc)
          it
        (concat acc eshell:sep it))
    acc))

(defun eshell:prompt-func ()
  "Generate the eshell prompt.
This function generates the eshell prompt by concatenating `eshell:header' with
valid `eshell:enabled-sections' and the `eshell-prompt-string'."
  (concat eshell:header
          (->> eshell:enabled-sections
               (mapcar (lambda (it) (void:symbol-intern 'eshell-prompt-- it)))
               (-filter #'fboundp)
               (-reduce-from #'eshell:acc ""))
          eshell-prompt-string))
#+end_src

***** eshell components
:PROPERTIES:
:ID: c22a9cdb-9b9f-4f06-9c09-f330d454ab1f
:END:

This heading contains the parts that make up the eshell prompt. They are the
header, the separator, the section delimiter and, the meat of the prompt, the
actual eshell sections.

#+begin_src emacs-lisp
(defvar eshell:sep "\s|\s"
  "Separator between eshell sections.")

(defvar eshell:section-delim "\s"
  "Separator between an eshell section icon and form.")

(defvar eshell:header "\s"
  "Eshell prompt header.")

(defvar eshell:enabled-sections '(dir git)
  "List of enabled eshell sections.
Each element of the list is an abbreviated.")

;; This is a regex that matches your eshell prompt so that eshell knows what to
;; keep readonly and what not to.
(setq eshell-prompt-regexp (rx (*? anything) "-> "))
(setq eshell-prompt-string " -> ")

(setq eshell-prompt-function #'eshell:prompt-func)
#+end_src

**** text wrapping
:PROPERTIES:
:ID: 7d155cf8-a90c-4183-a9be-5ffdc266d82a
:END:

#+begin_src emacs-lisp
(defhook! enable-text-wrapping (eshell-mode-hook)
  "Enable text wrapping."
  (visual-line-mode +1)
  (set-display-table-slot standard-display-table 0 ?\ ))
#+end_src

**** fringes
:PROPERTIES:
:ID: 312652e5-9975-4241-b709-7ed5b8537202
:END:

#+begin_src emacs-lisp
(defhook! remove-fringes (eshell-mode-hook)
  "Remove fringes for eshell."
  (set-window-fringes nil 0 0)
  (set-window-margins nil 1 nil))
#+end_src

**** hide modeline
:PROPERTIES:
:ID: 6dc13e60-abd4-40d0-be15-55b11c1faeb2
:END:

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook #'hide-mode-line-mode)
#+end_src

*** hooks
:PROPERTIES:
:ID: bfe31d56-9fae-4841-b078-d1f276f29611
:END:

**** aliases
:PROPERTIES:
:ID: 4f53fbac-9d9f-4e58-8e3a-0baad56d2ae9
:END:

***** setup
:PROPERTIES:
:ID: 1a346816-85a1-402e-81ac-c0dd0ef6dfc7
:END:

They are meant to emulate useful shell utilities, like fasd and bd.
Note that you may overwrite these in your [[helpvar:eshell-aliases-file][eshell-aliases-file]]. This is
here to provide an alternative, elisp-centric way to define your
aliases.

#+begin_src emacs-lisp
(defvar eshell:aliases
  '(("q"  "exit")
    ("ff"  "find-file $1")
    ("rg" "rg --color=always $*")
    ("ag" "ag --color=always $*")
    ("l"  "ls -lh")
    ("ll" "ls -lah"))
  "An alist of default eshell aliases. ")
#+end_src

***** initialize
:PROPERTIES:
:ID: 08af337e-61f3-4dce-bbf8-bab10c8d9793
:END:

#+begin_src emacs-lisp
(defvar eshell--default:aliases nil)

(defhook! enable-aliases (eshell-alias-load-hook)
  "Initialize eshell aliases."
  (setq eshell--default:aliases eshell-command-aliases-list
        eshell-command-aliases-list
        (append eshell-command-aliases-list
                eshell:aliases)))

(advice-add #'eshell-write-aliases-list :override #'ignore)
#+end_src

*** shrink-path
:PROPERTIES:
:ID: eef8ea28-4de2-44ab-a09d-26f58c0a75ac
:END:

#+begin_src emacs-lisp
(use-package! shrink-path
  :commands shrink-path-file)
#+end_src

** command-log-mode
:PROPERTIES:
:ID: 10226327-4c31-41db-b202-e4a9f44fc6fe
:END:

[[https://github.com/lewang/command-log-mode][command-log-mode]] keeps track of all the commands you run and displays them to
you on a side window.

#+begin_src emacs-lisp
(use-package! command-log-mode
  :commands command-log-mode global-command-log-mode
  :setq
  (command-log-mode-auto-show . t)
  (command-log-mode-open-log-turns-on-mode . nil)
  (command-log-mode-is-global . t))
#+end_src

** recentf
:PROPERTIES:
:ID: f26bedb3-a172-4543-afd0-4c47f5872d15
:END:

=recentf= is a built-in program that tracks the files you've opened recently
persistently. This is a great idea because these are the files you'll likely
revisit. In practice, I look at this list of files in addition to the buffers I
already have open using a [[][completion-framework]]. Because of this I rarely
have to set out to look for a file with =dired=.

*** recentf
:PROPERTIES:
:ID: 527f55e1-48c3-4d90-a2ef-9dd463e6d1fd
:END:

#+begin_src emacs-lisp
(use-feature! recentf
  :before-call find-file
  :idle-require easymenu tree-widget timer
  :commands recentf-open-files
  :defer-config
  (advice-add #'recentf-save-list :before #'recentf-cleanup)
  (recentf-mode 1)
  :setq
  (recentf-exclude . (list #'file-remote-p
                           "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\)$"
                           ;; ignore private Void temp files (but not all of them)
                           #'(lambda (file)
                               (-some-p (apply-partially #'file-in-directory-p file)
                                (list VOID:DATA-DIR)))))
  (recentf-max-menu-items . 0)
  (recentf-max-saved-items . 700)
  :custom
  (recentf-save-file . (concat VOID:DATA-DIR "recentf"))
  (recentf-auto-cleanup . 'never)
  (recentf-filename-handlers . '(file-truename abbreviate-file-name)))
#+end_src

*** silence recentf
:PROPERTIES:
:ID: 15a971c4-b43a-4539-846e-70fe4e90d84a
:END:

#+begin_src emacs-lisp
(defadvice! recentf:shut-up-a (orig-fn &rest args)
  "Shut up recentf."
  :around recentf-mode
  (shut-up! (apply orig-fn args)))
#+end_src

** saveplace
:PROPERTIES:
:ID: 6da42724-3137-4d70-9aed-9a978357679f
:END:

As its name suggests, =save-place= is a built-in package that stores the buffer
location you left off at in a particular buffer. When you visit that buffer
again, you are taken to the location you left off. This is very convenient.

#+begin_src emacs-lisp
(use-feature! saveplace
  :after-call after-find-file
  :setq
  (save-place-file . (concat VOID:DATA-DIR "saveplace"))
  (save-place-limit . nil)
  :config
  (save-place-mode)
  (defadvice! save-place-recenter-on-load-saveplace-a (&rest _)
    "Recenter on cursor when loading a saved place."
    :after-while save-place-find-file-hook
    (when buffer-file-name (ignore-errors (recenter)))))
#+end_src

** savehist
:PROPERTIES:
:ID: 23867595-32fd-4270-97bd-3101cc681f00
:END:

#+begin_src emacs-lisp
(use-feature! savehist
  :idle-require custom
  :hook emacs-startup-hook
  :setq
  (savehist-save-minibuffer-history . t)
  (savehist-autosave-interval . nil)
  (savehist-additional-variables . '(kill-ring search-ring regexp-search-ring))
  (savehist-file . (concat VOID:DATA-DIR "savehist")))

(defhook! unpropertize-kill-ring (kill-emacs-hook :append t)
  "Remove text properties from `kill-ring'."
  (setq kill-ring
        (mapcar (lambda (it) (when (stringp it) (substring-no-properties it)))
                (-non-nil kill-ring))))
#+end_src

** bookmarks
:PROPERTIES:
:ID: e1a569f8-d27a-4e0c-924a-3b123c62b6a2
:END:

[[info:emacs#Bookmarks][Bookmarks]] persistently store file locations. I use [[https://github.com/emacsmirror/bookmark-plus][bookmark-plus]] an increadibly
featureful bookmark extension package. Usually =xah lee= has good basic overviews
of topics on his site, check out the [[http://ergoemacs.org/emacs/bookmark.html — Emacs: Bookmark][one on bookmarks]]. I had already known about
=bookmark-plus=, however I hadn't really done anything with it. It was after I
read this [[https://emacs.stackexchange.com/questions/51853/retracing-steps-with-emacs-when-programming-exploring — search - Retracing steps with emacs (When programming /exploring) - Emacs Stack Exchange][question]].

#+begin_src emacs-lisp
(use-feature! bookmark
  :pre-setq
  (bookmark-default-file . (concat VOID:DATA-DIR "bookmarks"))
  (bookmark-save-flag . t))
#+end_src

** elfeed
:PROPERTIES:
:ID:       e018eeba-2e0b-4d9e-b813-bb9c427098f5
:END:

*** elfeed
:PROPERTIES:
:ID: 7454a51a-cb50-47e4-b0ab-7ac493d9d09d
:END:

[[https://github.com/skeeto/elfeed][elfeed]] is a news feed reader. I can give it a set of rss-feeds to blogs I like
to read and then read the articles in emacs! Typically, you'd set the feeds via
[[helpvar:elfeed-feeds][elfeed-feeds]], but with [[https://github.com/remyhonig/elfeed-org][elfeed-org]] I can do it by specifying a set of org files
from which to read my feeds. The org file I use is [[file:.local/config/elfeed.org][elfeed.org]]. The [[helpvar:rmh-elfeed-org-tree-id][rmh-elfeed-org-tree-id]] is the
tags that =elfeed-org= will consider when checking for feeds. Note that it's
case-sensitive so consider this if your tags (like me) capitalized. The
[[helpvar:elfeed-search-filter][elfeed-search-filter]] specifies how far back to go when looking for newsfeed
posts. So if you have some infrequent blogs, you might have to go further back
in time to see older posts.

#+begin_src emacs-lisp
(use-package! elfeed
  :ignore-buffers ("\\*elfeed")
  :commands elfeed
  :setq
  (elfeed-search-filter         . "@1-year-old")
  (elfeed-db-directory          . (concat VOID:DATA-DIR "elfeed/db/"))
  (elfeed-enclosure-default-dir . (concat VOID:DATA-DIR "elfeed/enclosures/"))
  (elfeed-show-entry-switch     . #'pop-to-buffer)
  (elfeed-show-entry-delete     . #'elfeed-kill-buffer)
  (shr-max-image-proportion     . 0.8))
#+end_src

*** elfeed org
:PROPERTIES:
:ID: e385b9b0-4681-4faa-9bfe-c759080ff5d9
:END:

#+begin_src emacs-lisp
(use-package! elfeed-org
  :after elfeed
  :require t
  :setq
  (rmh-elfeed-org-files      . (list (concat VOID:ORG-DIR "elfeed.org")))
  (rmh-elfeed-org-tree-id    . "ELFEED")
  (rmh-elfeed-org-ignore-tag . "IGNORE")
  :config
  (let ((default-directory org-directory))
    (elfeed-org)))
#+end_src

** pomodoro
:PROPERTIES:
:ID: d8056c5a-6b10-49d1-befc-842cea64419e
:END:

[[https://github.com/baudtack/pomodoro.el][pomodoro]] is meant to provide functions to follow the pomodoro style of working.
There is a slight lag in emacs when I play a sound with ~(play-sound-file sound)~.
I might consider doing this asynchronously.

#+begin_src emacs-lisp
(use-package! pomodoro
  :commands pomodoro-start
  :setq
  (pomodoro-play-sounds       . t)
  (pomodoro-work-start-sound  . (concat VOID:ALERT-SOUNDS "A-Tone-His_Self-1266414414.wav"))
  (pomodoro-break-start-sound . (concat VOID:ALERT-SOUNDS "A-Tone-His_Self-1266414414.wav"))
  (pomodoro-work-time         . 25)
  (pomodoro-break-time        . 5)
  (pomodoro-long-break-time   . 15))

(defadvice! pomodoro:play-sound-a (sound)
  "Play sound without using the call-process."
  :override play-pomodoro-sound
  (play-sound-file sound))
#+end_src

** file browsing
:PROPERTIES:
:ID: a8a9edfe-a4c0-4531-92d5-a59991f4af92
:END:

*** dired
:PROPERTIES:
:ID: 4021c260-0529-4a65-a3c4-4651cc33c6ae
:END:

**** dired
:PROPERTIES:
:ID: 55109eeb-8e59-4d15-926e-fbe42ed28056
:END:

#+begin_src emacs-lisp
(use-feature! dired
  :setq
  (dired-recursive-copies . 'always)
  (dired-recursive-deletes . 'top)
  (dired-hide-details-hide-symlink-targets . nil))
#+end_src

**** sort directories first
:PROPERTIES:
:ID: 4b6c0ed8-dbf2-4a65-adcc-1ce326eac465
:END:

#+begin_src emacs-lisp
(defhook! dired:sort-directories-first (dired-after-readin-hook)
  "List directories first in dired buffers."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max))))
  (and (featurep 'xemacs)
       (fboundp 'dired-insert-set-properties)
       (dired-insert-set-properties (point-min) (point-max)))
  (set-buffer-modified-p nil))
#+end_src

**** Create non-existent directory
:PROPERTIES:
:ID: 66981d0c-fe40-4552-9f63-2c39a7d584d2
:END:

#+begin_src emacs-lisp
(defun dired:create-non-existent-directory-h ()
  "Automatically create missing directories when creating new file."
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(after! dired
  (add-to-list 'find-file-not-found-functions 'dired:create-non-existent-directory-h nil #'eq))
#+end_src

*** ranger
:PROPERTIES:
:ID: 7504cab0-ddd9-4069-b6bb-9a5f3161cace
:END:

[[github:ralesi/ranger.el][ranger]] is a file browser built on top of dired that seeks to emulate [[github:ranger/ranger][a VIM
inspired file manager]] of also called =ranger=.

**** bindings
:PROPERTIES:
:ID: 6e779de2-86b8-4856-8569-33f6e69e3b17
:END:

***** important
:PROPERTIES:
:ID: d1835a7a-2a51-4bc5-98f6-4e13d2b98ee4
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "m" #'dired-mark
  "d" #'dired-do-delete
  "s" #'dired-do-symlink
  "e" #'eshell
  "c" #'dired-do-copy
  "M" #'dired-mark-files-containing-regexp
  "r" #'dired-do-rename
  "U" #'dired-unmark-all-marks
  "x" #'dired-do-shell-command
  "a" #'avy-goto-line
  "C-r" #'ranger-refresh
  "f" #'find-file
  "q" #'ranger-close)
#+end_src


***** generic
:PROPERTIES:
:ID: 0b160960-0eab-4faa-911d-0d8aef12cc47
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "A" #'dired-do-find-regexp
  "C" #'dired-do-copy
  "B" #'dired-do-byte-compile
  "D" #'dired-do-delete
  "H" #'dired-do-hardlink
  "L" #'dired-do-load
  "M" #'dired-do-chmod
  "O" #'dired-do-chown
  "P" #'dired-do-print
  "Q" #'dired-do-find-regexp-and-replace
  "R" #'dired-do-rename
  "S" #'dired-do-symlink
  "T" #'dired-do-touch
  "X" #'dired-do-shell-command
  "Z" #'dired-do-compress
  "c" #'dired-do-compress-to
  "!" #'dired-do-shell-command
  "&" #'dired-do-async-shell-command)
#+end_src

***** other
:PROPERTIES:
:ID: 45dab1c7-6558-42bc-a33e-91e1015d94ab
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  "["                   #'dired-prev-dirline
  "]"                   #'dired-next-dirline
  "<"                   #'dired-prev-dirline
  ">"                   #'dired-next-dirline
  "^"                   #'dired-up-directory
  "k"                   #'dired-previous-line
  "j"                   #'dired-next-line
  "h"                   #'dired-up-directory
  "l"                   #'dired-find-file
  "RET"                 #'dired-find-file
  [remap next-line]     #'dired-next-line
  [remap previous-line] #'dired-previous-line)
#+end_src

***** other
:PROPERTIES:
:ID: 1caa851b-211b-4bee-8d2b-0df643410640
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  :prefix "%"
  "u" #'dired-upcase
  "l" #'dired-downcase
  "d" #'dired-flag-files-regexp
  "r" #'dired-do-rename-regexp
  "C" #'dired-do-copy-regexp
  "H" #'dired-do-hardlink-regexp
  "R" #'dired-do-rename-regexp
  "S" #'dired-do-symlink-regexp
  "&" #'dired-flag-garbage-files)
#+end_src

***** marking
:PROPERTIES:
:ID: a4fff7fe-a895-4cf9-9737-685aa1b68e2f
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  :prefix "*"
  "*"         #'dired-mark-executables
  "/"         #'dired-mark-directories
  "@"         #'dired-mark-symlinks
  "%"         #'dired-mark-files-regexp
  "("         #'dired-mark-sexp
  "."         #'dired-mark-extension
  "O"         #'dired-mark-omitted
  "c"         #'dired-change-marks
  "s"         #'dired-mark-subdir-files
  "m"         #'dired-mark
  "u"         #'dired-unmark
  "?"         #'dired-unmark-all-files
  "!"         #'dired-unmark-all-marks
  " <delete>" #'dired-unmark-backward
  " C-n"      #'dired-next-marked-file
  " C-p"      #'dired-prev-marked-file
  "t"         #'dired-toggle-marks)
#+end_src

***** other
:PROPERTIES:
:ID: 64d0879a-6b01-4898-976f-e3363b0a2d2c
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  [remap read-only-mode]   #'dired-toggle-read-only
  [remap toggle-read-only] #'dired-toggle-read-only
  "<delete>"               #'dired-unmark-backward
  [remap undo]             #'dired-undo
  [remap advertised-undo]  #'dired-undo)
#+end_src

***** make sure that =;= uses =M-x=
:PROPERTIES:
:ID:       c63911ca-6d26-4d7c-be76-246639fb6c7a
:END:

#+begin_src emacs-lisp
(general-def 'normal ranger-mode-map
  ";" #'execute-extended-command)
#+end_src

**** entry
:PROPERTIES:
:ID: 2edf3f72-726f-4b31-9ff0-20e5e7d251b1
:END:

#+begin_src emacs-lisp
(use-package! ranger
  :commands deer ranger
  :setq
  (ranger-override-dired-mode . t)
  (ranger-cleanup-eagerly . t)
  (ranger-cleanup-on-disable . t)
  (ranger-omit-regexp . "^\.DS_Store$")
  (ranger-excluded-extensions . '("mkv" "iso" "mp4"))
  (ranger-deer-show-details . nil)
  (ranger-max-preview-size . 10)
  (ranger-modify-header . t)
  (ranger-hide-cursor . t)
  (ranger-dont-show-binary . t))

(setq image-dired-dir (concat VOID:DATA-DIR "image-dir"))
(setq dired-omit-verbose nil)
#+end_src

**** toggle dotfiles
:PROPERTIES:
:ID: 5b9b190c-b4a6-4834-b8c9-def16b0457ac
:END:

There's this wierd intermidiate stage between =hidden= and =format= called =prefer= in
which only some files are hidden. That's wierd, so I get rid of it.

#+begin_src emacs-lisp
(defadvice! ranger:toggle-dotfiles-a ()
  "Show/hide dot-files."
  :override ranger-toggle-dotfiles
  (interactive)
  (setq ranger-show-hidden
        (cl-case ranger-show-hidden
          (hidden 'format)
          (format 'hidden)))
  (ranger-setup))
#+end_src

**** silence window check                                              :silence:
:PROPERTIES:
:ID: e9d83b37-1257-4d78-ae5f-863c4e7198d1
:END:

#+begin_src emacs-lisp
(defadvice! ranger:window-check-shutup-a (orig-fn &rest args)
  "Silence `ranger-window-check'."
  :around ranger-window-check
  (quiet! (apply orig-fn args)))
#+end_src


**** refresh
:PROPERTIES:
:ID:       14e0f5b0-2b6c-44eb-8214-80e20f168871
:END:

#+begin_src emacs-lisp
(defadvice! ranger:refresh-after-new-dir (&rest _)
  :after (mkdir dired-do-rename)
  (when (eq major-mode 'ranger)
    (ranger-refresh)))
#+end_src

*** dired icons
:PROPERTIES:
:ID: 3b4561b3-18a5-475f-a8e8-e9cb7e213881
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons-dired :hook ranger-mode-hook)
#+end_src

** restart emacs
:PROPERTIES:
:ID: 2855f9fe-baac-43c4-9e7d-08c6fd118252
:END:

As it's name suggests [[https://github.com/iqbalansari/restart-emacs][restart-emacs]] provides a function (called ~restart-emacs~)
that restarts emacs. I haven't tested this in EXWM mode.

#+begin_src emacs-lisp
(use-package! restart-emacs :commands restart-emacs)
#+end_src

** version control
:PROPERTIES:
:ID: d99a378c-449f-4a0d-9b88-dd77d5a41bb1
:END:

*** transient
:PROPERTIES:
:ID: baf64a0f-f9fa-4700-bebf-d996018f894f
:END:

#+begin_src emacs-lisp
(use-package! transient
  :setq
  (transient-default-level . 5)
  (transient-levels-file   . (concat VOID:DATA-DIR "transient/levels"))
  (transient-values-file   . (concat VOID:DATA-DIR "transient/values"))
  (transient-history-file  . (concat VOID:DATA-DIR "transient/history")))
#+end_src

*** magit
:PROPERTIES:
:ID: c8a37b6a-46c7-406e-8793-1186f14407e0
:END:

#+begin_src emacs-lisp
(use-package! magit
  :commands magit-status magit-get-current-branch
  :idle-require f s with-editor git-commit package eieio lv transient
  :popup ("magit:"
          (display-buffer-at-bottom)
          (window-height . 0.5))
  :bind (:magit-status-mode-map
         ([remap magit-mode-bury-buffer] . magit/quit))
  :setq
  (magit-completing-read-function . #'magit-builtin-completing-read)
  (magit-revision-show-gravatars . '("^Author:     " . "^Commit:     "))
  (magit-diff-refine-hunk . t)
  (magit-auto-revert-mode . nil)
  :defer-config
  (add-hook 'magit-popup-mode-hook #'hide-mode-line-mode))
#+end_src

*** quitting
:PROPERTIES:
:ID: 49088c3e-6d3a-41b7-aee4-f0bb34c71a0c
:END:

#+begin_src emacs-lisp
(defun magit/quit ()
  "Clean up magit buffers after quitting `magit-status'."
  (interactive)
  (let ((buffers (magit-mode-get-buffers)))
    (magit-restore-window-configuration)
    (mapc #'kill-buffer buffers)))
#+end_src

*** evil-magit
:PROPERTIES:
:ID: 02025227-8f1a-45aa-b40a-aabf43a3041c
:END:

#+begin_src emacs-lisp
(use-package! evil-magit
  :before-call magit-status
  :defer-config
  (shut-up! (evil-magit-init))
  (setq evil-magit-state 'normal)
  (require 'evil-magit nil :no-error))
#+end_src

*** git-gutter
:PROPERTIES:
:ID: 96f0c876-533c-4b1a-a4c1-7b6c9bf58c03
:END:

#+begin_src emacs-lisp
(use-package! git-gutter :commands git-gutter-mode)
#+end_src

** server                                                             :built-in:
:PROPERTIES:
:ID: b2bc973f-7d24-431c-90bc-4c1055a9fc0a
:END:

#+begin_src emacs-lisp
(when (display-graphic-p)
  (after! server
    (when-let* ((name (getenv "EMACS_SERVER_NAME")))
      (setq server-name name))
    (unless (server-running-p)
      (server-start))))
#+end_src

** TODO autorevert                                                    :disabled:
:PROPERTIES:
:ID: 1d7c8bac-e523-4251-bb3c-b85f592fbfc3
:END:

#+begin_src emacs-lisp
(use-feature! autorevert
  :after-call switch-to-buffer find-file
  :setq
  (auto-revert-verbose . t)
  (auto-revert-use-notify . nil)
  (auto-revert-stop-on-user-input . nil)
  (revert-without-query . (list "."))
  :defer-config
  (defun auto-revert-buffer-maybe ()
    (unless (or (bound-and-true-p auto-revert-mode)
                (active-minibuffer-window))
      (auto-revert-handler)))

  (defhook! auto-revert-buffer-maybe (void:after-switch-buffer-hook)
    "Auto revert current buffer, if necessary."
    (auto-revert-buffer-maybe))

  (defhook! auto-revert-auto-revert-visible-buffers (focus-in-hook after-save-hook)
    "Auto revert stale buffers in visible windows, if necessary."
    (--each (-uniq (mapcar #'window-buffer (window-list)))
      (with-current-buffer it
        (auto-revert-buffer-maybe)))))
#+end_src

** security
:PROPERTIES:
:ID: 313aedc2-c737-42b4-afaa-069ec33803aa
:END:

*** pass
:PROPERTIES:
:ID: 78e2ac6e-e465-482c-80bf-19ddfdaff31d
:END:

**** pass
:PROPERTIES:
:ID: 4ab61136-e27a-4bd1-bfd6-d99015819a1b
:END:

#+begin_src emacs-lisp
(use-package! pass
  :commands pass
  :setq
  (pass-username-field . "username"))
#+end_src

**** get password
:PROPERTIES:
:ID: 52d9423c-32fb-4538-9e69-537e458b52d5
:END:

#+begin_src emacs-lisp
(defun pass/get-password ()
  "Copy password from entry into kill ring."
  (interactive)
  (require 'pass)
  (password-store-copy
   (completing-read "Copy password of entry: "
                    (password-store-list (password-store-dir))
                    nil
                    t)))
#+end_src

**** auth source pass
:PROPERTIES:
:ID: 2cd2fcee-e503-4430-9f37-43fecb12ac19
:END:

#+begin_src emacs-lisp
(use-package! auth-source-pass
  ;; (:after-hook pre-command-hook)
  :setq
  (auth-source-pass-filename . "~/.password-store")
  (auth-source-pass-port-separator . ":")
  :defer-config (auth-source-pass-enable))
#+end_src

**** epa
:PROPERTIES:
:ID: 9eeb5714-a5dc-4f88-8992-0bd3a158878b
:END:

#+begin_src emacs-lisp
(use-feature! epa
  :setq
  (epg-gpg-program . "gpg2")
  (epa-pinentry-mode . 'loopback))
#+end_src

*** password-generator
:PROPERTIES:
:ID: 11bc4d9a-78df-4010-b81a-4a87b1443ea9
:END:

I'm sure that =pass= can generate custom passwords with some options or other, but
I do not like dealing with the command line. I want real elisp code please.

#+begin_src emacs-lisp
(use-package! password-generator
  :commands password-generator-simple password-generator-paranoid)
#+end_src

** uuidgen
:PROPERTIES:
:ID: 9becd3bb-e74e-4644-a716-5b941fbbda50
:END:

#+begin_src emacs-lisp
(use-package! uuidgen)
#+end_src

** xr
:PROPERTIES:
:ID: 75c56163-9ce1-4726-969a-350fcc56395f
:END:

This package is the inverse of =rx=. It takes a regular expression and returns the
=rx= representation.

#+begin_src emacs-lisp
(use-package! xr
  ;; :functions xr xr-pp
  )
#+end_src

** pdf-tools
:PROPERTIES:
:ID:       63343f9d-6b19-43de-8302-d1344d571949
:END:

*** pdf-tools
:PROPERTIES:
:ID: 163d8880-6a7d-4479-a7e4-e333e4f930da
:END:

#+begin_src emacs-lisp
(use-package! pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :bind (:pdf-view-mode-map
         ("j" . pdf-view-next-line-or-next-page)
         ("k" . pdf-view-previous-line-or-previous-page)))
#+end_src

*** epd-pdf-info-program
:PROPERTIES:
:ID:       25826061-a4a7-4f8a-8d3b-bdd5a80f70d0
:END:

#+begin_src emacs-lisp
(defadvice! pdf-tools:build-pdf-info-program-a ()
  "Build the pdf-info program if it hasn't already been built."
  :before pdf-view-mode
  (unless (file-executable-p pdf-info-epdfinfo-program)
    (let ((wconf (current-window-configuration)))
      (pdf-tools-install)
      (message "Building epdfinfo, this will take a moment...")
      (--each (buffer-list)
        (with-current-buffer it
          (when (eq major-mode 'pdf-view-mode)
            (fundamental-mode))))
      (while compilation-in-progress
        ;; Block until `pdf-tools-install' is done
        (redisplay)
        (sleep-for 1))
      ;; HACK If pdf-tools was loaded by you opening a pdf file, once
      ;;      `pdf-tools-install' completes, `pdf-view-mode' will throw an error
      ;;      because the compilation buffer is focused, not the pdf buffer.
      ;;      Therefore, it is imperative that the window config is restored.
      (when (file-executable-p pdf-info-epdfinfo-program)
        (set-window-configuration wconf)))))
#+end_src

*** bindings
:PROPERTIES:
:ID:       506c568c-0473-4db6-82b6-cc91174b0ce4
:END:

#+begin_src emacs-lisp
(general-def 'normal pdf-view-mode-map
  "j" #'pdf-view-next-line-or-next-page
  "k" #'pdf-view-previous-line-or-previous-page
  "0" #'pdf-view-first-page
  "9" #'pdf-view-last-page
  "s" #'pdf-view-fit-width-to-window)
#+end_src

** circe
:PROPERTIES:
:ID: 65495471-b9b4-47cc-aa85-5a6ead4c6538
:END:

#+begin_src emacs-lisp
(use-package! circe)
#+end_src

** peristent scratch
:PROPERTIES:
:ID: 8180d63f-1c0c-4a03-8dbc-9a99bf0c9f0b
:END:

#+begin_src emacs-lisp
(use-package! persistent-scratch
  :commands persistent-scratch-restore
  :setq (persistent-scratch-save-file . (concat VOID:DATA-DIR "scratch")))
#+end_src

** alert
:PROPERTIES:
:ID: 07960fe7-7ef5-48db-bfd9-86c980a7599d
:END:

Notifications are very important. Messages from the =*Messages*= buffer are not enough.

#+begin_src emacs-lisp
(use-package! alert
  :setq
  (alert-default-style . 'libnotify)
  (alert-log-messages . t))
#+end_src

** sudo-edit
:PROPERTIES:
:ID:       38a9aec6-f826-4ebc-82f1-08ace40c2287
:END:

Sometimes I'll want edit files with root privileges. This package let's you edit
a file from another user (=root= by default). To use it you just call [[helpfn:sudo-edit][sudo-edit]]
on the buffer you'd like to edit.

#+begin_src emacs-lisp
(use-package! sudo-edit :commands sudo-edit)
#+end_src

** yadm
:PROPERTIES:
:ID:       5783c785-cee0-4705-9b6b-eec5124f34a0
:END:

#+begin_src emacs-lisp
(defun void/dotfile-status ()
  (interactive)
  (require 'tramp)
  (add-to-list 'tramp-methods
               '("yadm"
                 (tramp-login-program "yadm")
                 (tramp-login-args (("enter")))
                 (tramp-login-env (("SHELL") ("/bin/sh")))
                 (tramp-remote-shell "/bin/sh")
                 (tramp-remote-shell-args ("-c"))))
  (magit-status "/yadm::"))
#+end_src

** plantuml
:PROPERTIES:
:ID:       4c452dea-a404-4443-9ecc-189c940d201e
:END:

#+begin_src emacs-lisp
(use-package! plantuml-mode
  :init
  (after! org
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
  :setq
  (plantuml-executable-path . (executable-find "plantuml"))
  (plantuml-jar-path . "/usr/share/java/plantuml/plantuml.jar")
  (plantuml-default-exec-mode . 'jar)
  (org-plantuml-jar-path . "/usr/share/java/plantuml/plantuml.jar")
  (org-plantuml-executable-path . (executable-find "plantuml")))
#+end_src

** autosave
:PROPERTIES:
:ID:       32fe3a49-5cff-4bc5-9a62-ef4a5ac50b7d
:END:

[[https://github.com/kentaro/auto-save-buffers-enhanced][auto-save-enhanced]] is a package that replaces and (as its name suggests) enhances Emacs's
stock autosaving. Unlike the

#+begin_src emacs-lisp
(use-package! auto-save-buffers-enhanced
  :setq
  (auto-save-buffers-enhanced-interval . 5.0)
  (auto-save-buffers-enhanced-quiet-save-p . t)
  (auto-save-buffers-enhanced-exclude-regexps . nil)
  (auto-save-buffers-enhanced-include-regexps (rx (1+ anything)))
  :config
  (auto-save-buffers-enhanced t))
#+end_src

* Languages
:PROPERTIES:
:ID: 51e3b9b1-0e74-431e-a113-fe6f86a4b22a
:END:

** lisp
:PROPERTIES:
:ID: 9b7ec12e-e62b-447a-90dd-2fef0cc952ad
:END:

*** sly
:PROPERTIES:
:ID: 2e4ddfa7-2243-458c-8045-ef4a9f652d9c
:END:

[[https://github.com/joaotavora/sly][sly]] is an alternative to [[https://github.com/slime/slime][slime]].

#+begin_src emacs-lisp
(use-package! sly
  :setq (inferior-lisp-program . "/usr/bin/sbcl"))
#+end_src

*** clojure
:PROPERTIES:
:ID: 7941233e-6524-4da1-b6d9-05faf8991824
:END:

[[https://github.com/clojure-emacs/cider][cider]] is a repl for clojure.

#+begin_src emacs-lisp
(use-package! cider :commands cider)
#+end_src

*** emacs lisp
:PROPERTIES:
:ID: f90ab909-dd53-41ca-bc77-849fb89ac6c8
:END:

**** printing
:PROPERTIES:
:ID: 954a5a72-1db9-4a40-b9cb-e9099bfd0f83
:END:

#+begin_src emacs-lisp
(setq eval-expression-print-length nil)
(setq eval-expression-print-level nil)
#+end_src

**** electric-pair
:PROPERTIES:
:ID: 1febf5ab-f545-4a72-97ef-892740575a3a
:END:

#+begin_src emacs-lisp
#+end_src

**** fix elisp indentation
:PROPERTIES:
:ID: aa7f846f-8802-4c75-88d8-a438e2f63ccd
:END:

A problem with elisp indentation is indents quoted lists the way functions
should be indented. It has been discussed in at least three stackoverflow
questions [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned/10233#10233][here]], [[https://stackoverflow.com/questions/49222433/align-symbols-in-plist][here]] and [[https://stackoverflow.com/questions/22166895/customize-elisp-plist-indentation][here]]. In all these questions the solutions have not
been satisfactory. Some of them recommend using [[helpfn:common-lisp-indent-function][common-lisp-indent-function]] as
the value of [[helpvar:lisp-indent-function][lisp-indent-function]]. This works for indenting a quoted list
properly, but at the expense of changing the way that many other elisp forms are
indented. Common Lisp's indentation is different from Elisp's. Others recommend
using [[https://github.com/Fuco1/.emacs.d/blob/af82072196564fa57726bdbabf97f1d35c43b7f7/site-lisp/redef.el#L12-L94][Fuco1's lisp indent function hack]]. This also is not ideal. For one thing it
only works for quoted lists with keywords but not generic symbols. Another thing
is that the change should really be occurring in [[helpfn:calculate-lisp-indent][calculate-lisp-indent]].
~calculate-lisp-indent~ is a function that returns what the indentation should be
for the line at point. Since Fuco1 did not modify ~calculate-lisp-indent~ the
*wrong* indentation still returned by this function and the modified
~lisp-indent-function~ just cleans up the mess. Better is just fixing the source
of the problem. You can check out a more in-depth explanation looking at my
[[https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/][reddit-post]] or looking at an answer I gave to [[https://emacs.stackexchange.com/questions/10230/how-to-indent-keywords-aligned][this question]].

#+begin_src emacs-lisp
(defadvice! void:calculate-lisp-indent-a (&optional parse-start)
  "Add better indentation for quoted and backquoted lists.
The change to this function."
  :override calculate-lisp-indent
  (defvar calculate-lisp-indent-last-sexp)
  (save-excursion
    (beginning-of-line)
    (let ((indent-point (point))
          state
          ;; setting this to a number inhibits calling hook
          (desired-indent nil)
          (retry t)
          calculate-lisp-indent-last-sexp containing-sexp)
      (cond ((or (markerp parse-start) (integerp parse-start))
             (goto-char parse-start))
            ((null parse-start) (beginning-of-defun))
            (t (setq state parse-start)))
      (unless state
        ;; Find outermost containing sexp
        (while (< (point) indent-point)
          (setq state (parse-partial-sexp (point) indent-point 0))))
      ;; Find innermost containing sexp
      (while (and retry
                  state
                  (> (elt state 0) 0))
        (setq retry nil)
        (setq calculate-lisp-indent-last-sexp (elt state 2))
        (setq containing-sexp (elt state 1))
        ;; Position following last unclosed open.
        (goto-char (1+ containing-sexp))
        ;; Is there a complete sexp since then?
        (if (and calculate-lisp-indent-last-sexp
                 (> calculate-lisp-indent-last-sexp (point)))
            ;; Yes, but is there a containing sexp after that?
            (let ((peek (parse-partial-sexp calculate-lisp-indent-last-sexp
                                            indent-point 0)))
              (if (setq retry (car (cdr peek))) (setq state peek)))))
      (if retry
          nil
        ;; Innermost containing sexp found
        (goto-char (1+ containing-sexp))
        (if (not calculate-lisp-indent-last-sexp)
            ;; indent-point immediately follows open paren.
            ;; Don't call hook.
            (setq desired-indent (current-column))
          ;; Find the start of first element of containing sexp.
          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
          (cond ((looking-at "\\s(")
                 ;; First element of containing sexp is a list.
                 ;; Indent under that list.
                 )
                ((> (save-excursion (forward-line 1) (point))
                    calculate-lisp-indent-last-sexp)
                 ;; This is the first line to start within the containing sexp.
                 ;; It's almost certainly a function call.
                 (if (or
                      (= (point) calculate-lisp-indent-last-sexp)

                      (when-let (after (char-after (1+ containing-sexp)))
                        (char-equal after ?:))

                      (when-let (point (char-before containing-sexp))
                        (char-equal point ?'))

                      (let ((quoted-p nil)
                            (point nil)
                            (positions (nreverse (butlast (elt state 9)))))
                        (while (and positions (not quoted-p))
                          (setq point (pop positions))
                          (setq quoted-p
                                (or
                                 (and (char-before point)
                                      (char-equal (char-before point) ?'))
                                 (save-excursion
                                   (goto-char (1+ point))
                                   (looking-at-p "quote[\t\n\f\s]+(")))))
                        quoted-p))
                     ;; Containing sexp has nothing before this line
                     ;; except the first element.  Indent under that element.
                     nil
                   ;; Skip the first element, find start of second (the first
                   ;; argument of the function call) and indent under.
                   (progn (forward-sexp 1)
                          (parse-partial-sexp (point)
                                              calculate-lisp-indent-last-sexp
                                              0 t)))
                 (backward-prefix-chars))
                (t
                 ;; Indent beneath first sexp on same line as
                 ;; `calculate-lisp-indent-last-sexp'.  Again, it's
                 ;; almost certainly a function call.
                 (goto-char calculate-lisp-indent-last-sexp)
                 (beginning-of-line)
                 (parse-partial-sexp (point) calculate-lisp-indent-last-sexp
                                     0 t)
                 (backward-prefix-chars)))))
      ;; Point is at the point to indent under unless we are inside a string.
      ;; Call indentation hook except when overridden by lisp-indent-offset
      ;; or if the desired indentation has already been computed.
      (let ((normal-indent (current-column)))
        (cond ((elt state 3)
               ;; Inside a string, don't change indentation.
               nil)
              ((and (integerp lisp-indent-offset) containing-sexp)
               ;; Indent by constant offset
               (goto-char containing-sexp)
               (+ (current-column) lisp-indent-offset))
              ;; in this case calculate-lisp-indent-last-sexp is not nil
              (calculate-lisp-indent-last-sexp
               (or
                ;; try to align the parameters of a known function
                (and lisp-indent-function
                     (not retry)
                     (funcall lisp-indent-function indent-point state))
                ;; If the function has no special alignment
                ;; or it does not apply to this argument,
                ;; try to align a constant-symbol under the last
                ;; preceding constant symbol, if there is such one of
                ;; the last 2 preceding symbols, in the previous
                ;; uncommented line.
                (and (save-excursion
                       (goto-char indent-point)
                       (skip-chars-forward " \t")
                       (looking-at ":"))
                     ;; The last sexp may not be at the indentation
                     ;; where it begins, so find that one, instead.
                     (save-excursion
                       (goto-char calculate-lisp-indent-last-sexp)
                       ;; Handle prefix characters and whitespace
                       ;; following an open paren.  (Bug#1012)
                       (backward-prefix-chars)
                       (while (not (or (looking-back "^[ \t]*\\|([ \t]+"
                                                     (line-beginning-position))
                                       (and containing-sexp
                                            (>= (1+ containing-sexp) (point)))))
                         (forward-sexp -1)
                         (backward-prefix-chars))
                       (setq calculate-lisp-indent-last-sexp (point)))
                     (> calculate-lisp-indent-last-sexp
                        (save-excursion
                          (goto-char (1+ containing-sexp))
                          (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
                          (point)))
                     (let ((parse-sexp-ignore-comments t)
                           indent)
                       (goto-char calculate-lisp-indent-last-sexp)
                       (or (and (looking-at ":")
                                (setq indent (current-column)))
                           (and (< (line-beginning-position)
                                   (prog2 (backward-sexp) (point)))
                                (looking-at ":")
                                (setq indent (current-column))))
                       indent))
                ;; another symbols or constants not preceded by a constant
                ;; as defined above.
                normal-indent))
              ;; in this case calculate-lisp-indent-last-sexp is nil
              (desired-indent)
              (t
               normal-indent))))))
#+end_src

**** highlight-quoted
:PROPERTIES:
:ID: afacf700-86a9-4c1b-9062-7a28c11dcf69
:END:

[[https://github.com/Fanael/highlight-quoted][highlight-quoted]] highlights quotes, backticks and.

#+begin_src emacs-lisp
(use-package! highlight-quoted
  :hook emacs-lisp-mode-hook)
#+end_src

**** buttercup
:PROPERTIES:
:ID: 228fb805-620d-4519-822f-f633540f7b58
:END:

[[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]] is an emacs debugging suite.

#+begin_src emacs-lisp
(use-package! buttercup)
#+end_src

**** outorg
:PROPERTIES:
:ID: a3461ce0-8c5d-4bea-950e-b18ea6422672
:END:

Outorg adds overlays to make an org buffer look more readable. I do not want
these overlays.

#+begin_src emacs-lisp
(use-package! outorg
  ;; TODO: should be changed to `:functions'
  :commands outorg-convert-back-to-code outorg-convert-to-org)

(defadvice! outorg:do-not-add-overlays-a (orig-fn &rest args)
  :around outorg-wrap-source-in-block
  (cl-letf (((symbol-function #'overlay-put) #'ignore))
    (apply orig-fn args)))
#+end_src

**** outshine
:PROPERTIES:
:ID: ffeddf0d-aa29-473f-b73c-d94971d91da9
:END:

[[https://github.com/alphapapa/outshine][outshine]] is a clever package that tries to make elisp mode more like org mode.
It colors certain comments like org headings, and adds function for convertion
from elisp to org. My [[helpvar:VOID-INIT-FILE][void:init-file]] is written with =outshine= in mind.

#+begin_src emacs-lisp
(use-package! outshine
  :hook emacs-lisp-mode-hook
  :defer-config
  (general-def '(normal) emacs-lisp-mode-map
    "TAB" #'outline-toggle-children))
#+end_src

**** macrostep
:PROPERTIES:
:ID: 81e59dcc-7e23-4dd1-9917-06f0ab59f2a6
:END:

[[https://github.com/joddie/macrostep][macrostep]]

#+begin_src emacs-lisp
(use-package! macrostep
  :commands (macrostep-expand macrostep-collapse macrostep-collapse-all)
  :init (define-localleader-key!
          :infix "m"
          :keymaps 'emacs-lisp-mode-map
          "e" (list :def #'macrostep-expand :wk "expand")
          "c" (list :def #'macrostep-collapse :wk "collapse")
          "C" (list :def #'macrostep-collapse-all :wk "collapse all")))
#+end_src

*** hy
:PROPERTIES:
:ID: 6b62fbdd-448b-4b69-82f8-1e1231a10c3e
:END:

#+begin_src emacs-lisp
(use-package! hy-mode :mode "\\.hy\\'")
#+end_src

** markdown
:PROPERTIES:
:ID: 9d684855-961a-4294-8b90-44d2796526e2
:END:

I'm adding [[https://github.com/jrblevin/markdown-mode][markdown-mode]] so I can see =README= files.

#+begin_src emacs-lisp
(use-package! markdown-mode :mode "\\.md\\'")
#+end_src

** org
:PROPERTIES:
:ID: 7fd3bb4f-354c-4427-914c-9de2223f5646
:END:

Org mode introduces an elegant way of dealing with different languages in one
file. In an org file the background language is Org's own markup language that's
typically composed mostly of outline headlines. In the org markup language you
can embed multiple different languages in [[][source blocks]]. Additionally, org
mode provides a library of functions for dealing with these files. This includes
things like executing (or evaluating) source blocks, moving headlines to other
files, or even converting an org mode document into another format. As the name
=org= suggests, org is tool that's used for organization of data.

*** structures
:PROPERTIES:
:ID: 85ac0a35-4e44-41e6-a1f1-54698cb86212
:END:

**** todo-keywords
:PROPERTIES:
:ID: a32da379-654e-4b1a-83f4-cf9e4003d578
:END:

***** todo keywords
:PROPERTIES:
:ID: 2f0459d4-9afd-4fd9-bdba-c0a3dc993963
:END:

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "NEXT" "WAITING" "|" "DONE")
          (sequence "|" "DUPLICATE")
          (sequence "|" "CANCELLED"))))
#+end_src

***** return todo-keywords
:PROPERTIES:
:ID: 38385aee-1326-46d8-9eef-3bfa2e57c0cc
:END:

Knowing what the exact todo-keywords are is important so that I know exactly
when headline contents begin.

#+begin_src emacs-lisp
(defun org:todo-keywords ()
  "Return list of all TODO keywords."
  (--filter (and (stringp it) (not (string= "|" it)))
            (flatten-list org-todo-keywords)))
#+end_src

***** heading start
:PROPERTIES:
:ID: 0ebf90e8-cd14-4364-b26a-da6676b29089
:END:

#+begin_src emacs-lisp
(defun org:heading-start-regexp ()
  "Compute regexp for heading start."
  (rx-to-string `(: bol (1+ "*") space (opt (or ,@(org:todo-keywords)) space))))

(defun org:heading-goto-start ()
  "Go to first letter of headline."
  (let (case-fold-search)
    (beginning-of-line)
    (re-search-forward (org:heading-start-regexp)
                       (line-end-position))))
#+end_src

**** return
:PROPERTIES:
:ID: c161f1b0-dbc0-4240-8102-69e95f3fd62f
:END:

#+begin_src emacs-lisp
(defun org/dwim-return ()
  "Do what I mean."
  (interactive)
  (cond
   (and (org-at-heading-p)
        (looking-at-p (rx (* (or "\s" "\t"))
                          (opt (1+ ":" (1+ letter)) ":") eol)))
   (org/insert-heading-below)
   (t
    (call-interactively #'org-return))))
#+end_src

**** TODO scroll window to top
:PROPERTIES:
:ID: 149e9f0c-e984-42e6-afb1-03502eda41ea
:END:

I need this function for some org actions. Evil has this as
[[helpfn:evil-scroll-line-to-top][evil-scroll-line-to-top]] but I didn't want to depend on evil.

#+begin_src emacs-lisp
(defun org:scroll-window-to-top ()
  (let ((line (line-number-at-pos (point)))
        (col (current-column)))
    (goto-char (point-min))
    (forward-line (1- line))
    (move-to-column col)))
#+end_src

**** TODO fix nearby line adjustment
:PROPERTIES:
:ID: 6168590a-db23-4f0b-bdd9-9d9666624af6
:END:

=counsel-org-goto= is lets you fuzzy search a term among org headings.

#+begin_src emacs-lisp
(defun org:prettify-nearby-headlines ()
  "Prettify display of nearby headlines."
  (save-excursion
    (while (org-up-heading-safe)
      (outline-show-children)))
  (outline-show-children)
  (let ((line (line-number-at-pos (point))))
    (goto-char (point-min))
    (forward-line (1- line)))
  (recenter (1- (max 1 scroll-margin)))
  (org-beginning-of-line))
#+end_src

**** helpers
:PROPERTIES:
:ID: 50b79866-2905-459e-9723-6b822dde9127
:END:

***** org-heading-folded-p
:PROPERTIES:
:ID: 919b2b6e-2c43-4fd5-87cc-cfc62cf75405
:END:

#+begin_src emacs-lisp
(defun org:heading-folded-p ()
  "Return t if an current heading is folded."
  (outline-invisible-p (line-end-position)))
#+end_src

***** headline-name
:PROPERTIES:
:ID: 97ac2e07-9db1-43e4-a71b-1a4ed959c7b1
:END:

#+begin_src emacs-lisp
(defun org:heading-name ()
  "Return the headline of the current heading."
  (interactive)
  (save-excursion
    (org-back-to-heading)
    (unless org-complex-heading-regexp
      (let ((major-mode 'org-mode))
        (org-set-regexps-and-options)))
    (looking-at org-complex-heading-regexp)
    (match-string 4)))
#+end_src

***** beginning-of-headline
:PROPERTIES:
:ID: ac43317c-485e-4efb-aff7-36c3ab69ea79
:END:

#+begin_src emacs-lisp
(defun org:beginning-of-headline (&optional end)
  "Return the character position at the end of the headline."
  (let (case-fold-search)
    (save-excursion
      (org-back-to-heading)
      (looking-at org-complex-heading-regexp)
      (funcall (if end #'match-end #'match-beginning) 4))))
#+end_src

***** end-of-headline
:PROPERTIES:
:ID: b9f9115c-4f84-4894-b926-8c1b948c0246
:END:

#+begin_src emacs-lisp
(defun org:end-of-headline ()
  "Return the character position at the end of the headline."
  (interactive)
  (org:beginning-of-headline t))
#+end_src

***** heading
:PROPERTIES:
:ID: f6b74522-180a-485c-b946-f7fa2e18a826
:END:

#+begin_src emacs-lisp
(defun org:heading-end-of-heading ()
  "Return point at end of heading.")

(defun org:heading-block-lang ()
  "Return the language of the current language's source block."
  (save-excursion
    (org-back-to-heading)
    (re-search-forward org-babel-src-block-regexp)))
#+end_src

**** preserve point
:PROPERTIES:
:ID: 52781cc9-e1ca-4618-aa1b-6845494b5dc6
:END:

If possible org commands should preserve =point=. If this isn't possible (ie. when
deleting a subtree with), then should leave point at a place that is easy to
predict and convenient (as opposed to a random location).

***** start on beginning of first heading
:PROPERTIES:
:ID: 81732dde-85f7-4336-a9fd-351d8f74671f
:END:

It looks nice if when I'm on a heading when I first enter an org file.

#+begin_src emacs-lisp
(defhook! goto-first-heading (org-mode-hook)
  "Go to first heading when entering an org-mode file."
  (when (org-at-heading-p)
    (beginning-of-line)
    (org:heading-goto-start)))
#+end_src

***** fix bug with next visible heading
:PROPERTIES:
:ID: 9a3759e8-8928-47cb-97c9-9ce5ee673cba
:END:

[[helpfn:outline-next-visible-heading][outline-next-visible-heading]] continues to =EOB= after reaching the last visible
heading. It should just stop at the last visible heading. This advice checks to
see if it's gone farther than it should have and in that case goes back.

#+begin_src emacs-lisp
(defadvice! outline:dont-end-at-eob-a (orig-fn &rest args)
  "Fix bug where the next heading moves past last visible heading."
  :around outline-next-visible-heading
  (apply orig-fn args)
  (when (eobp) (apply #'outline-previous-visible-heading args)))
#+end_src

***** go to proper point after refile
:PROPERTIES:
:ID: 591045df-8d3e-4ff7-b4bc-c949222a0717
:END:

#+begin_src emacs-lisp
(defadvice! org:end-at-start-of-headline-a (&rest _)
  "After running body end at headline start."
  :after org-refile org-cut-subtree org-copy-subtree org/jump-to-headline
  (when (org-at-heading-p) (org:heading-goto-start)))
#+end_src

**** commands
:PROPERTIES:
:ID: 86f0b9be-0033-46bd-8d02-7e506fe73ead
:END:

***** dwim
:PROPERTIES:
:ID: 93a6e45c-b23b-4639-9e1c-9f1aef0fb95a
:END:

****** insert
:PROPERTIES:
:ID: 1b8ccbb8-2614-4d2e-ab7c-e8bd23c2c02d
:END:

#+begin_src emacs-lisp
(defun org/dwim-insert-elisp-block ()
  "Insert elisp block."
  (interactive)
  (save-excursion
    (unless (org-at-heading-p)
      (org-back-to-heading))
    (org-end-of-subtree)
    (goto-char (line-end-position))
    (insert (concat "\n\n"
                    "#+begin_src emacs-lisp"
                    "\n"
                    "#+end_src"))
    (forward-line -1)))
#+end_src

****** eval
:PROPERTIES:
:ID: e804805a-ba96-41d0-aa6f-6756c65e9abf
:END:

#+begin_src emacs-lisp
(defun org/dwim-eval-block ()
  "Eval block contents."
  (interactive)
  (unless (org-at-heading-p)
    (user-error "Not in source block"))
  (save-window-excursion
    (org-babel-execute-subtree)))
#+end_src

****** next-line
:PROPERTIES:
:ID: d8d118a7-78e8-4602-81b3-17fd1d8ab79c
:END:

#+begin_src emacs-lisp
(defun org/dwim-next-line (&optional backward)
  "Go to the start of the next heading.
If DIR is a negative integer, go the opposite direction: the start of the
  previous heading."
  (interactive)
  (outline-next-visible-heading (if backward -1 1))
  (when (org-at-heading-p)
    (org:heading-goto-start)))
#+end_src

****** previous-line
:PROPERTIES:
:ID: e7562921-77ca-4d90-be57-1d586ec26ee5
:END:

#+begin_src emacs-lisp
(defun org/dwim-previous-line (&optional forward)
  (interactive)
  (funcall #'org/dwim-next-line (not forward)))
#+end_src

****** up-heading
:PROPERTIES:
:ID: 1f25d3b0-7280-4012-94b5-b0fea2f686b3
:END:

#+begin_src emacs-lisp
(defun org/dwim-up-heading ()
  ""
  (interactive)
  (condition-case nil
      (progn (outline-up-heading 1)
             (outline-hide-subtree)
             (outline-show-children)
             (org:heading-goto-start))
    (error
     (unless (outline-invisible-p (line-end-position))
       (outline-hide-subtree))
     (org:heading-goto-start))))
#+end_src

***** jump to heading                                                      :avy:
:PROPERTIES:
:ID: 3c396b33-437c-410f-aff6-2106ade42621
:END:

#+begin_src emacs-lisp
(defun org/avy-jump-to-heading ()
  "Jump to the beginning of a visible heading using `avy'."
  (interactive)
  (org-back-to-heading)
  (avy-jump (rx bol (1+ "*") space (group nonl))
            :beg (window-start)
            :end (window-end)
            :pred `(lambda () (/= (1+ ,(point)) (point)))
            :action (lambda (point) (goto-char point)
                      (org:heading-goto-start))
            :group 1))
#+end_src

***** dwim jump to heading
:PROPERTIES:
:ID: 7ad9d757-57ba-4537-821f-8beae57f39eb
:END:

#+begin_src emacs-lisp
(defun org/dwim-jump-to-heading ()
  ""
  (interactive)
  (let ((origin (point)))
    (if (and (org/avy-jump-to-heading)
             (org:heading-folded-p))
        (progn (outline-toggle-children)
               (org:scroll-window-to-top))
      (goto-char origin))))
#+end_src

***** inserting
:PROPERTIES:
:ID: e99abeff-328b-48e4-aebb-00db34fa98e8
:END:

In my eyes, many Org functions are unnecessarily complicated and long. Often they
need to perform a simple task (like inserting a heading) but lose their
fundamental purpose in their inclusion of numerous obscure and opinionated
options. For this reason I wrote my own insert heading functions.

****** newlines between headings
:PROPERTIES:
:ID: e0dcf718-120c-488d-9d37-96243132bf0b
:END:

#+begin_src emacs-lisp
(defvar org:newlines-between-headings "\n\n"
  "Number of newlines between headings.")
#+end_src

****** heading above
:PROPERTIES:
:ID: 6c227dea-e10b-4f86-a01b-5d223d18e3a4
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-above (&optional below)
  "Insert a heading above the current heading."
  (interactive)
  (funcall #'org/insert-heading-below (not below)))
#+end_src

****** heading below
:PROPERTIES:
:ID: b059a431-e29c-4f2c-ab5e-8d2d02636405
:END:

#+begin_src emacs-lisp
(defun org/insert-heading-below (&optional above)
  "Insert heading below."
  (interactive)
  (let* ((on-heading-p (ignore-errors (org-back-to-heading)))
         (newlines org:newlines-between-headings)
         (level (or (org-current-level) 1))
         (heading (concat (make-string level ?*) "\s")))
    (cond ((not on-heading-p)
           (insert heading))
          (above
           (goto-char (line-beginning-position))
           (insert heading)
           (save-excursion (insert newlines)))
          (t ; below
           (org-end-of-subtree)
           (insert (concat newlines heading))))
    (run-hooks 'org-insert-heading-hook)))
#+end_src

****** subheading
:PROPERTIES:
:ID: cf910dcf-6250-4b6a-80d5-63ac457d4a81
:END:

#+begin_src emacs-lisp
(defun org/insert-subheading ()
  "Insert subheading below current heading."
  (interactive)
  (org/insert-heading-below)
  (org-demote))
#+end_src

*** source blocks
:PROPERTIES:
:ID: 2bb1b8ef-f41c-4dfa-8e47-549326f7ce05
:END:

Many of these =org-src= variables are not very applicable to me anymore because I
use =edit-indirect= to edit source blocks.
:PROPERTIES:
:ID: 3329768f-2669-43be-ad85-da2239082cc2
:END:

#+begin_src emacs-lisp
(use-feature! org-src
  :setq
  (org-edit-src-persistent-message . nil)
  (org-src-window-setup . 'current-window)
  (org-src-fontify-natively . t)
  (org-src-ask-before-returning-to-edit-buffer . nil)
  (org-src-preserve-indentation . t)
  (org-src-tab-acts-natively . t)
  (org-confirm-babel-evaluate . nil)
  (org-babel-default-header-args . '((:session . "none")
                                     (:results . "silent")
                                     (:exports . "code")
                                     (:cache . "no")
                                     (:initeb . "no")
                                     (:hlines . "no")
                                     (:tangle . "yes"))))
#+end_src

*** org-mode
:PROPERTIES:
:ID: c1c5724e-028a-42a5-a982-28d57203b335
:END:

#+begin_src emacs-lisp
(use-package! org
  :idle-require
  calendar find-func format-spec org-macs org-compat org-faces org-entities
  org-list org-pcomplete org-src org-footnote org-macro ob org org-agenda
  org-capture
  :setq
  (org-directory . VOID:ORG-DIR)
  (org-archive-location . (concat org-directory "archive.org::"))
  (org-default-notes-file . (concat org-directory "notes.org"))
  (org-fontify-emphasized-text . t)
  (org-hide-emphasis-markers . t)
  (org-pretty-entities . t)
  (org-fontify-whole-heading-line . t)
  (org-fontify-done-headline . t)
  (org-fontify-quote-and-verse-blocks . t)
  (org-adapt-indentation . nil)
  (org-cycle-separator-lines . 2)
  (outline-blank-line . t)
  (org-enforce-todo-dependencies . t)
  (org-use-fast-tag-selection . nil)
  (org-tags-column . -80)
  (org-tag-alist . nil))
#+end_src

*** asthetic
:PROPERTIES:
:ID: 52f5560d-6e52-4234-88d8-d326bc97525a
:END:

To be honest, org mode has some pretty ugly syntax. The asterixes at the
beginning of a heading are ugly, org block end and begin lines are ugly,
property drawers are ugly. For a nice-looking, minimal, and non-distracting
appearance all this needs to be improved.

**** visibility
:PROPERTIES:
:ID: 71462363-ddd0-4734-a074-7b00fde06e82
:END:

***** hide lines
:PROPERTIES:
:ID: 533c108a-36d0-4686-9476-2588647402ed
:END:
=hide-lines= is a package which, as its name suggests, hides certain lines.
Specifically, it hides lines that match a regular expression you provide. You
can reveal them with [[helpfn:hide-lines-show-all][hide-lines-show-all]].

****** hide lines
:PROPERTIES:
:ID: a2ea1e7e-5049-4b5e-bb06-4f31cf89ae32
:END:

Particularly in boilerplate heavy languages like Org, hiding certain lines can
make reading documents much easier by reducing visual distraction. This package
though is in need of an update. It didn't work out of the box (see [[id:b358f324-9b64-4e83-8168-231ff1ab115d][hide-lines]] and
[[id:a3e62e0a-452b-429c-9558-139e7b83cf80][hl overlay fix]]).

#+begin_src emacs-lisp
(use-package! hide-lines
  :commands hide-lines hide-lines-matching)
#+end_src

****** =hl= overlay fix
:PROPERTIES:
:ID: a3e62e0a-452b-429c-9558-139e7b83cf80
:END:

The line ~(overlay-put overlay 'invisible 'hl)~ in [[helpfn:][hide-lines-add-overlay]] wouldn't
work with the argument =hl=. It works when you set it to =t= instead. Maybe =hl= is
depreciated.

#+begin_src emacs-lisp
(defadvice! hide:lines-fix-add-overlay-a (start end)
  "Add an overlay from `start' to `end' in the current buffer.
Push the overlay into `hide-lines-invisible-areas'."
  :override hide-lines-add-overlay
  (let ((overlay (make-overlay start end)))
    (setq hide-lines-invisible-areas (cons overlay hide-lines-invisible-areas))
    (overlay-put overlay 'invisible t)))
#+end_src

****** make sure all lines are hidden
:PROPERTIES:
:ID: b358f324-9b64-4e83-8168-231ff1ab115d
:END:

When I tried hiding property drawers [[hfn:hide-lines-matching][hide-lines-matching]] left out the start and end property
lines. Only the property block body was hidden. This advice fixes this.

#+begin_src emacs-lisp
(defadvice! hide:lines-fix-hide-matching-a  (search-text)
  :override hide-lines-matching
  "Hide lines matching the specified regexp."
  (interactive "MHide lines matching regexp: ")
  (set (make-local-variable 'line-move-ignore-invisible) t)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward search-text nil t)
      (hide-lines-add-overlay (match-beginning 0) (match-end 0)))))
#+end_src

***** toggle org properties
:PROPERTIES:
:ID: c2c54bd5-9148-45e9-a675-154bcbf13674
:END:

I want properties to exist--they are useful even if it's just to store an ID.
Yet, like most raw org syntax it looks ugly and takes up a lot of space.
Unless I explicitly ask for properties I don't want to see them.

#+begin_src emacs-lisp
(defun org/hide-property-drawers ()
  "Hide property drawers."
  (interactive)
  (let (selective-display-ellipses org-ellipsis)
    ;; If properties are folded, ellipsis will show.
    (org-show-all '(drawers))
    (hide-lines-matching (concat (s-chop-suffix "$" org-property-re) "\n"))))
#+end_src

***** toggle end source lines
:PROPERTIES:
:ID: 18fdd2a0-df15-486f-97c6-594cba018a3e
:END:

#+begin_src emacs-lisp
(defun org/hide-source-block-delimiters ()
  "Hide property drawers."
  (interactive)
  (let (selective-display-ellipses org-ellipsis)
    ;; If properties are folded, ellipsis will show.
    (org-show-all)
    (hide-lines-matching (rx "#+" (or "begin" "end") "_src" (* nonl) "\n"))))
#+end_src

***** ensure that everything is folded
:PROPERTIES:
:ID: 86437909-e4df-48ae-9e2f-bf364e92cc86
:END:

#+begin_src emacs-lisp
(setq-default org-startup-folded 'fold)

(defadvice! org:set-startup-visibility-h ()
  "Completely hide all text properties."
  :override org-set-startup-visibility
  ;; Hide property drawers on startup.
  (org/hide-property-drawers)
  (org-overview))
#+end_src

***** ensure headings are visible
:PROPERTIES:
:ID: c0395fe0-fa69-49c1-94ed-cdbb94031868
:END:

Sometimes the heading inserted doesn't remain visible.

#+begin_src emacs-lisp
(defhook! ensure-heading-are-visible (org-insert-heading-hook)
  "Ensure that heading remains visible after insertion."
  (-when-let (o (cdr (get-char-property-and-overlay (point) 'invisible)))
    (move-overlay o (overlay-start o) (line-end-position 0))))
#+end_src

***** display children in window
:PROPERTIES:
:ID: f7a9c5e7-fcf8-434a-a9b3-dbe4eadead78
:END:

#+begin_src emacs-lisp
(defun org:display-children-in-window ()
  "Scroll up window to maximize view of unfolded subtree.
If the subtree is unfolded and the end of the current subtree is outside of the
visible window, scroll up until the whole subtree is visible. If the whole
subtree can't fit on the visible window, only scroll up until the top of the
subtree is on the first line of the window (in other words, the beginning of
th subtree should always be visible)."
  (interactive)
  ;; Don't use `window-beg' and `window-end' because their values are
  ;; unreliable.
  (let ((subtree-beg
         (save-excursion (org-back-to-heading)
                         (line-beginning-position)))
        (subtree-end
         (save-excursion (org-end-of-subtree)
                         (line-end-position))))
    (save-excursion
      (while (and (pos-visible-in-window-p subtree-beg)
                  (not (pos-visible-in-window-p subtree-end)))
        (scroll-up 1))
      ;; Sometimes the line at the end is not fully visible. So I try to
      ;; scroll down an extra line.
      (unless (pos-visible-in-window-p subtree-beg)
        (scroll-down 1)))))
#+end_src

***** ensure children are visible
:PROPERTIES:
:ID: 479455ed-a0be-4ecc-af66-559abf53c77c
:END:

If I unfold a subtree and the end of the subtree is outside of the window and
there's space in the window above the subtree, scroll up as much as possible.

Note that I don't use [[helpfn:window-start][window-start]] and [[helpfn:window-end][window-end]] because [[info:elisp#Window Start and End][their values are
unreliable]]. They update when [[helpfn:redisplay][redisplay]] is called; and for efficiency, I don't
want to call this function through every iteration of the loop. Instead I used
[[helpfn:pos-visible-in-window-p][pos-visible-in-window-p]] to tell me if a point is still in the visible window. In
hindsight, using this function is even easier than using ~window-beg~ and
~window-end~ because it doesn't require any math on my part.

#+begin_src emacs-lisp
(defadvice! org:ensure-children-visible-a ()
  "Ensure children are visible after toggling."
  :after outline-toggle-children
  (unless (org:heading-folded-p)
    (org:display-children-in-window)))
#+end_src

**** fancy priorities
:PROPERTIES:
:ID: 306faaf1-fa4d-42bd-8863-ae73ca12cb61
:END:

[[package:org-fancy-priorities][org-fancy-priorities]] is a package that displays org priorities with an icon.

#+begin_src emacs-lisp
(use-package! org-fancy-priorities
  :hook org-mode-hook
  :setq
  (org-fancy-priorities-list . (list (all-the-icons-material "priority_high")
                                     (all-the-icons-octicon "arrow-up")
                                     (all-the-icons-octicon "arrow-down")
                                     (all-the-icons-material "low_priority"))))
#+end_src

**** org superstar
:PROPERTIES:
:ID: c43700f5-ff24-46b2-aed5-a12f8d8bb347
:END:

[[package:org-superstar][org-superstar]] is a an =org-bullets= remake redesigned from the ground up.

#+begin_src emacs-lisp
(use-package! org-superstar
  :hook org-mode-hook
  :pre-setq
  (org-superstar-headline-bullets-list . (list "◉" "○" "▷"))
  :setq
  (org-superstar-special-todo-items . t)
  (org-superstar-leading-bullet . ?\s))
#+end_src

*** links
:PROPERTIES:
:ID: dbc3d205-9831-41f0-95f8-1e8746e0be3a
:END:

To me links are one of the biggest drawing points to org-mode. The ability to
have documentation that can link to websites, files, info docs and even github
commits is too juicy to pass up. Why in the 21st century do we still have to
deal with such weak, plain text code documentation when we could use a more
powerful markup language?

**** ol
:PROPERTIES:
:ID: 21148ef5-0887-4560-9997-6059b3529a2d
:END:

#+begin_src emacs-lisp
(use-feature! ol
  :after org
  :custom
  (org-link-descriptive . t)
  (org-link-use-indirect-buffer-for-internals . t))
#+end_src

**** custom link types
:PROPERTIES:
:ID: 76f86439-8ee3-4688-b117-a51d18d365ce
:END:

***** helpvar
:PROPERTIES:
:ID: 20f9629a-f145-44df-b8b4-69c5394dc773
:END:

=helpvar= I a new link type that when pressed, opens a help buffer from [[https://github.com/Wilfred/helpful][helpful]] if
it's installed, otherwise it defaults to bringing up an regular emacs help buffer.

#+begin_src emacs-lisp
(after! org
  (defun ol:helpvar-face (link)
    (if (boundp (intern link)) 'org-link 'error))

  (defun ol:helpvar-follow (link)
    (let ((var (intern link)))
      (if (require 'helpful nil :noerror)
          (helpful-variable var)
        (describe-variable var))))

  (org-link-set-parameters "helpvar" :face #'ol:helpvar:face :follow #'ol:helpvar:follow))
#+end_src

***** helpfn
:PROPERTIES:
:ID: 449a3953-dce5-41a1-afdf-129fa6fae573
:END:

=helpfn= is the same as helpvar except with functions.

#+begin_src emacs-lisp
(after! org
  (defun ol:helpfn-face (link)
    (let ((fn (intern link)))
      (if (fboundp fn) 'org-link 'error)))

  (defun ol:helpfn-follow (link)
    (let ((fn (intern link)))
      (if (require 'helpful nil :no-error)
          (helpful-callable fn)
        (describe-function fn))))

  (org-link-set-parameters "helpfn" :face #'ol:helpfn-face :follow #'ol:helpfn-follow))
#+end_src

**** toggle link display                                              :disabled:
:PROPERTIES:
:ID: 06d2b812-5d76-4bc4-bdce-3b6fcf5a9070
:END:

#+begin_src emacs-lisp
(general-def
  (:localleader "t")
  (:map org-mode-map)
  ("l" #'org-toggle-link-display)
  ("p" #'org/toggle-property-drawer-display))
#+end_src

*** org capture
:PROPERTIES:
:ID: 81197df0-6744-4a63-a202-f7279d7b7119
:END:

Ever been in the middle of doing something when a thought in your head pops up
about some thing else? You can stop what you're doing but then you lose focus.
You can resolve to make note of it later but then you might forget. Capturing is
designed to confront this problem. While in the middle of a task you can quickly
jump into a small org buffer and write down an idea that you have, then close
it.

**** org capture
:PROPERTIES:
:ID:       8fc5d248-ff21-45e4-a48b-57cecd57b7a3
:END:

#+begin_src emacs-lisp
(use-feature! org-capture
  :after org
  :commands org-capture)
#+end_src

**** completing read for templates
:PROPERTIES:
:ID: 799ac569-85e8-43c0-93ae-a00cf982777f
:END:

The default Org capture templates use this ido-like popup for selecting capture
templates. They shouldn't have made this popup. Org should have just left this
for completing read. Fortunately, there's a package that provides a
completing-read-using replacement for [[helpfn:org-capture][org-capture]] called
[[helpfn:counsel-org-capture-string][counsel-org-capture-string]].

#+begin_src emacs-lisp
(use-package! counsel-org-capture-string
  :after org ivy
  :commands counsel-org-capture-string)
#+end_src

**** remove capture headerline
:PROPERTIES:
:ID: 7b8a8e1d-3c72-492f-9311-56a2428a1f1d
:END:

This was the answer to [[https://emacs.stackexchange.com/questions/53648/eliminate-org-capture-message][my question]]. I need to disable =org-capture's= header-line.

#+begin_src emacs-lisp
(defhook! disable-header-line (org-capture-mode-hook)
  "Turn of the header line message."
  (setq-local header-line-format nil))
#+end_src

**** doct
:PROPERTIES:
:ID: 287fb9c7-110e-4758-aab2-71f74079ade2
:END:

[[https://github.com/progfolio/doct][doct]] is a package designed to ease writing and understanding capture templates
by allowing you to write them in a declarative style (see [[][doct docstring]]).
In org mode, capture templates are [[][represented as plain lists]]. This makes
it easy to forget what a certain element meant or to accidentally omit a capture
template element as you're writing it.

#+begin_src emacs-lisp
(use-package! doct
  :after org-capture
  :require t
  :config
  ;; (require 'doct)
  ;; doct just returns the new template.
  (defadvice! doct:add-to-capture-templates (orig-fn &rest args)
    "Automatically add the template to capture templates."
    :around doct
    (alet (apply orig-fn args)
      (prepend! org-capture-templates it))))
#+end_src

**** capture templates
:PROPERTIES:
:ID: aeb0bc04-84a1-4f85-89f9-c2e04cefce92
:END:

***** emacs
:PROPERTIES:
:ID: e6109a54-37af-44ba-852f-a1c34f910cb9
:END:

#+begin_src emacs-lisp
(after! org-capture
  (doct (list "Emacs"
              :keys "e"
              :file (lambda nil (concat VOID:ORG-DIR "todo.org"))
              :prepend t
              :empty-lines 1
              :ID (lambda () (require 'uuidgen) (uuidgen-4))
              :template '("* %{todo-state} %?"
                          ":PROPERTIES:"
                          ":ID: %{ID}"
                          ":CREATED: %U"
                          ":END:")
              :children
              '(("Todo" :keys "1" :todo-state "TODO")
                ("Bug" :keys "2" :todo-state "BUG")))))
#+end_src

***** notes
:PROPERTIES:
:ID: b5af648e-d9fa-4d48-b68b-419c53dcd144
:END:

Sometimes there are things I want to capture that's not a =TODO=, but more like
information I don't want to forget or that I feel like I might need to reference
in the future. I use this template for this.

#+begin_src emacs-lisp
(after! org-capture
  (doct (list "Notes"
              :keys "n"
              :file (lambda nil (concat VOID:ORG-DIR "notes.org"))
              :prepend t
              :empty-lines 1
              :ID (lambda () (require 'uuidgen) (uuidgen-4))
              :template '("* %?"
                          ":PROPERTIES:"
                          ":ID: %{ID}"
                          ":CREATED: %U"
                          ":END:"))))
#+end_src

*** org agenda
:PROPERTIES:
:ID: 65b2885d-aca6-42b8-a8ad-e3ae077b9aae
:END:

[[helpfn:org-agenda-list][org-agenda-list]] is the function that actually takes you to the agenda for the current week.

#+begin_src emacs-lisp
(use-feature! org-agenda
  :after org
  :commands (org-agenda org-agenda-list)
  :setq
  (org-agenda-files . (mapcar (lambda (it) (concat org-directory it))
                               '("todo.org")))
  (org-agenda-start-on-weekday . 0)
  (org-agenda-timegrid-use-ampm . nil)
  (org-agenda-skip-unavailable-files . nil)
  (org-agenda-time-leading-zero . t)
  (org-agenda-text-search-extra-files . '(agenda-archives))
  (org-agenda-dim-blocked-tasks . nil)
  (org-agenda-inhibit-startup . t))
#+end_src

*** org refile
:PROPERTIES:
:ID: 0174a708-8043-403e-b024-8ae29868564d
:END:

#+begin_src emacs-lisp
(use-feature! org-refile
  :after org
  :setq
  (org-refile-targets . `((,VOID:README-FILE . (:maxlevel . 10))
                          (,VOID:TODO-FILE . (:maxlevel . 1))))
  (org-refile-use-outline-path . 'file)
  (org-refile-allow-creating-parent-nodes . t)
  (org-reverse-note-order . t)
  (org-outline-path-complete-in-steps . nil))
#+end_src

*** org id
:PROPERTIES:
:ID: e7ecff83-7ba6-4620-ac05-ebac2f250b7a
:END:

=org-id= is a built-in package that creates that provides tools for creating and
storing universally unique IDs. This is primarily used to disguish and
referenance org headlines.

#+begin_src emacs-lisp
(use-feature! org-id
  :commands org-id-get-create
  :setq
  (org-id-locations-file . (concat VOID:DATA-DIR "org-id-locations"))
  ;; Global ID state means we can have ID links anywhere. This is required for
  ;; `org-brain', however.
  (org-id-locations-file-relative . t)
  :hook (org-insert-heading-hook . org-id-get-create))
#+end_src

*** org clock
:PROPERTIES:
:ID:       d378471c-89df-48c9-a755-b79880f27308
:END:

=org-clock= is a built-in package that provides time logging functions for
tracking the time you spend on a particular task.

#+begin_src emacs-lisp
(use-feature! org-clock
  :commands org-clock-in
  ;; :before-call ((org-clock-in org-clock-out org-clock-in-last org-clock-goto org-clock-cancel) . (org-clock-load))
  :hook (kill-emacs-hook . org-clock-save)
  :setq
  ;; org-clock-sound
  ;; org-show-notification-handler
  (org-clock-persist . 'history)
  (org-clock-persist-file . (concat VOID:DATA-DIR "org-clock-save.el"))
  ;; Resume when clocking into task with open clock
  (org-clock-in-resume . t)
  :config
  ;; set up hooks for persistence.
  (org-clock-persistence-insinuate))
#+end_src

*** org crypt
:PROPERTIES:
:ID:       f5278890-8b84-43df-b5dc-0ef8074bfba9
:END:

#+begin_src emacs-lisp
(use-feature! org-crypt
  :commands org-encrypt-entries org-encrypt-entry org-decrypt-entries org-decrypt-entry
  :hook (org-reveal-start . org-decrypt-entry)
  ;; :preface
  ;; ;; org-crypt falls back to CRYPTKEY property then `epa-file-encrypt-to', which
  ;; ;; is a better default than the empty string `org-crypt-key' defaults to.
  ;; (defvar org-crypt-key nil)
  ;; (after! org
  ;;   (add-to-list 'org-tags-exclude-from-inheritance "crypt")
  ;;   (add-hook! 'org-mode-hook
  ;;              (add-hook 'before-save-hook 'org-encrypt-entries nil t)))
  )
#+end_src

*** org-journal
:PROPERTIES:
:ID:       c3056303-5fa1-49f9-ae2d-294942e25f54
:END:

=org-journal= is a package that provides functions to maintain a simple
diary/journal using =org-mode=.

#+begin_src emacs-lisp
(use-package! org-journal
  :commands org-journal-new-entry
  :setq
  (org-journal-file-type . 'yearly)
  (org-journal-dir . (concat VOID:ORG-DIR "journal/"))
  (org-journal-find-file . 'find-file))
#+end_src

*** keybindings
:PROPERTIES:
:ID: ee444a86-1266-42dd-9fe8-40192db1fdde
:END:

**** narrowing and widening                                           :disabled:
:PROPERTIES:
:ID: 72bd1c81-bd60-472f-8166-20bb2a16093d
:END:

#+begin_src emacs-lisp
(general-def
  (:localleader "n")
  (:map org-mode-map)
  (:wk "Narrow" "" nil)
  (:wk "To Element" :n "e" #'org-narrow-to-element)
  (:wk "To Block"   :n "b" #'org-narrow-to-block)
  (:wk "To Subtree" :n "s" #'org-narrow-to-subtree)
  (:wk "Widen"      :n "w" #'widen))
#+end_src

**** replace evil folding commands to outline folding
:PROPERTIES:
:ID: b3a4908d-538e-4d4c-acc9-fbd822220f03
:END:

By default evil binds =za= to [[helpfn:evil-open-folds][evil-open-folds]] and =zb= to [[helpfn:evil-close-folds][evil-close-folds]]. They do
work in =org-mode= but I'd rather use the folding commands provided by =outline.el.=
The outline api actually seems pretty solid; better coded and simpler than the org api it seems.

#+begin_src emacs-lisp
;; (general-def
;;   (:leader "z")
;;   (:n "a" #'outline-show-all)
;;   (:n "m" #'outline:hide-all-sublevels))

(general-def 'normal org-mode-map
  [tab] #'outline-toggle-children
  "TAB" #'outline-toggle-children)

(defun outline:hide-all-sublevels ()
  (interactive)
  (outline-hide-sublevels 1))

(general-def 'normal org-mode-map
  "j" #'org/dwim-next-line
  "k" #'org/dwim-previous-line
  "b" #'org/dwim-insert-elisp-block
  "o" #'org/insert-heading-below
  "O" #'org/insert-heading-above
  "l" #'org-do-demote
  "h" #'org-promote-subtree
  "L" #'org-demote-subtree
  "t" #'org-set-tags-command
  "r" #'org-capture
  "s" #'org-schedule
  "S" #'org-deadline
  "R" #'org-refile
  "T" #'org-todo
  "D" #'org-cut-subtree
  "Y" #'org-copy-subtree
  "K" #'org-metaup
  "J" #'org-metadown)
#+end_src

** lua
:PROPERTIES:
:ID: 9f458b76-489f-45e0-b99a-ad6a9a2ae182
:END:

#+begin_src emacs-lisp
(use-package! lua-mode :mode "\\.lua\\'")
#+end_src

** cpp
:PROPERTIES:
:ID:       2fecdcf5-f482-4672-8bc8-9e9e1e0e110b
:END:

*** modern font lock
:PROPERTIES:
:ID:       2778d03a-4ee0-4175-90e5-331140ca7faf
:END:

#+begin_src emacs-lisp
(use-package! modern-cpp-font-lock
  :hook (c++-mode-hook . modern-c++-font-lock-mode))
#+end_src

*** demangle
:PROPERTIES:
:ID:       2cda9af3-c7e3-48b5-8b49-ec4c63d4f501
:END:

#+begin_src emacs-lisp
(use-package! demangle-mode
  :hook llvm-mode-hook)
#+end_src

** TODO latex
:PROPERTIES:
:ID:       03b47c17-e217-4dd5-b48d-36ae54a8349e
:END:

*** tex
:PROPERTIES:
:ID:       da68dfd0-62c5-4101-a7f3-7b13df760670
:END:

#+begin_src emacs-lisp
(use-feature! tex
  :mode ("\\.tex\\'" . LaTeX-mode)
  :hook (LaTex-mode-hook . visual-line-mode)
  :setq
  (TeX-parse-self . t)
  (TeX-auto-save . t)
  ;; use hidden dirs for auctex files
  (TeX-auto-local . ".auctex-auto")
  (TeX-style-local . ".auctex-style")
  (TeX-source-correlate-mode . t)
  (TeX-source-correlate-method . 'synctex)
  ;; don't start the emacs server when correlating sources
  (TeX-source-correlate-start-server . nil)
  ;; automatically insert braces after sub/superscript in math mode
  (TeX-electric-sub-and-superscript . t))
#+end_src

*** auctex
:PROPERTIES:
:ID:       5d5d2e8f-3b95-4d1a-bcc0-1c4ec8f51202
:END:

#+begin_src emacs-lisp
(use-package! auctex)
#+end_src

*** adaptive wrap
:PROPERTIES:
:ID:       80c837fc-a8de-4c11-9c76-b54f58c9a157
:END:

#+begin_src emacs-lisp
(use-package! adaptive-wrap
  :hook (LaTeX-mode . adaptive-wrap-prefix-mode)
  :setq-default (adaptive-wrap-extra-indent . 0))
#+end_src

*** preview pane
:PROPERTIES:
:ID:       a1c99afc-ee73-42fd-b33d-7c61ad607e90
:END:

#+begin_src emacs-lisp
(use-package! latex-preview-pane)
#+end_src

* User Interface
:PROPERTIES:
:ID: ee57f711-9a4f-421f-b831-ab4907402e52
:END:

** TODO hydra                                                         :disabled:
:PROPERTIES:
:ID:       503d301c-8452-4a85-be41-aa6e5ed701dd
:END:

Using emacs you'll enavitably encounter many keybindings. Muscle memory is good
but often it can be useful to able to also see the keybindings.

*** pretty hydra
:PROPERTIES:
:ID:       236961bf-5600-46d0-8468-51d6cb6e15d8
:END:

#+begin_src emacs-lisp
(use-package! pretty-hydra)
#+end_src

*** pretty hydra title
:PROPERTIES:
:ID:       68af369e-fc84-41dc-8804-5a4ba785fb51
:END:

I got this from [[https://github.com/seagle0128/.emacs.d/blob/master/lisp/init-hydra.el][centaur emacs]].

#+begin_src emacs-lisp
(cl-defun pretty-hydra-title (title &optional icon-type icon-name
                                    &key face height v-adjust)
  "Add an icon in the hydra title."
  (let ((face (or face `(:foreground ,(face-background 'highlight))))
        (height (or height 1.0))
        (v-adjust (or v-adjust 0.0)))
    (concat
     (when (and (icons-displayable-p) icon-type icon-name)
       (let ((f (intern (format "all-the-icons-%s" icon-type))))
         (when (fboundp f)
           (concat
            (apply f (list icon-name :face face :height height :v-adjust v-adjust))
            " "))))
     (propertize title 'face face))))
#+end_src

*** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:toggle (:title (pretty-hydra-title "Toggles" 'faicon "toggle-on")
                                   :color amaranth :quit-key "q")
  ("No Title"
   (("l" display-line-numbers "line-numbers")
    ("c" caps-lock "caps-lock")
    ("d" debug-on-error "debug"))
   "Other"
   (("f" void/set-font "font face")
    ("L" org-toggle-link-display "link display")
    ("s" void/set-font-size "font size"))))
#+end_src

*** theme
:PROPERTIES:
:ID:       e3525bb4-8b8c-4a87-ac23-f9627c6e55bb
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:theme (:title (pretty-hydra-title "Themes" 'faicon "paint-brush")
                                  :color amaranth :quit-key "q")
  ("Traverse"
   (("j" theme-looper-enable-next-theme "next")
    ("k" theme-looper-enable-previous-theme "previous"))
   "Favorites"
   (("f" theme-looper/add-current-theme-to-favorites "favorites")
    ("f" theme-looper/add-current-theme-to-ignored "ignore"))
   "Random"
   (;; ("d" theme-looper/enable-random-dark-theme "dark")
    ;; ("l" theme-looper/enable-random-light-theme "light")
    ("r" theme-looper-enable-random-theme "random")
    ("I" theme-looper/enable-random-ignored-theme "ignored")
    ("F" theme-looper/enable-random-favorite-theme "favorite"))
   "circadian"
   (("t" circadian/set-current-theme-for-time "display at particular time"))))
#+end_src

*** window
:PROPERTIES:
:ID:       71951e0f-fbb9-4458-be9f-ce439e1eedcd
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:window (:title (pretty-hydra-title "Windows" 'faicon "windows")
                                   :color amaranth
                                   :quit-key "q")
  ("Traverse"
   (("h" windmove-left "move left")
    ("j" windmove-down "move down")
    ("k" windmove-up "move up")
    ("l" windmove-right "move right"))
   "Resize"
   (("M" maximize-window "maximize")
    ("m" minimize-window "minimize")
    ("b" balance-windows "balance"))
   "Split"
   (("s" split-window-horizontally "horizontally")
    ("v" split-window-vertically "vertically"))
   "Transpose"
   (("t" transpose-frame "vertically")
    ("v" transpose- "horizontally"))
   "Actions"
   (("a" ace-select-window "select")
    ("w" ace-swap-window "swap")
    ("d" delete-window "delete")
    ("D" delete-other-windows "delete others"))
   "Zoom"
   (("z" zoom-in "zoom-in")
    ("Z" zoom-out "zoom-out"))))
#+end_src

*** help
:PROPERTIES:
:ID:       0f7f0487-d554-4957-a834-6aef6ea89028
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:help (:title (pretty-hydra-title "Help" 'material "help")
                                 :color amaranth :quit-key "q")
  ("Describe"
   (("v" describe-variable "variable")
    ("f" describe-function "function")
    ("k" describe-key "key"))
   "Apropos"
   (("a" apropos "apropos")
    ("V" apropos-variable "variable"))))
#+end_src

*** packages
:PROPERTIES:
:ID:       4187c7f4-8b54-4ac3-bcec-cb84a63466e0
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:packages (:title (pretty-hydra-title "Packages" 'octicon "package")
                                     :color pink :quit-key "q")
  ("Installation"
   (("i" package-install "install")
    ("c" remove "remove")
    ("l" paradox "debug"))
   ""
   (("f" #'paradox-list-packages "font face")
    ("L" org-toggle-link-display "link display")
    ("s" void/set-font-size "font size"))))
#+end_src

*** quit
:PROPERTIES:
:ID:       08725792-4030-4224-a678-e70f84495d51
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:quit (:title (pretty-hydra-title "quit" 'faicon "power-off")
                                 :color amaranth :quit-key "q")
  ("Emacs"
   (("q" evil-quit-all "next")
    ("s" void/quit-emacs-no-prompt "with no prompt")
    ("Q" evil-save-and-quit "and save")
    ("D" void/kill-emacs-no-hook "with no hook")
    ("Q" void/kill-emacs-brutally "brutally"))
   "Restart"
   (("r" restart-emacs "and restart"))
   "Processes"
   (("p" void/kill-emacs-processes "favorites"))))
#+end_src

*** app
:PROPERTIES:
:ID:       ae7ffbcd-07f5-4b23-a134-262e51485be0
:END:

#+begin_src emacs-lisp
(pretty-hydra-define hydra:app (:title (pretty-hydra-title "Apps" 'faicon "")
                                :color amaranth :quit-key "q")
  ("Browsers"
   (("f" firefox "next")
    ("q" qutebrowser "with no hook")
    ("n" next "random"))
   "Processes"
   (("p" void/kill-emacs-processes "favorites"))))
#+end_src

** help and documentation
:PROPERTIES:
:ID:       3c01c053-fe6f-4a7a-92a5-6d4de7caac0a
:END:

*** helpful
:PROPERTIES:
:ID: 25270809-b64e-4b9a-b0c2-95ffd047280c
:END:

[[github:wilfred/helpful][helpful]] provides a complete replacement for the built-in
Emacs help facility which provides much more contextual information
in a better format.

#+begin_src emacs-lisp
(use-package! helpful
  :ignore-buffers ("\\*Help.*")
  :popup
  ("\\*Help.*"
   (display-buffer-at-bottom)
   (window-width . 0.50)
   (side . bottom)
   (slot . 4))
  :bind
  ([remap describe-function] . helpful-callable)
  ([remap describe-command]  . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key]      . helpful-key))
#+end_src

*** elisp demos
:PROPERTIES:
:ID: d1164fd9-bfc6-4436-a249-136a63c76e40
:END:

This package improves help further by allowing you to add examples on how to use
a function or macro. It seems simple but having examples can really ease the
understanding of a verbally terse and dry command description.

#+begin_src emacs-lisp
(use-package! elisp-demos
  ;; :functions elisp-demos-advice-helpful-update
  :advice (:after helpful-update elisp-demos-advice-helpful-update)
  :commands elisp-demos-add-demo)
#+end_src

* Asthetic
:PROPERTIES:
:ID: bd21a69a-794c-4ff1-97d0-9e5911a26ad7
:END:

It's easy to underestimate how much of a difference having an asthetically
pleasing Emacs configuration can have. Ugliness really can take its toll.

** which-key
:PROPERTIES:
:ID: 79d530ab-ab32-459e-853c-b1ec9eee37ef
:END:

Emacs is full of so many keybindings, that it can be difficult to keep track of
them. Especially when you're starting out, but even when you're an Emacs-pro,
it's easy to forget what a particular functionality is bound to. Typically,
you'll remember the first few key strokes but struggle with the rest. To address
this [[github:][which-key]] displays key binding sequences in the minibuffer as your typing
them ([[][]] and [[][]] are screenshots of this in action). By doing this
you can "discover" the commands as you go along.

#+begin_src emacs-lisp
(use-package! which-key
  :hook emacs-startup-hook
  :setq
  (which-key-sort-uppercase-first . nil)
  (which-key-max-display-columns . nil)
  (which-key-add-column-padding . 1)
  (which-key-min-display-lines . 6)
  (which-key-side-window-slot . -10)
  (which-key-sort-order . #'which-key-prefix-then-key-order)
  (which-key-popup-type . 'minibuffer)
  :config
  (which-key-mode)
  (defhook! set-line-spacing (which-key-init-buffer-hook)
    (setq line-spacing 3))
  (which-key-add-key-based-replacements void:leader-key "<leader>")
  (which-key-add-key-based-replacements void:localleader-key "<localleader>"))
#+end_src

** dashboard
:PROPERTIES:
:ID: 20926522-b78b-4bca-b70e-9ef4213c4344
:END:

[[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] is an extensible emacs startup screen. I love the idea of =dashboard=:
having an extensible, fast, nice-looking dashboard when starting emacs is
nice. It's not only nice asthetically, it's also strategic too. First, you can
use it as a launching point to get to your tasks quicker. And second, it doesn't
require any expensive modes. I've often been starting out with the scratch
buffer and I've wanted to have the scratch buffer start off with
=emacs-lisp-mode=, but I don't want it to trigger =company=, =yasnippet=, etc. on
startup. If I start my emacs with =dashboard= I can avoid this.

*** dashboard
:PROPERTIES:
:ID: 9de45782-1683-40ef-aff2-95c0dbaa4ba7
:END:

#+begin_src emacs-lisp
(use-package! dashboard
  :require t
  :hook (window-setup-hook . dashboard-insert-startupify-lists)
  :setq
  (dashboard-items . nil)
  (dashboard-startup-banner . 2)
  (dashboard-center-content . t)
  (initial-buffer-choice . (lambda () (get-buffer-create dashboard-buffer-name))))
#+end_src

*** dashboard-init-info
:PROPERTIES:
:ID: 92c199ad-5862-4fe3-be04-44c94d4286b6
:END:

[[helpvar:void-init-time][void:init-time]] is more accurate than dashboard's init time measure. So I use it instead.

#+begin_src emacs-lisp
(defadvice! dashboard:set-init-info-a (&rest _)
  :before dashboard-insert-startupify-lists
  (setq dashboard-init-info
        (format "%d packages loaded in %.2f seconds"
                (cond ((featurep 'straight)
                       (hash-table-size straight--profile-cache))
                      ((featurep 'package) (length package-activated-list))
                      (t 0))
                (string-to-number (emacs-init-time)))))
#+end_src

*** banner path
:PROPERTIES:
:ID: 597af7c3-f5d2-4cf5-a93e-3dd3564fb34a
:END:

#+begin_src emacs-lisp
(defadvice! dashboard:custom-banner-path-a (&rest _)
  "Use the Void text banner."
  :override dashboard-get-banner-path
  (concat VOID:LOCAL-DIR "void-banner.txt"))
#+end_src

*** navigator buttons                                                 :disabled:
:PROPERTIES:
:ID:       a4a9e0ae-ee44-4434-bcf6-b415ef348e45
:END:

**** navigator button
:PROPERTIES:
:ID:       63829df6-5ba9-477e-99e9-86aabf7f5862
:END:

This is a convenience macro that allows navigation buttons to be defined
declaratively and with a "defun-like" syntax.

#+begin_src emacs-lisp
(defmacro dashboard:define-naviator-button! (name args description &rest body)
  "Define a dashboard navigator button."
  (declare (indent defun))
  (let ((dashboard-fn dashboard:name-button)
        ((&plist ))
        ((&plist ) icon))
    `(alet (list ()
                 ,name
                 ,description
                 #',dashboard-fn)
       (push it dashboard-navigator-buttons))))
#+end_src

**** github link
:PROPERTIES:
:ID:       a3c05c71-bd42-4508-8738-5c75f95b29d6
:END:

#+begin_src emacs-lisp
(dashboard:define-naviator-button! Homepage ()
  "Browse Homepage."
  :icon "mark-github"
  (browse-url "https://github.com/Luis-Henriquez-Perez/dotfiles"))
#+end_src

**** go to readme
:PROPERTIES:
:ID:       1a666fec-9f7c-4153-9e9a-f0f4a74e4d31
:END:

#+begin_src emacs-lisp
(dashboard:define-naviator-button! README ()
  "Go to README."
  :icon "eye"
  :type faicon
  (browse-url "https://github.com/Luis-Henriquez-Perez/dotfiles"))
#+end_src

** hide-mode-line
:PROPERTIES:
:ID: 043e3474-7b66-4e73-9e0b-3347897dbdcc
:END:

[[https://github.com/hlissner/emacs-hide-mode-line][hide-mode-line]] is another package that does exactly what it's name says: hide
the mode line.

#+begin_src emacs-lisp
(use-package! hide-mode-line
  :hook Man-mode completion-list-mode)
#+end_src

** all-the-icons
:PROPERTIES:
:ID: 6a7c7438-42c0-4833-9398-fa9fd58515d1
:END:

A little bit of decoration and spice can go a long way. As its name suggests,
[[all-the-icons][all-the-icons]] is a package that contains a lot of icons ([[][here]] you can see
a few). In practice I use these icons to (1) make things look nicer and more
colorful and (2) enhance readability of plain text.

*** install all the icons if not installed                            :disabled:
:PROPERTIES:
:ID: 1cda0692-8f42-4bb3-b11d-da52e2004a55
:END:

This will install the icons if they're not already installed. Unless somehow the
fonts are deleted, this code should only take effect the first time installing
void. This helps achieve the goal to automate as much as possible on a fresh
VOID install. For writing this code I referenced the body of
[[helpfn:all-the-icons-install-fonts][all-the-icons-install-fonts]].

#+begin_src emacs-lisp
(let ((font-dir
       (cl-case window-system
         (x (concat (or (getenv "XDG_DATA_HOME")
                        (concat (getenv "HOME") "/.local/share"))
                    "/fonts/"))
         (mac (concat (getenv "HOME") "/Library/Fonts/" ))
         (ns (concat (getenv "HOME") "/Library/Fonts/" )))))
  (unless (--all-p (file-exists-p (concat font-dir it))
                   '("all-the-icons.ttf"
                     "file-icons.ttf"
                     "fontawesome.ttf"
                     "material-design-icons.ttf"
                     "octicons.ttf"
                     "weathericons.ttf"))
    (void:log "No icons installed. Installing...")
    (all-the-icons-install-fonts :ignore-prompt)))
#+end_src

*** boostrap
:PROPERTIES:
:ID: a13cf0ec-14e2-4d4b-b313-65fe68f0655b
:END:

#+begin_src emacs-lisp
(use-package! all-the-icons
  :commands (all-the-icons-octicon
             all-the-icons-faicon
             all-the-icons-fileicon
             all-the-icons-wicon
             all-the-icons-material
             all-the-icons-alltheicon))
#+end_src

*** disable in tty
:PROPERTIES:
:ID: fce313d3-aa5a-4ea8-b994-1f9a8e33ab9d
:END:

In terminals these icons will not display correctly. I usually use emacs as a
graphical interface but.

#+begin_src emacs-lisp
(defadvice! void:disable-all-the-icons-in-tty-a (orig-fn &rest args)
  "Disable icons in tty."
  :around (all-the-icons-octicon
           all-the-icons-material
           all-the-icons-faicon
           all-the-icons-fileicon
           all-the-icons-wicon
           all-the-icons-alltheicon)
  (if (display-graphic-p) (apply orig-fn args) ""))
#+end_src

** themes
:PROPERTIES:
:ID:       d21b01bd-b5fe-461e-bd3e-54bcde7a8244
:END:

*** themes
:PROPERTIES:
:ID: fb192344-8aef-4ab1-800d-6b5cd8c900b9
:END:

#+begin_src emacs-lisp
(use-package! humanoid-themes
  :pre-setq (humanoid-org-bold . nil))

(use-package! spacemacs-theme
  :pre-setq
  (spacemacs-theme-org-bold . nil)
  (spacemacs-theme-comment-italic . t)
  (spacemacs-theme-org-bold . nil)
  (spacemacs-theme-org-height . nil))

(use-package! tao-theme)

(use-package! one-themes
  :pre-setq
  (emacs-one-scale-org-headlines . nil)
  (emacs-one-use-variable-pitch . nil))

(use-package! avk-emacs-themes)

(use-package! hemera-theme)
#+end_src

*** circadian                                                         :disabled:
:PROPERTIES:
:ID:       1f8dfb73-9709-4b3b-b02f-0c81b04665f3
:END:

[[https://github.com/GuidoSchmidt/circadian.el][circadian]] manages the loading of themes at certain time.

#+begin_src emacs-lisp
(use-package! circadian)

#+end_src

* Keybindings
:PROPERTIES:
:ID: 226e2c5b-2b81-483a-9942-d0ca0fc80f1f
:END:

** general
:PROPERTIES:
:ID: 3260f794-2d7f-4a68-a36a-78af01e4a4a9
:END:

This heading is dedicated to general keybinding decisions I make.

*** execute extended command
:PROPERTIES:
:ID: d8071a32-e58c-41ab-8fd7-7d7732708ee8
:END:

One of the most common--if not the most common--command you use in Emacs is
[[helpfn:execute-extended-command][execute-extended-command]]. This command let's you search any other command and
upon pressing enter, then you execute the command. The fact that this command is
invoked so frequently demands it have one of the shortest, easiest to press
bindings. I chose to give it =SPC SPC= and =;=. =SPC SPC= is short and quick to
type as well as consistent with other =SPC= bindings. While =;= is super fast to
press as well and even faster than =SPC SPC=.

#+begin_src emacs-lisp
(define-leader-key! "SPC" (list :def #'execute-extended-command :wk "M-x"))

(general-def
  "A-x" #'execute-extended-command
  "M-x" #'execute-extended-command)

(general-def 'normal ";" #'execute-extended-command
  "q" #'delete-window)
#+end_src

*** scrolling pages
:PROPERTIES:
:ID: 4861fa41-7185-471f-bfad-bba1283414ce
:END:

I scroll pages all the time. The default binding for scrolling pages in evil are
=C-j= to scroll down and =C-k= to scroll up. These chords are too much for such
common commands however, so I bound them to =J= and =K= respectively.

#+begin_src emacs-lisp
(general-def 'normal
  "K" #'evil-scroll-page-up
  "J" #'evil-scroll-page-down)
#+end_src

*** increasing text scale
:PROPERTIES:
:ID: 927dedb6-eee9-47ff-9298-c2e21bbce524
:END:

As someone who spends much of his day on the computer.

#+begin_src emacs-lisp
(general-def '(emacs normal)
  "M--" #'text-scale-decrease
  "M-=" #'text-scale-increase)
#+end_src

** windows
:PROPERTIES:
:ID: 784956e2-3696-4f92-80ca-41b7e30e5b2b
:END:

Efficient window management in Emacs crucial for success. These keys all pertain
to window/workspace actions.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "w"
  ""  (list :ignore nil                              :wk "window")
  "w" (list :def #'display-buffer :wk "display buffer")
  "o" (list :def #'other-window                      :wk "other window")
  "S" (list :def #'void/window-split-below-and-focus :wk "split below and focus")
  "V" (list :def #'void/window-split-right-and-focus :wk "split right and focus")
  "s" (list :def #'split-window-below                :wk "split below")
  "v" (list :def #'split-window-right                :wk "split right")
  "M" (list :def #'maximize-window                   :wk "maximize")
  "m" (list :def #'minimize-window                   :wk "minimize")
  "b" (list :def #'balance-windows                   :wk "move left")
  "d" (list :def #'delete-window                     :wk "delete current")
  "D" (list :def #'delete-other-windows              :wk "delete others")
  "h" (list :def #'windmove-left                     :wk "move left")
  "j" (list :def #'windmove-down                     :wk "move down")
  "k" (list :def #'windmove-up                       :wk "move up")
  "l" (list :def #'windmove-right                    :wk "move right")
  "x" (list :def #'ace-swap-window                   :wk "swap windows")
  "t" (list :def #'transpose-frame                   :wk "transpose")
  "n" (list :def #'eyebrowse-create-window-config    :wk "save window config")
  "J" (list :def #'eyebrowse-next-window-config      :wk "next window config")
  "K" (list :def #'eyebrowse-prev-window-config      :wk "prev window config"))
#+end_src

** buffer
:PROPERTIES:
:ID: e3eec4f8-88d8-4010-adb5-2f8e05f14677
:END:

In emacs, we change the buffer a window's displaying pretty often. That's why
efficient buffer navigation is a must. There are particular buffers which I
visit so often that it's worth having keybindings just for them.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "b"
  ""  (list :def nil                            :wk "buffer")
  "e" (list :def #'buffer-expose                :wk "expose")
  "p" (list :def #'previous-buffer              :wk "previous")
  "n" (list :def #'next-buffer                  :wk "next")
  "s" (list :def #'switch-to-buffer             :wk "switch")
  "b" (list :def #'switch-to-buffer             :wk "display")
  "d" (list :def #'display-buffer               :wk "display")
  "t" (list :def #'void/switch-to-todo-file     :wk "Void TODO")
  "S" (list :def #'void/open-scratch            :wk "*scratch*")
  "i" (list :def #'void/switch-to-init-org-file :wk "fallback")
  "I" (list :def #'void/switch-to-main-elisp    :wk "main.el")
  "m" (list :def #'void/switch-to-main-org-file :wk "Void README")
  "M" (list :def #'void/switch-to-messages      :wk "*messages*"))

(define-leader-key!
  :infix "b k"
  ""  (list :ignore t             :wk "kill")
  "c" (list #'kill-current-buffer :wk "current"))
#+end_src

** app
:PROPERTIES:
:ID: 3f09a41a-03b8-4d5c-85c5-d7adeb7dd328
:END:

These keybindings are for opening particular apps. When I'm testing Void I like
to open another emacs instance.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "a"
  ""  (list :ignore t                       :wk "app")
  "a" (list :def #'counsel-linux-app :wk "open app")
  "E" (list :def #'elfeed                   :wk "elfeed")
  "d" (list :def #'deer                     :wk "deer")
  "r" (list :def #'ranger                   :wk "ranger")
  "e" (list :def #'void/open-emacs-instance :wk "emacs")
  "q" (list :def #'void/open-qutebrowser    :wk "qutebrowser")
  "q" (list :def #'void/open-next           :wk "next")
  "w" (list :def #'w3m                      :wk "w3m")
  "c" (list :def #'org-capture              :wk "capture"))
#+end_src

** file
:PROPERTIES:
:ID: 2231147b-88c9-4c63-9c75-488cd1465807
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "f"
  ""  (list :ignore t          :wk "file")
  "S" (list :def #'sudo-edit   :wk "sudo")
  "s" (list :def #'save-buffer :wk "save buffer")
  "f" (list :def #'find-file   :wk "find file")
  "r" (list :def #'ranger      :wk "ranger")
  "d" (list :def #'deer        :wk "deer"))
#+end_src

** eval
:PROPERTIES:
:ID: afa6be08-a38c-45f1-867a-5620fc290aac
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "e"
  ""  (list :ignore t                   :wk "eval")
  "r" (list :def #'eval-region          :wk "region")
  "d" (list :def #'eval-defun           :wk "defun")
  "l" (list :def #'eval-print-last-sexp :wk "sexp")
  "b" (list :def #'eval-buffer          :wk "buffer"))
#+end_src

** code
:PROPERTIES:
:ID: 661f77fb-3435-4e4f-8adb-c4d6390ea6b8
:END:

These bindings are for generally working with code.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "c"
  ""  (list :ignore t                                   :wk "code")
  "a" (list :def #'ialign                               :wk "align")
  "l" (list :def #'lispyville-comment-or-uncomment-line :wk "toggle comment")
  "y" (list :def #'lispyvile-comment-and-cone-dwim      :wk "copy comment"))
#+end_src

** toggle
:PROPERTIES:
:ID: 10d6851b-6af6-4185-8976-0ad65b3d1d28
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "t"
  ""  (list :ignore t                    :wk "toggle/set")
  "r" (list :def #'read-only-mode        :wk "read-only")
  "t" (list :def #'load-theme            :wk "load theme")
  "c" (list :def #'caps-lock-mode        :wk "caps lock")
  "d" (list :def #'toggle-debug-on-error :wk "debug")
  "F" (list :def #'void/set-font         :wk "set font")
  "f" (list :def #'void/set-font-size    :wk "font size"))

(define-leader-key!
  :infix "t"
  :keymaps 'org-mode-map
  "l" (list :def #'org-toggle-link-display :wk "link display"))
#+end_src

** help
:PROPERTIES:
:ID: c7f3b699-7cf9-480b-a88c-10bdae4c165e
:END:

There's a lot of documentation finding and information searching involved in
Emacs and for that we need all the help we can get.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "h"
  ""  (list :ignore t                      :wk "help")
  "h" (list :def #'describe-function       :wk "function")
  "v" (list :def #'describe-variable       :wk "variable")
  "c" (list :def #'describe-char           :wk "char")
  "k" (list :def #'describe-key            :wk "key")
  "f" (list :def #'describe-function       :wk "function")
  "l" (list :def #'global-command-log-mode :wk "command log")
  "a" (list :def #'apropos                 :wk "apropos"))
#+end_src

** quit
:PROPERTIES:
:ID: d4828ea9-5ee1-4424-8ff0-f700876d34fd
:END:

There's many ways to quit Emacs. Sometimes I'd like to save all the buffers I
had been working on. Sometimes, when I'm testing something and I mess up
[[helpvar:kill-emacs-hook][kill-emacs-hook]] I want Emacs to just quit even if it means ignoring that hook.
Most of the time, I know what I'm doing when I quit Emacs, so I don't want a
prompt asking me if I'm sure.

#+begin_src emacs-lisp
(define-leader-key!
  :infix "q"
  ""  (list :ignore t                        :wk "quit")
  "q" (list :def #'evil-quit-all             :wk "normally")
  "s" (list :def #'void/quit-emacs-no-prompt :wk "with no prompt")
  "Q" (list :def #'evil-save-and-quit        :wk "and save")
  "x" (list :def #'void/kill-emacs-no-hook   :wk "with no hook")
  "e" (list :def #'void/kill-emacs-processes :wk "emacs processes")
  "b" (list :def #'void/kill-emacs-brutally  :wk "brutally")
  "r" (list :def #'restart-emacs             :wk "and restart"))
#+end_src

** packages
:PROPERTIES:
:ID: d3286920-ead4-4f7c-bf9d-8a6ed3d7ba46
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "p"
  ""  (list :ignore t                       :wk "package")
  "i" (list :def #'straight-use-package     :wk "install")
  "r" (list :def #'straight-rebuild-package :wk "rebuild")
  "p" (list :def #'straight-pull-package    :wk "pull")
  "s" (list :def #'straight/search-package  :wk "search"))
#+end_src

** search
:PROPERTIES:
:ID: b50ed0da-652d-4d20-8a4e-e0cf053548a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "s"
  ""  (list :ignore t :wk "search")
  "s" (list :def #'selectrum/swiper :wk "swiper"))

(define-leader-key!
  :infix "s"
  :keymaps 'org-mode-map
  "h" (list :def #'selectrum/org-outline-headings :wk "headlines"))
#+end_src

** git
:PROPERTIES:
:ID: 87ba6613-6606-423c-84ec-f7c9ae10c9a6
:END:

#+begin_src emacs-lisp
(define-leader-key!
  :infix "g"
  ""  (list :ignore t           :wk "git")
  "c" (list :def #'magit-commit :wk "commit")
  "s" (list :def #'magit-status :wk "status"))
#+end_src
